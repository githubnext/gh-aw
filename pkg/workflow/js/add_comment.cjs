// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Generate footer with AI attribution and workflow installation instructions
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)
 * @param {string} workflowSourceURL - GitHub URL for the workflow source
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow
 * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow
 * @returns {string} Footer text
 */
function generateFooter(
  workflowName,
  runUrl,
  workflowSource,
  workflowSourceURL,
  triggeringIssueNumber,
  triggeringPRNumber,
  triggeringDiscussionNumber
) {
  let footer = `\n\n> _Generated by [${workflowName}](${runUrl})`;

  // Add reference to triggering issue/PR/discussion if available
  if (triggeringIssueNumber) {
    footer += ` for #${triggeringIssueNumber}`;
  } else if (triggeringPRNumber) {
    footer += ` for #${triggeringPRNumber}`;
  } else if (triggeringDiscussionNumber) {
    footer += ` for discussion #${triggeringDiscussionNumber}`;
  }

  footer += `_`;

  if (workflowSource && workflowSourceURL) {
    footer += `\n>\n> _To add this workflow: \`gh aw add ${workflowSource}\` · [usage guide](https://githubnext.github.io/gh-aw/tools/cli/)_`;
  }

  footer += "\n";
  return footer;
}

/**
 * Comment on a GitHub Discussion using GraphQL
 * @param {any} github - GitHub REST API instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} discussionNumber - Discussion number
 * @param {string} message - Comment body
 * @param {string|undefined} replyToId - Optional comment node ID to reply to (for threaded comments)
 * @returns {Promise<{id: string, html_url: string, discussion_url: string}>} Comment details
 */
async function commentOnDiscussion(github, owner, repo, discussionNumber, message, replyToId) {
  // 1. Retrieve discussion node ID
  const { repository } = await github.graphql(
    `
    query($owner: String!, $repo: String!, $num: Int!) {
      repository(owner: $owner, name: $repo) {
        discussion(number: $num) { 
          id 
          url
        }
      }
    }`,
    { owner, repo, num: discussionNumber }
  );

  if (!repository || !repository.discussion) {
    throw new Error(`Discussion #${discussionNumber} not found in ${owner}/${repo}`);
  }

  const discussionId = repository.discussion.id;
  const discussionUrl = repository.discussion.url;

  // 2. Add comment (with optional replyToId for threading)
  let result;
  if (replyToId) {
    // Create a threaded reply to an existing comment
    result = await github.graphql(
      `
      mutation($dId: ID!, $body: String!, $replyToId: ID!) {
        addDiscussionComment(input: { discussionId: $dId, body: $body, replyToId: $replyToId }) {
          comment { 
            id 
            body 
            createdAt 
            url
          }
        }
      }`,
      { dId: discussionId, body: message, replyToId }
    );
  } else {
    // Create a top-level comment on the discussion
    result = await github.graphql(
      `
      mutation($dId: ID!, $body: String!) {
        addDiscussionComment(input: { discussionId: $dId, body: $body }) {
          comment { 
            id 
            body 
            createdAt 
            url
          }
        }
      }`,
      { dId: discussionId, body: message }
    );
  }

  const comment = result.addDiscussionComment.comment;

  return {
    id: comment.id,
    html_url: comment.url,
    discussion_url: discussionUrl,
  };
}

async function main() {
  // Check if we're in staged mode
  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";
  const isDiscussionExplicit = process.env.GITHUB_AW_COMMENT_DISCUSSION === "true";

  // Read the validated output content from environment variable
  const agentOutputFile = process.env.GH_AW_AGENT_OUTPUT;
  if (!agentOutputFile) {
    core.info("No GH_AW_AGENT_OUTPUT environment variable found");
    return;
  }

  // Read agent output from file
  let outputContent;
  try {
    outputContent = require("fs").readFileSync(agentOutputFile, "utf8");
  } catch (error) {
    core.setFailed(`Error reading agent output file: ${error instanceof Error ? error.message : String(error)}`);
    return;
  }

  if (outputContent.trim() === "") {
    core.info("Agent output content is empty");
    return;
  }

  core.info(`Agent output content length: ${outputContent.length}`);

  // Parse the validated output JSON
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
    return;
  }

  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    core.info("No valid items found in agent output");
    return;
  }

  // Find all add-comment items
  const commentItems = validatedOutput.items.filter(/** @param {any} item */ item => item.type === "add_comment");
  if (commentItems.length === 0) {
    core.info("No add-comment items found in agent output");
    return;
  }

  core.info(`Found ${commentItems.length} add-comment item(s)`);

  // Helper function to get the repository URL for different purposes
  function getRepositoryUrl() {
    // For trial mode, use target repository for issue/PR URLs but execution context for action runs
    const targetRepoSlug = process.env.GH_AW_TARGET_REPO_SLUG;

    if (targetRepoSlug) {
      // Use target repository for issue/PR URLs in trial mode
      const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
      return `${githubServer}/${targetRepoSlug}`;
    } else if (context.payload.repository) {
      // Use execution context repository (default behavior)
      return context.payload.repository.html_url;
    } else {
      // Final fallback for action runs when context repo is not available
      const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
      return `${githubServer}/${context.repo.owner}/${context.repo.repo}`;
    }
  }

  // Helper function to get the target number (issue, discussion, or pull request)
  function getTargetNumber(item) {
    return item.item_number;
  }

  // Get the target configuration from environment variable
  const commentTarget = process.env.GH_AW_COMMENT_TARGET || "triggering";
  core.info(`Comment target configuration: ${commentTarget}`);

  // Check if we're in an issue, pull request, or discussion context
  const isIssueContext = context.eventName === "issues" || context.eventName === "issue_comment";
  const isPRContext =
    context.eventName === "pull_request" ||
    context.eventName === "pull_request_review" ||
    context.eventName === "pull_request_review_comment";
  const isDiscussionContext = context.eventName === "discussion" || context.eventName === "discussion_comment";
  const isDiscussion = isDiscussionContext || isDiscussionExplicit;

  // If in staged mode, emit step summary instead of creating comments
  if (isStaged) {
    let summaryContent = "## 🎭 Staged Mode Preview\n\n";
    summaryContent += "_Would add the following comments:_\n\n";

    // Show created items references if available
    const createdIssueUrl = process.env.GH_AW_CREATED_ISSUE_URL;
    const createdIssueNumber = process.env.GH_AW_CREATED_ISSUE_NUMBER;
    const createdDiscussionUrl = process.env.GH_AW_CREATED_DISCUSSION_URL;
    const createdDiscussionNumber = process.env.GH_AW_CREATED_DISCUSSION_NUMBER;
    const createdPullRequestUrl = process.env.GH_AW_CREATED_PULL_REQUEST_URL;
    const createdPullRequestNumber = process.env.GH_AW_CREATED_PULL_REQUEST_NUMBER;

    if (createdIssueUrl || createdDiscussionUrl || createdPullRequestUrl) {
      const relatedParts = [];
      if (createdIssueUrl && createdIssueNumber) {
        relatedParts.push(`[#${createdIssueNumber}](${createdIssueUrl})`);
      }
      if (createdDiscussionUrl && createdDiscussionNumber) {
        relatedParts.push(`[Discussion #${createdDiscussionNumber}](${createdDiscussionUrl})`);
      }
      if (createdPullRequestUrl && createdPullRequestNumber) {
        relatedParts.push(`[PR #${createdPullRequestNumber}](${createdPullRequestUrl})`);
      }
      summaryContent += `_Related: ${relatedParts.join(" · ")}_\n\n`;
    }

    for (let i = 0; i < commentItems.length; i++) {
      const item = commentItems[i];
      summaryContent += `### Comment ${i + 1}\n\n`;
      const targetNumber = getTargetNumber(item);
      if (targetNumber) {
        const repoUrl = getRepositoryUrl();
        if (isDiscussion) {
          const discussionUrl = `${repoUrl}/discussions/${targetNumber}`;
          summaryContent += `_Target: [Discussion #${targetNumber}](${discussionUrl})_\n\n`;
        } else {
          const issueUrl = `${repoUrl}/issues/${targetNumber}`;
          summaryContent += `_Target: [#${targetNumber}](${issueUrl})_\n\n`;
        }
      } else {
        if (isDiscussion) {
          summaryContent += `_Target: Current discussion_\n\n`;
        } else {
          summaryContent += `_Target: Current issue/PR_\n\n`;
        }
      }
      summaryContent += `${item.body || "No content provided"}\n\n`;
      summaryContent += "---\n\n";
    }

    // Write to step summary
    await core.summary.addRaw(summaryContent).write();
    core.info("📝 Comment creation preview written to step summary");
    return;
  }

  // Validate context based on target configuration
  if (commentTarget === "triggering" && !isIssueContext && !isPRContext && !isDiscussionContext) {
    core.info('Target is "triggering" but not running in issue, pull request, or discussion context, skipping comment creation');
    return;
  }

  // Extract triggering context for footer generation
  const triggeringIssueNumber =
    context.payload?.issue?.number && !context.payload?.issue?.pull_request ? context.payload.issue.number : undefined;
  const triggeringPRNumber =
    context.payload?.pull_request?.number || (context.payload?.issue?.pull_request ? context.payload.issue.number : undefined);
  const triggeringDiscussionNumber = context.payload?.discussion?.number;

  const createdComments = [];

  // Process each comment item
  for (let i = 0; i < commentItems.length; i++) {
    const commentItem = commentItems[i];
    core.info(`Processing add-comment item ${i + 1}/${commentItems.length}: bodyLength=${commentItem.body.length}`);

    // Determine the issue/PR number and comment endpoint for this comment
    let itemNumber;
    let commentEndpoint;

    if (commentTarget === "*") {
      // For target "*", we need an explicit number from the comment item
      const targetNumber = getTargetNumber(commentItem);
      if (targetNumber) {
        itemNumber = parseInt(targetNumber, 10);
        if (isNaN(itemNumber) || itemNumber <= 0) {
          core.info(`Invalid target number specified: ${targetNumber}`);
          continue;
        }
        commentEndpoint = isDiscussion ? "discussions" : "issues";
      } else {
        core.info(`Target is "*" but no number specified in comment item`);
        continue;
      }
    } else if (commentTarget && commentTarget !== "triggering") {
      // Explicit number specified in target configuration
      itemNumber = parseInt(commentTarget, 10);
      if (isNaN(itemNumber) || itemNumber <= 0) {
        core.info(`Invalid target number in target configuration: ${commentTarget}`);
        continue;
      }
      commentEndpoint = isDiscussion ? "discussions" : "issues";
    } else {
      // Default behavior: use triggering issue/PR/discussion
      if (isIssueContext) {
        itemNumber = context.payload.issue?.number || context.payload.pull_request?.number || context.payload.discussion?.number;
        if (context.payload.issue) {
          commentEndpoint = "issues";
        } else {
          core.info("Issue context detected but no issue found in payload");
          continue;
        }
      } else if (isPRContext) {
        itemNumber = context.payload.pull_request?.number || context.payload.issue?.number || context.payload.discussion?.number;
        if (context.payload.pull_request) {
          commentEndpoint = "issues"; // PR comments use the issues API endpoint
        } else {
          core.info("Pull request context detected but no pull request found in payload");
          continue;
        }
      } else if (isDiscussionContext) {
        itemNumber = context.payload.discussion?.number || context.payload.issue?.number || context.payload.pull_request?.number;
        if (context.payload.discussion) {
          commentEndpoint = "discussions"; // Discussion comments use GraphQL via commentOnDiscussion
        } else {
          core.info("Discussion context detected but no discussion found in payload");
          continue;
        }
      }
    }

    if (!itemNumber) {
      core.info("Could not determine issue, pull request, or discussion number");
      continue;
    }

    // Extract body from the JSON item
    let body = commentItem.body.trim();

    // Append references to created issues, discussions, and pull requests if they exist
    const createdIssueUrl = process.env.GH_AW_CREATED_ISSUE_URL;
    const createdIssueNumber = process.env.GH_AW_CREATED_ISSUE_NUMBER;
    const createdDiscussionUrl = process.env.GH_AW_CREATED_DISCUSSION_URL;
    const createdDiscussionNumber = process.env.GH_AW_CREATED_DISCUSSION_NUMBER;
    const createdPullRequestUrl = process.env.GH_AW_CREATED_PULL_REQUEST_URL;
    const createdPullRequestNumber = process.env.GH_AW_CREATED_PULL_REQUEST_NUMBER;

    // Add references section if any URLs are available
    const relatedParts = [];

    if (createdIssueUrl && createdIssueNumber) {
      relatedParts.push(`[#${createdIssueNumber}](${createdIssueUrl})`);
    }
    if (createdDiscussionUrl && createdDiscussionNumber) {
      relatedParts.push(`[Discussion #${createdDiscussionNumber}](${createdDiscussionUrl})`);
    }
    if (createdPullRequestUrl && createdPullRequestNumber) {
      relatedParts.push(`[PR #${createdPullRequestNumber}](${createdPullRequestUrl})`);
    }

    if (relatedParts.length > 0) {
      body += `\n\n_Related: ${relatedParts.join(" · ")}_`;
    }

    // Add AI disclaimer with workflow name and run url
    const workflowName = process.env.GH_AW_WORKFLOW_NAME || "Workflow";
    const workflowSource = process.env.GH_AW_WORKFLOW_SOURCE || "";
    const workflowSourceURL = process.env.GH_AW_WORKFLOW_SOURCE_URL || "";
    const runId = context.runId;
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    const runUrl = context.payload.repository
      ? `${context.payload.repository.html_url}/actions/runs/${runId}`
      : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
    body += generateFooter(
      workflowName,
      runUrl,
      workflowSource,
      workflowSourceURL,
      triggeringIssueNumber,
      triggeringPRNumber,
      triggeringDiscussionNumber
    );

    try {
      let comment;

      // Use GraphQL API for discussions, REST API for issues/PRs
      if (commentEndpoint === "discussions") {
        core.info(`Creating comment on discussion #${itemNumber}`);
        core.info(`Comment content length: ${body.length}`);

        // For discussion_comment events, extract the comment node_id to create a threaded reply
        let replyToId;
        if (context.eventName === "discussion_comment" && context.payload?.comment?.node_id) {
          replyToId = context.payload.comment.node_id;
          core.info(`Creating threaded reply to comment ${replyToId}`);
        }

        // Create discussion comment using GraphQL
        comment = await commentOnDiscussion(github, context.repo.owner, context.repo.repo, itemNumber, body, replyToId);
        core.info("Created discussion comment #" + comment.id + ": " + comment.html_url);

        // Add discussion_url to the comment object for consistency
        comment.discussion_url = comment.discussion_url;
      } else {
        core.info(`Creating comment on ${commentEndpoint} #${itemNumber}`);
        core.info(`Comment content length: ${body.length}`);

        // Create regular issue/PR comment using REST API
        const { data: restComment } = await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: itemNumber,
          body: body,
        });

        comment = restComment;
        core.info("Created comment #" + comment.id + ": " + comment.html_url);
      }

      createdComments.push(comment);

      // Set output for the last created comment (for backward compatibility)
      if (i === commentItems.length - 1) {
        core.setOutput("comment_id", comment.id);
        core.setOutput("comment_url", comment.html_url);
      }
    } catch (error) {
      core.error(`✗ Failed to create comment: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  // Write summary for all created comments
  if (createdComments.length > 0) {
    let summaryContent = "\n\n## Created Comments\n";
    for (const comment of createdComments) {
      summaryContent += `- [View Comment #${comment.id}](${comment.html_url})\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }

  core.info(`Successfully created ${createdComments.length} comment(s)`);
  return createdComments;
}
await main();
