const{runLogParser}=require("./log_parser_bootstrap.cjs"),{truncateString,estimateTokens,formatToolCallAsDetails}=require("./log_parser_shared.cjs");function main(){runLogParser({parseLog:parseCodexLog,parserName:"Codex",supportsDirectories:!1})}function extractMCPInitialization(lines){const mcpServers=new Map;let serverCount=0,availableTools=[];for(const line of lines){line.includes("Initializing MCP servers")||line.includes("mcp")&&line.includes("init");const countMatch=line.match(/Found (\d+) MCP servers? in configuration/i);countMatch&&(serverCount=parseInt(countMatch[1]));const connectingMatch=line.match(/Connecting to MCP server[:\s]+['"]?(\w+)['"]?/i);if(connectingMatch){const serverName=connectingMatch[1];mcpServers.has(serverName)||mcpServers.set(serverName,{name:serverName,status:"connecting"})}const connectedMatch=line.match(/MCP server ['"](\w+)['"] connected successfully/i);if(connectedMatch){const serverName=connectedMatch[1];mcpServers.set(serverName,{name:serverName,status:"connected"})}const failedMatch=line.match(/Failed to connect to MCP server ['"](\w+)['"][:]\s*(.+)/i);if(failedMatch){const serverName=failedMatch[1],error=failedMatch[2].trim();mcpServers.set(serverName,{name:serverName,status:"failed",error})}const initFailedMatch=line.match(/MCP server ['"](\w+)['"] initialization failed/i);if(initFailedMatch){const serverName=initFailedMatch[1],existing=mcpServers.get(serverName);existing&&"failed"!==existing.status&&mcpServers.set(serverName,{name:serverName,status:"failed",error:"Initialization failed"})}const toolsMatch=line.match(/Available tools:\s*(.+)/i);toolsMatch&&(availableTools=toolsMatch[1].split(",").map(t=>t.trim()).filter(t=>t.length>0))}let markdown="";const hasInfo=mcpServers.size>0||availableTools.length>0;if(mcpServers.size>0){markdown+="**MCP Servers:**\n";const servers=Array.from(mcpServers.values()),connected=servers.filter(s=>"connected"===s.status),failed=servers.filter(s=>"failed"===s.status);markdown+=`- Total: ${servers.length}${serverCount>0&&servers.length!==serverCount?` (configured: ${serverCount})`:""}\n`,markdown+=`- Connected: ${connected.length}\n`,failed.length>0&&(markdown+=`- Failed: ${failed.length}\n`),markdown+="\n";for(const server of servers)markdown+=`- ${"connected"===server.status?"âœ…":"failed"===server.status?"âŒ":"â³"} **${server.name}** (${server.status})`,server.error&&(markdown+=`\n  - Error: ${server.error}`),markdown+="\n";markdown+="\n"}return availableTools.length>0&&(markdown+="**Available MCP Tools:**\n",markdown+=`- Total: ${availableTools.length} tools\n`,markdown+=`- Tools: ${availableTools.slice(0,10).join(", ")}${availableTools.length>10?", ...":""}\n\n`),{hasInfo,markdown,servers:Array.from(mcpServers.values())}}function parseCodexLog(logContent){try{const lines=logContent.split("\n"),LOOKAHEAD_WINDOW=50;let markdown="";const mcpInfo=extractMCPInitialization(lines);mcpInfo.hasInfo&&(markdown+="## ðŸš€ Initialization\n\n",markdown+=mcpInfo.markdown),markdown+="## ðŸ¤– Reasoning\n\n";let inThinkingSection=!1;for(let i=0;i<lines.length;i++){const line=lines[i];if(line.includes("OpenAI Codex")||line.startsWith("--------")||line.includes("workdir:")||line.includes("model:")||line.includes("provider:")||line.includes("approval:")||line.includes("sandbox:")||line.includes("reasoning effort:")||line.includes("reasoning summaries:")||line.includes("tokens used:")||line.includes("DEBUG codex")||line.includes("INFO codex")||line.match(/^\d{4}-\d{2}-\d{2}T[\d:.]+Z\s+(DEBUG|INFO|WARN|ERROR)/))continue;if("thinking"===line.trim()){inThinkingSection=!0;continue}const toolMatch=line.match(/^tool\s+(\w+)\.(\w+)\(/);if(toolMatch){inThinkingSection=!1;const server=toolMatch[1],toolName=toolMatch[2];let statusIcon="â“";for(let j=i+1;j<Math.min(i+LOOKAHEAD_WINDOW,lines.length);j++){const nextLine=lines[j];if(nextLine.includes(`${server}.${toolName}(`)&&nextLine.includes("success in")){statusIcon="âœ…";break}if(nextLine.includes(`${server}.${toolName}(`)&&(nextLine.includes("failed in")||nextLine.includes("error"))){statusIcon="âŒ";break}}markdown+=`${statusIcon} ${server}::${toolName}(...)\n\n`;continue}inThinkingSection&&line.trim().length>20&&!line.match(/^\d{4}-\d{2}-\d{2}T/)&&(markdown+=`${line.trim()}\n\n`)}markdown+="## ðŸ¤– Commands and Tools\n\n";for(let i=0;i<lines.length;i++){const line=lines[i],toolMatch=line.match(/^\[.*?\]\s+tool\s+(\w+)\.(\w+)\((.+)\)/)||line.match(/ToolCall:\s+(\w+)__(\w+)\s+(\{.+\})/),bashMatch=line.match(/^\[.*?\]\s+exec\s+bash\s+-lc\s+'([^']+)'/);if(toolMatch){const server=toolMatch[1],toolName=toolMatch[2],params=toolMatch[3];let statusIcon="â“",response="",isError=!1;for(let j=i+1;j<Math.min(i+LOOKAHEAD_WINDOW,lines.length);j++){const nextLine=lines[j];if(nextLine.includes(`${server}.${toolName}(`)&&(nextLine.includes("success in")||nextLine.includes("failed in"))){isError=nextLine.includes("failed in"),statusIcon=isError?"âŒ":"âœ…";let jsonLines=[],braceCount=0,inJson=!1;for(let k=j+1;k<Math.min(j+30,lines.length);k++){const respLine=lines[k];if(respLine.includes("tool ")||respLine.includes("ToolCall:")||respLine.includes("tokens used"))break;for(const char of respLine)"{"===char?(braceCount++,inJson=!0):"}"===char&&braceCount--;if(inJson&&jsonLines.push(respLine),inJson&&0===braceCount)break}response=jsonLines.join("\n");break}}markdown+=formatCodexToolCall(server,toolName,params,response,statusIcon)}else if(bashMatch){const command=bashMatch[1];let statusIcon="â“",response="",isError=!1;for(let j=i+1;j<Math.min(i+LOOKAHEAD_WINDOW,lines.length);j++){const nextLine=lines[j];if(nextLine.includes("bash -lc")&&(nextLine.includes("succeeded in")||nextLine.includes("failed in"))){isError=nextLine.includes("failed in"),statusIcon=isError?"âŒ":"âœ…";let responseLines=[];for(let k=j+1;k<Math.min(j+20,lines.length);k++){const respLine=lines[k];if(respLine.includes("tool ")||respLine.includes("exec ")||respLine.includes("ToolCall:")||respLine.includes("tokens used")||respLine.includes("thinking"))break;responseLines.push(respLine)}response=responseLines.join("\n").trim();break}}markdown+=formatCodexBashCall(command,response,statusIcon)}}markdown+="\n## ðŸ“Š Information\n\n";let totalTokens=0;const tokenCountMatches=logContent.matchAll(/total_tokens:\s*(\d+)/g);for(const match of tokenCountMatches){const tokens=parseInt(match[1]);totalTokens=Math.max(totalTokens,tokens)}const finalTokensMatch=logContent.match(/tokens used\n([\d,]+)/);finalTokensMatch&&(totalTokens=parseInt(finalTokensMatch[1].replace(/,/g,""))),totalTokens>0&&(markdown+=`**Total Tokens Used:** ${totalTokens.toLocaleString()}\n\n`);const toolCalls=(logContent.match(/ToolCall:\s+\w+__\w+/g)||[]).length;return toolCalls>0&&(markdown+=`**Tool Calls:** ${toolCalls}\n\n`),markdown}catch(error){return core.error(`Error parsing Codex log: ${error}`),"## ðŸ¤– Commands and Tools\n\nError parsing log content.\n\n## ðŸ¤– Reasoning\n\nUnable to parse reasoning from log.\n\n"}}function formatCodexToolCall(server,toolName,params,response,statusIcon){const totalTokens=estimateTokens(params)+estimateTokens(response);let metadata="";totalTokens>0&&(metadata=`<code>~${totalTokens}t</code>`);const summary=`<code>${server}::${toolName}</code>`,sections=[];return params&&params.trim()&&sections.push({label:"Parameters",content:params,language:"json"}),response&&response.trim()&&sections.push({label:"Response",content:response,language:"json"}),formatToolCallAsDetails({summary,statusIcon,metadata,sections})}function formatCodexBashCall(command,response,statusIcon){const totalTokens=estimateTokens(command)+estimateTokens(response);let metadata="";totalTokens>0&&(metadata=`<code>~${totalTokens}t</code>`);const summary=`<code>bash: ${truncateString(command,60)}</code>`,sections=[];return sections.push({label:"Command",content:command,language:"bash"}),response&&response.trim()&&sections.push({label:"Output",content:response}),formatToolCallAsDetails({summary,statusIcon,metadata,sections})}"undefined"!=typeof module&&module.exports&&(module.exports={parseCodexLog,formatCodexToolCall,formatCodexBashCall,extractMCPInitialization}),main();