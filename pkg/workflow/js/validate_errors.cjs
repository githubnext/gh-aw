function main(){const fs=require("fs"),path=require("path");core.info("Starting validate_errors.cjs script");const startTime=Date.now();try{const logPath=process.env.GH_AW_AGENT_OUTPUT;if(!logPath)throw new Error("GH_AW_AGENT_OUTPUT environment variable is required");if(core.info(`Log path: ${logPath}`),!fs.existsSync(logPath))return core.info(`Log path not found: ${logPath}`),void core.info("No logs to validate - skipping error validation");const patterns=getErrorPatternsFromEnv();if(0===patterns.length)throw new Error("GH_AW_ERROR_PATTERNS environment variable is required and must contain at least one pattern");core.info(`Loaded ${patterns.length} error patterns`),core.info(`Patterns: ${JSON.stringify(patterns.map(p=>({description:p.description,pattern:p.pattern})))}`);let content="";if(fs.statSync(logPath).isDirectory()){const logFiles=fs.readdirSync(logPath).filter(file=>file.endsWith(".log")||file.endsWith(".txt"));if(0===logFiles.length)return void core.info(`No log files found in directory: ${logPath}`);core.info(`Found ${logFiles.length} log files in directory`),logFiles.sort();for(const file of logFiles){const filePath=path.join(logPath,file),fileContent=fs.readFileSync(filePath,"utf8");core.info(`Reading log file: ${file} (${fileContent.length} bytes)`),content+=fileContent,content.length>0&&!content.endsWith("\n")&&(content+="\n")}}else content=fs.readFileSync(logPath,"utf8"),core.info(`Read single log file (${content.length} bytes)`);core.info(`Total log content size: ${content.length} bytes, ${content.split("\n").length} lines`);const hasErrors=validateErrors(content,patterns),elapsedTime=Date.now()-startTime;core.info(`Error validation completed in ${elapsedTime}ms`),hasErrors?core.error("Errors detected in agent logs - continuing workflow step (not failing for now)"):core.info("Error validation completed successfully")}catch(error){console.debug(error),core.error(`Error validating log: ${error instanceof Error?error.message:String(error)}`)}}function getErrorPatternsFromEnv(){const patternsEnv=process.env.GH_AW_ERROR_PATTERNS;if(!patternsEnv)throw new Error("GH_AW_ERROR_PATTERNS environment variable is required");try{const patterns=JSON.parse(patternsEnv);if(!Array.isArray(patterns))throw new Error("GH_AW_ERROR_PATTERNS must be a JSON array");return patterns}catch(e){throw new Error(`Failed to parse GH_AW_ERROR_PATTERNS as JSON: ${e instanceof Error?e.message:String(e)}`)}}function shouldSkipLine(line){const GITHUB_ACTIONS_TIMESTAMP=/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z\s+/;return!!(new RegExp(GITHUB_ACTIONS_TIMESTAMP.source+"GH_AW_ERROR_PATTERNS:").test(line)||/^\s+GH_AW_ERROR_PATTERNS:\s*\[/.test(line)||new RegExp(GITHUB_ACTIONS_TIMESTAMP.source+"env:").test(line)||/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z\s+\[DEBUG\]/.test(line))}function validateErrors(logContent,patterns){const lines=logContent.split("\n");let hasErrors=!1;core.info(`Starting error validation with ${patterns.length} patterns and ${lines.length} lines`);const validationStartTime=Date.now();let totalMatches=0,patternStats=[];for(let patternIndex=0;patternIndex<patterns.length;patternIndex++){const pattern=patterns[patternIndex],patternStartTime=Date.now();let regex,patternMatches=0;try{regex=new RegExp(pattern.pattern,"g"),core.info(`Pattern ${patternIndex+1}/${patterns.length}: ${pattern.description||"Unknown"} - regex: ${pattern.pattern}`)}catch(e){core.error(`invalid error regex pattern: ${pattern.pattern}`);continue}for(let lineIndex=0;lineIndex<lines.length;lineIndex++){const line=lines[lineIndex];if(shouldSkipLine(line))continue;if(line.length>1e4)continue;if(totalMatches>=100){core.warning(`Stopping error validation after finding ${totalMatches} matches (max: 100)`);break}let match,iterationCount=0,lastIndex=-1;for(;null!==(match=regex.exec(line));){if(iterationCount++,regex.lastIndex===lastIndex){core.error(`Infinite loop detected at line ${lineIndex+1}! Pattern: ${pattern.pattern}, lastIndex stuck at ${lastIndex}`),core.error(`Line content (truncated): ${truncateString(line,200)}`);break}if(lastIndex=regex.lastIndex,1e3===iterationCount&&(core.warning(`High iteration count (${iterationCount}) on line ${lineIndex+1} with pattern: ${pattern.description||pattern.pattern}`),core.warning(`Line content (truncated): ${truncateString(line,200)}`)),iterationCount>1e4){core.error(`Maximum iteration limit (10000) exceeded at line ${lineIndex+1}! Pattern: ${pattern.pattern}`),core.error(`Line content (truncated): ${truncateString(line,200)}`),core.error("This likely indicates a problematic regex pattern. Skipping remaining matches on this line.");break}const level=extractLevel(match,pattern),errorMessage=`Line ${lineIndex+1}: ${extractMessage(match,pattern,line)} (Pattern: ${pattern.description||"Unknown pattern"}, Raw log: ${truncateString(line.trim(),120)})`;"error"===level.toLowerCase()?(core.error(errorMessage),hasErrors=!0):core.warning(errorMessage),patternMatches++,totalMatches++}iterationCount>100&&core.info(`Line ${lineIndex+1} had ${iterationCount} matches for pattern: ${pattern.description||pattern.pattern}`)}const patternElapsed=Date.now()-patternStartTime;if(patternStats.push({description:pattern.description||"Unknown",pattern:pattern.pattern.substring(0,50)+(pattern.pattern.length>50?"...":""),matches:patternMatches,timeMs:patternElapsed}),patternElapsed>5e3&&core.warning(`Pattern "${pattern.description}" took ${patternElapsed}ms to process (${patternMatches} matches)`),totalMatches>=100){core.warning(`Stopping pattern processing after finding ${totalMatches} matches (max: 100)`);break}}const validationElapsed=Date.now()-validationStartTime;core.info(`Validation summary: ${totalMatches} total matches found in ${validationElapsed}ms`),patternStats.sort((a,b)=>b.timeMs-a.timeMs);const topSlow=patternStats.slice(0,5);return topSlow.length>0&&topSlow[0].timeMs>1e3&&(core.info("Top 5 slowest patterns:"),topSlow.forEach((stat,idx)=>{core.info(`  ${idx+1}. "${stat.description}" - ${stat.timeMs}ms (${stat.matches} matches)`)})),core.info(`Error validation completed. Errors found: ${hasErrors}`),hasErrors}function extractLevel(match,pattern){if(pattern.level_group&&pattern.level_group>0&&match[pattern.level_group])return match[pattern.level_group];const fullMatch=match[0];return fullMatch.toLowerCase().includes("error")?"error":fullMatch.toLowerCase().includes("warn")?"warning":"unknown"}function extractMessage(match,pattern,fullLine){return pattern.message_group&&pattern.message_group>0&&match[pattern.message_group]?match[pattern.message_group].trim():match[0]||fullLine.trim()}function truncateString(str,maxLength){return str?str.length<=maxLength?str:str.substring(0,maxLength)+"...":""}"undefined"!=typeof module&&module.exports&&(module.exports={validateErrors,extractLevel,extractMessage,getErrorPatternsFromEnv,truncateString,shouldSkipLine}),"undefined"!=typeof module&&require.main!==module||main();