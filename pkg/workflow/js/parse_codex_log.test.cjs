import{describe,it,expect,beforeEach,vi}from"vitest";describe("parse_codex_log.cjs",()=>{let mockCore,parseCodexLog,formatCodexToolCall,formatCodexBashCall,truncateString,estimateTokens,formatDuration,extractMCPInitialization;beforeEach(async()=>{mockCore={debug:vi.fn(),info:vi.fn(),warning:vi.fn(),error:vi.fn(),setFailed:vi.fn(),setOutput:vi.fn(),summary:{addRaw:vi.fn().mockReturnThis(),write:vi.fn().mockResolvedValue()}},global.core=mockCore;const module=await import("./parse_codex_log.cjs");parseCodexLog=module.parseCodexLog,formatCodexToolCall=module.formatCodexToolCall,formatCodexBashCall=module.formatCodexBashCall,extractMCPInitialization=module.extractMCPInitialization;const sharedModule=await import("./log_parser_shared.cjs");truncateString=sharedModule.truncateString,estimateTokens=sharedModule.estimateTokens,formatDuration=sharedModule.formatDuration}),describe("parseCodexLog function",()=>{it("should parse basic tool call with success",()=>{const result=parseCodexLog('tool github.list_pull_requests({"state":"open"})\ngithub.list_pull_requests(...) success in 123ms:\n{"items": [{"number": 1}]}');expect(result).toContain("## ğŸ¤– Reasoning"),expect(result).toContain("## ğŸ¤– Commands and Tools"),expect(result).toContain("github::list_pull_requests"),expect(result).toContain("âœ…")}),it("should parse tool call with failure",()=>{const result=parseCodexLog('tool github.create_issue({"title":"Test"})\ngithub.create_issue(...) failed in 456ms:\n{"error": "permission denied"}');expect(result).toContain("github::create_issue"),expect(result).toContain("âŒ")}),it("should parse thinking sections",()=>{const result=parseCodexLog("thinking\nI need to analyze the repository structure to understand the codebase\nLet me start by listing the files in the root directory");expect(result).toContain("## ğŸ¤– Reasoning"),expect(result).toContain("I need to analyze the repository structure"),expect(result).toContain("Let me start by listing the files")}),it("should skip metadata lines",()=>{const result=parseCodexLog("OpenAI Codex v1.0\n--------\nworkdir: /tmp/test\nmodel: gpt-4\nprovider: openai\nthinking\nThis is actual thinking content");expect(result).not.toContain("OpenAI Codex"),expect(result).not.toContain("workdir"),expect(result).not.toContain("model:"),expect(result).toContain("This is actual thinking content")}),it("should skip debug and timestamp lines",()=>{const result=parseCodexLog("DEBUG codex: starting session\n2024-01-15T12:30:00.000Z DEBUG processing request\nINFO codex: tool call completed\nthinking\nActual thinking content that is long enough to be included");expect(result).not.toContain("DEBUG codex"),expect(result).not.toContain("INFO codex"),expect(result).toContain("Actual thinking content")}),it("should parse bash commands",()=>{const result=parseCodexLog("[2024-01-15T12:30:00.000Z] exec bash -lc 'ls -la'\nbash -lc 'ls -la' succeeded in 50ms:\ntotal 8\n-rw-r--r-- 1 user user 100 Jan 15 12:30 file.txt");expect(result).toContain("bash: ls -la"),expect(result).toContain("âœ…")}),it("should extract total tokens from log",()=>{const result=parseCodexLog("tool github.list_issues({})\ntotal_tokens: 1500\ntokens used\n1,500");expect(result).toContain("ğŸ“Š Information"),expect(result).toContain("Total Tokens Used"),expect(result).toContain("1,500")}),it("should count tool calls",()=>{const result=parseCodexLog("ToolCall: github__list_issues {}\nToolCall: github__create_comment {}\nToolCall: github__add_labels {}");expect(result).toContain("**Tool Calls:** 3")}),it("should handle empty log content",()=>{const result=parseCodexLog("");expect(result).toContain("## ğŸ¤– Reasoning"),expect(result).toContain("## ğŸ¤– Commands and Tools")}),it("should handle log with errors gracefully",()=>{mockCore.error.mockImplementation(()=>{});const result=parseCodexLog(null);expect(result).toContain("Error parsing log content"),expect(mockCore.error).toHaveBeenCalled()}),it("should handle tool calls without responses",()=>{const result=parseCodexLog("tool github.list_issues({})");expect(result).toContain("github::list_issues"),expect(result).toContain("â“")}),it("should filter out short lines in thinking sections",()=>{const result=parseCodexLog("thinking\nShort\nThis is a long enough line to be included in the thinking section\nx");expect(result).toContain("This is a long enough line"),expect(result).not.toContain("Short\n\n"),expect(result).not.toContain("x\n\n")}),it("should handle ToolCall format",()=>{const result=parseCodexLog('ToolCall: github__create_issue {"title":"Test"}');expect(result).toContain("ğŸ“Š Information"),expect(result).toContain("**Tool Calls:** 1")}),it("should handle tokens with commas in final count",()=>{const result=parseCodexLog("tokens used\n12,345");expect(result).toContain("12,345")})}),describe("formatCodexToolCall function",()=>{it("should format tool call with response",()=>{const result=formatCodexToolCall("github","list_issues",'{"state":"open"}','{"items":[]}',"âœ…");expect(result).toContain("<details>"),expect(result).toContain("<summary>"),expect(result).toContain("github::list_issues"),expect(result).toContain("âœ…"),expect(result).toContain("Parameters:"),expect(result).toContain("Response:"),expect(result).toContain("```json")}),it("should format tool call without response - shows parameters in details",()=>{const result=formatCodexToolCall("github","create_issue",'{"title":"Test"}',"","âŒ");expect(result).toContain("<details>"),expect(result).toContain("github::create_issue"),expect(result).toContain("âŒ"),expect(result).toContain("Parameters:"),expect(result).not.toContain("Response:")}),it("should format tool call without any content - no details",()=>{const result=formatCodexToolCall("github","ping","","","âœ…");expect(result).not.toContain("<details>"),expect(result).toContain("github::ping"),expect(result).toContain("âœ…")}),it("should include token estimate",()=>{const result=formatCodexToolCall("github","get_issue",'{"number":123}','{"title":"Test issue"}',"âœ…");expect(result).toMatch(/~\d+t/)})}),describe("formatCodexBashCall function",()=>{it("should format bash call with output",()=>{const result=formatCodexBashCall("ls -la","file1.txt\nfile2.txt","âœ…");expect(result).toContain("<details>"),expect(result).toContain("bash: ls -la"),expect(result).toContain("âœ…"),expect(result).toContain("Command:"),expect(result).toContain("Output:")}),it("should format bash call without output - shows command in details",()=>{const result=formatCodexBashCall("mkdir test_dir","","âœ…");expect(result).toContain("<details>"),expect(result).toContain("bash: mkdir test_dir"),expect(result).toContain("âœ…"),expect(result).toContain("Command:"),expect(result).not.toContain("Output:")}),it("should truncate long commands",()=>{const longCommand="echo "+"x".repeat(100),result=formatCodexBashCall(longCommand,"output","âœ…");expect(result).toContain("..."),expect(result.split("...")[0].length).toBeLessThan(longCommand.length)})}),describe("truncateString function",()=>{it("should not truncate short strings",()=>{expect(truncateString("hello",10)).toBe("hello")}),it("should truncate long strings",()=>{expect(truncateString("hello world this is a long string",10)).toBe("hello worl...")}),it("should handle empty strings",()=>{expect(truncateString("",10)).toBe("")}),it("should handle null/undefined",()=>{expect(truncateString(null,10)).toBe(""),expect(truncateString(void 0,10)).toBe("")})}),describe("estimateTokens function",()=>{it("should estimate tokens using 4 chars per token",()=>{expect(estimateTokens("1234")).toBe(1),expect(estimateTokens("12345678")).toBe(2)}),it("should handle empty strings",()=>{expect(estimateTokens("")).toBe(0)}),it("should handle null/undefined",()=>{expect(estimateTokens(null)).toBe(0),expect(estimateTokens(void 0)).toBe(0)}),it("should round up",()=>{expect(estimateTokens("123")).toBe(1),expect(estimateTokens("12345")).toBe(2)})}),describe("formatDuration function",()=>{it("should format seconds",()=>{expect(formatDuration(1e3)).toBe("1s"),expect(formatDuration(5e3)).toBe("5s"),expect(formatDuration(59e3)).toBe("59s")}),it("should format minutes",()=>{expect(formatDuration(6e4)).toBe("1m"),expect(formatDuration(12e4)).toBe("2m")}),it("should format minutes and seconds",()=>{expect(formatDuration(9e4)).toBe("1m 30s"),expect(formatDuration(125e3)).toBe("2m 5s")}),it("should handle zero or negative values",()=>{expect(formatDuration(0)).toBe(""),expect(formatDuration(-1e3)).toBe("")}),it("should handle null/undefined",()=>{expect(formatDuration(null)).toBe(""),expect(formatDuration(void 0)).toBe("")}),it("should round to nearest second",()=>{expect(formatDuration(1499)).toBe("1s"),expect(formatDuration(1500)).toBe("2s")})}),describe("extractMCPInitialization function",()=>{it("should extract MCP server initialization",()=>{const result=extractMCPInitialization(["2025-01-15T12:00:00.123Z DEBUG codex_core::mcp: Initializing MCP servers from config","2025-01-15T12:00:00.234Z DEBUG codex_core::mcp: Found 3 MCP servers in configuration","2025-01-15T12:00:00.345Z DEBUG codex_core::mcp::client: Connecting to MCP server: github","2025-01-15T12:00:01.567Z INFO codex_core::mcp::client: MCP server 'github' connected successfully"]);expect(result.hasInfo).toBe(!0),expect(result.markdown).toContain("**MCP Servers:**"),expect(result.markdown).toContain("github"),expect(result.markdown).toContain("âœ…"),expect(result.markdown).toContain("connected"),expect(result.servers).toHaveLength(1),expect(result.servers[0].name).toBe("github"),expect(result.servers[0].status).toBe("connected")}),it("should detect failed MCP server connections",()=>{const result=extractMCPInitialization(["2025-01-15T12:00:00.345Z DEBUG codex_core::mcp::client: Connecting to MCP server: time","2025-01-15T12:00:02.123Z ERROR codex_core::mcp::client: Failed to connect to MCP server 'time': Connection timeout"]);expect(result.hasInfo).toBe(!0),expect(result.markdown).toContain("âŒ"),expect(result.markdown).toContain("time"),expect(result.markdown).toContain("failed"),expect(result.markdown).toContain("Connection timeout"),expect(result.servers).toHaveLength(1),expect(result.servers[0].status).toBe("failed"),expect(result.servers[0].error).toBe("Connection timeout")}),it("should extract available MCP tools",()=>{const result=extractMCPInitialization(["2025-01-15T12:00:02.678Z INFO codex_core: Available tools: github.list_issues, github.create_comment, safe_outputs.create_issue"]);expect(result.hasInfo).toBe(!0),expect(result.markdown).toContain("**Available MCP Tools:**"),expect(result.markdown).toContain("3 tools"),expect(result.markdown).toContain("github.list_issues")}),it("should handle multiple MCP servers with mixed status",()=>{const result=extractMCPInitialization(["2025-01-15T12:00:00.234Z DEBUG codex_core::mcp: Found 3 MCP servers in configuration","2025-01-15T12:00:00.345Z DEBUG codex_core::mcp::client: Connecting to MCP server: github","2025-01-15T12:00:01.567Z INFO codex_core::mcp::client: MCP server 'github' connected successfully","2025-01-15T12:00:01.789Z DEBUG codex_core::mcp::client: Connecting to MCP server: time","2025-01-15T12:00:02.123Z ERROR codex_core::mcp::client: Failed to connect to MCP server 'time': Connection timeout","2025-01-15T12:00:02.345Z DEBUG codex_core::mcp::client: Connecting to MCP server: safe_outputs","2025-01-15T12:00:02.456Z INFO codex_core::mcp::client: MCP server 'safe_outputs' connected successfully","2025-01-15T12:00:02.567Z DEBUG codex_core::mcp: MCP initialization complete: 2/3 servers connected"]);expect(result.hasInfo).toBe(!0),expect(result.markdown).toContain("Total: 3"),expect(result.markdown).toContain("Connected: 2"),expect(result.markdown).toContain("Failed: 1"),expect(result.servers).toHaveLength(3);const github=result.servers.find(s=>"github"===s.name),time=result.servers.find(s=>"time"===s.name),safeOutputs=result.servers.find(s=>"safe_outputs"===s.name);expect(github.status).toBe("connected"),expect(time.status).toBe("failed"),expect(safeOutputs.status).toBe("connected")}),it("should handle logs with no MCP information",()=>{const result=extractMCPInitialization(["[2025-08-31T12:37:08] OpenAI Codex v0.27.0 (research preview)","--------","workdir: /home/runner/work/gh-aw/gh-aw"]);expect(result.hasInfo).toBe(!1),expect(result.markdown).toBe(""),expect(result.servers).toHaveLength(0)}),it("should handle initialization failed pattern",()=>{const result=extractMCPInitialization(["2025-01-15T12:00:01.789Z DEBUG codex_core::mcp::client: Connecting to MCP server: custom","2025-01-15T12:00:02.234Z WARN codex_core::mcp: MCP server 'custom' initialization failed, continuing without it"]);expect(result.hasInfo).toBe(!0),expect(result.markdown).toContain("custom"),expect(result.markdown).toContain("failed"),expect(result.servers[0].status).toBe("failed"),expect(result.servers[0].error).toBe("Initialization failed")}),it("should truncate tool list if too many tools",()=>{const tools=Array.from({length:15},(_,i)=>`tool${i}`).join(", "),result=extractMCPInitialization([`2025-01-15T12:00:02.678Z INFO codex_core: Available tools: ${tools}`]);expect(result.hasInfo).toBe(!0),expect(result.markdown).toContain("15 tools"),expect(result.markdown).toContain("...")})}),describe("parseCodexLog with MCP initialization",()=>{it("should include MCP initialization section when present",()=>{const result=parseCodexLog("2025-01-15T12:00:00.123Z DEBUG codex_core::mcp: Initializing MCP servers from config\n2025-01-15T12:00:00.234Z DEBUG codex_core::mcp: Found 2 MCP servers in configuration\n2025-01-15T12:00:00.345Z DEBUG codex_core::mcp::client: Connecting to MCP server: github\n2025-01-15T12:00:01.567Z INFO codex_core::mcp::client: MCP server 'github' connected successfully\n2025-01-15T12:00:01.789Z DEBUG codex_core::mcp::client: Connecting to MCP server: safe_outputs\n2025-01-15T12:00:02.456Z INFO codex_core::mcp::client: MCP server 'safe_outputs' connected successfully\nthinking\nI will now use the GitHub API to list issues");expect(result).toContain("## ğŸš€ Initialization"),expect(result).toContain("**MCP Servers:**"),expect(result).toContain("Total: 2"),expect(result).toContain("Connected: 2"),expect(result).toContain("âœ…"),expect(result).toContain("github"),expect(result).toContain("safe_outputs"),expect(result).toContain("## ğŸ¤– Reasoning")}),it("should skip initialization section when no MCP info present",()=>{const result=parseCodexLog("[2025-08-31T12:37:08] OpenAI Codex v0.27.0\nthinking\nI will analyze the code");expect(result).not.toContain("## ğŸš€ Initialization"),expect(result).toContain("## ğŸ¤– Reasoning")})})});