/**
 * Network permissions validator for Claude Code engine.
 * Generated by gh-aw from engine network permissions configuration.
 * This validates network requests by reading JSON from stdin and outputting validation results.
 */

/**
 * Extract domain from URL or search query.
 * @param {string|undefined} urlOrQuery - The URL or search query to extract domain from
 * @returns {string|null} The extracted domain or null if none found
 */
function extractDomain(urlOrQuery) {
  if (!urlOrQuery) {
    return null;
  }

  if (urlOrQuery.startsWith("http://") || urlOrQuery.startsWith("https://")) {
    try {
      const url = new URL(urlOrQuery);
      return url.hostname.toLowerCase();
    } catch (error) {
      return null;
    }
  }

  // Check for domain patterns in search queries
  const siteMatch = urlOrQuery.match(/site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  if (siteMatch) {
    return siteMatch[1].toLowerCase();
  }

  return null;
}

/**
 * Check if domain is allowed based on the allowed domains list.
 * @param {string|null} domain - The domain to check
 * @param {string[]} allowedDomains - List of allowed domain patterns
 * @returns {boolean} True if domain is allowed, false otherwise
 */
function isDomainAllowed(domain, allowedDomains) {
  if (!domain) {
    // If no domain detected, allow only if not under deny-all policy
    return allowedDomains.length > 0; // False if empty list (deny-all), True if has domains
  }

  // Empty allowed domains means deny all
  if (allowedDomains.length === 0) {
    return false;
  }

  for (const pattern of allowedDomains) {
    // Convert wildcard pattern to regex
    const regex = pattern.replace(/\./g, "\\.").replace(/\*/g, ".*");
    const regexPattern = new RegExp(`^${regex}$`);
    if (regexPattern.test(domain)) {
      return true;
    }
  }
  return false;
}

/**
 * Main validation logic for use as a GitHub Action
 */
async function main() {
  try {
    // Get the allowed domains from the GitHub Actions input
    const allowedDomainsInput = core.getInput("allowed_domains", { required: true });

    /** @type {string[]} */
    let allowedDomains;
    try {
      allowedDomains = JSON.parse(allowedDomainsInput);
    } catch (error) {
      core.setFailed(`Error parsing allowed_domains input: ${error instanceof Error ? error.message : String(error)}`);
      return;
    }

    // Get the tool data from the GitHub Actions input
    const toolDataInput = core.getInput("tool_data", { required: true });

    /** @type {any} */
    let data;
    try {
      data = JSON.parse(toolDataInput);
    } catch (error) {
      core.setFailed(`Error parsing tool_data input: ${error instanceof Error ? error.message : String(error)}`);
      return;
    }

    const toolName = data.tool_name || "";
    const toolInput = data.tool_input || {};

    if (!["WebFetch", "WebSearch"].includes(toolName)) {
      core.info(`Tool ${toolName} is not subject to network restrictions, allowing`);
      core.setOutput("allowed", "true");
      return;
    }

    const target = toolInput.url || toolInput.query || "";
    const domain = extractDomain(target);

    // For WebSearch, apply domain restrictions consistently
    // If no domain detected in search query, check if restrictions are in place
    if (toolName === "WebSearch" && !domain) {
      // Since this hook is only generated when network permissions are configured,
      // empty allowedDomains means deny-all policy
      if (allowedDomains.length === 0) {
        core.error("Network access blocked: deny-all policy in effect");
        core.error("No domains are allowed for WebSearch");
        core.setOutput("allowed", "false");
        core.setOutput("reason", "deny-all policy in effect");
        return;
      } else {
        core.error("Network access blocked for web-search: no specific domain detected");
        core.error(`Allowed domains: ${allowedDomains.join(", ")}`);
        core.setOutput("allowed", "false");
        core.setOutput("reason", "no specific domain detected");
        return;
      }
    }

    if (!isDomainAllowed(domain, allowedDomains)) {
      core.error(`Network access blocked for domain: ${domain}`);
      core.error(`Allowed domains: ${allowedDomains.join(", ")}`);
      core.setOutput("allowed", "false");
      core.setOutput("reason", `domain ${domain} not allowed`);
      return;
    }

    core.info(`Network access allowed for domain: ${domain}`);
    core.setOutput("allowed", "true");
  } catch (error) {
    core.error(`Network validation error: ${error instanceof Error ? error.message : String(error)}`);
    core.setOutput("allowed", "false");
    core.setOutput("reason", "validation error");
  }
}

// Export the functions for testing and use as a module
if (typeof module !== "undefined" && module.exports) {
  module.exports = { main, extractDomain, isDomainAllowed };
}

// If running in GitHub Actions context (core is available), run main
if (typeof core !== "undefined") {
  main().catch(error => {
    core.setFailed(error instanceof Error ? error.message : String(error));
  });
}
