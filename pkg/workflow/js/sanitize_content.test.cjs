import{describe,it,expect,beforeEach,afterEach,vi}from"vitest";describe("sanitize_content.cjs",()=>{let mockCore,sanitizeContent;beforeEach(async()=>{mockCore={debug:vi.fn(),info:vi.fn(),warning:vi.fn(),error:vi.fn()},global.core=mockCore;const module=await import("./sanitize_content.cjs");sanitizeContent=module.sanitizeContent}),afterEach(()=>{delete global.core,delete process.env.GH_AW_ALLOWED_DOMAINS,delete process.env.GH_AW_COMMAND,delete process.env.GITHUB_SERVER_URL,delete process.env.GITHUB_API_URL}),describe("basic sanitization",()=>{it("should return empty string for null or undefined input",()=>{expect(sanitizeContent(null)).toBe(""),expect(sanitizeContent(void 0)).toBe("")}),it("should return empty string for non-string input",()=>{expect(sanitizeContent(123)).toBe(""),expect(sanitizeContent({})).toBe(""),expect(sanitizeContent([])).toBe("")}),it("should trim whitespace",()=>{expect(sanitizeContent("  hello world  ")).toBe("hello world"),expect(sanitizeContent("\n\thello\n\t")).toBe("hello")}),it("should preserve normal text",()=>{expect(sanitizeContent("Hello, this is normal text.")).toBe("Hello, this is normal text.")})}),describe("command neutralization",()=>{beforeEach(()=>{process.env.GH_AW_COMMAND="bot"}),it("should neutralize command at start of text",()=>{const result=sanitizeContent("/bot do something");expect(result).toBe("`/bot` do something")}),it("should neutralize command after whitespace",()=>{const result=sanitizeContent("  /bot do something");expect(result).toBe("`/bot` do something")}),it("should not neutralize command in middle of text",()=>{const result=sanitizeContent("hello /bot world");expect(result).toBe("hello /bot world")}),it("should handle special regex characters in command name",()=>{process.env.GH_AW_COMMAND="my-bot+test";const result=sanitizeContent("/my-bot+test action");expect(result).toBe("`/my-bot+test` action")}),it("should not neutralize when no command is set",()=>{delete process.env.GH_AW_COMMAND;const result=sanitizeContent("/bot do something");expect(result).toBe("/bot do something")})}),describe("@mention neutralization",()=>{it("should neutralize @mentions",()=>{const result=sanitizeContent("Hello @user");expect(result).toBe("Hello `@user`")}),it("should neutralize @org/team mentions",()=>{const result=sanitizeContent("Hello @myorg/myteam");expect(result).toBe("Hello `@myorg/myteam`")}),it("should not neutralize @mentions already in backticks",()=>{const result=sanitizeContent("Already `@user` mentioned");expect(result).toBe("Already `@user` mentioned")}),it("should neutralize multiple @mentions",()=>{const result=sanitizeContent("@user1 and @user2 are here");expect(result).toBe("`@user1` and `@user2` are here")}),it("should not neutralize email addresses",()=>{const result=sanitizeContent("Contact email@example.com");expect(result).toBe("Contact email@example.com")})}),describe("@mention allowedAliases",()=>{it("should not neutralize mentions in allowedAliases list",()=>{const result=sanitizeContent("Hello @author",{allowedAliases:["author"]});expect(result).toBe("Hello @author")}),it("should neutralize mentions not in allowedAliases list",()=>{const result=sanitizeContent("Hello @other",{allowedAliases:["author"]});expect(result).toBe("Hello `@other`")}),it("should handle multiple mentions with some allowed",()=>{const result=sanitizeContent("Hello @author and @other",{allowedAliases:["author"]});expect(result).toBe("Hello @author and `@other`")}),it("should handle case-insensitive matching for allowedAliases",()=>{const result=sanitizeContent("Hello @Author",{allowedAliases:["author"]});expect(result).toBe("Hello @Author")}),it("should handle multiple allowed aliases",()=>{const result=sanitizeContent("Hello @user1 and @user2 and @other",{allowedAliases:["user1","user2"]});expect(result).toBe("Hello @user1 and @user2 and `@other`")}),it("should work with options object containing both maxLength and allowedAliases",()=>{const result=sanitizeContent("Hello @author and @other",{maxLength:524288,allowedAliases:["author"]});expect(result).toBe("Hello @author and `@other`")}),it("should handle empty allowedAliases array",()=>{const result=sanitizeContent("Hello @user",{allowedAliases:[]});expect(result).toBe("Hello `@user`")}),it("should not neutralize org/team mentions in allowedAliases",()=>{const result=sanitizeContent("Hello @myorg/myteam",{allowedAliases:["myorg/myteam"]});expect(result).toBe("Hello @myorg/myteam")}),it("should preserve backward compatibility with numeric maxLength parameter",()=>{const result=sanitizeContent("Hello @user",524288);expect(result).toBe("Hello `@user`")}),it("should log escaped mentions for debugging",()=>{const result=sanitizeContent("Hello @user1 and @user2",{allowedAliases:["user1"]});expect(result).toBe("Hello @user1 and `@user2`"),expect(mockCore.info).toHaveBeenCalledWith("Escaped mention: @user2 (not in allowed list)")}),it("should log multiple escaped mentions",()=>{const result=sanitizeContent("@user1 @user2 @user3",{allowedAliases:["user1"]});expect(result).toBe("@user1 `@user2` `@user3`"),expect(mockCore.info).toHaveBeenCalledWith("Escaped mention: @user2 (not in allowed list)"),expect(mockCore.info).toHaveBeenCalledWith("Escaped mention: @user3 (not in allowed list)")}),it("should not log when all mentions are allowed",()=>{const result=sanitizeContent("Hello @user1 and @user2",{allowedAliases:["user1","user2"]});expect(result).toBe("Hello @user1 and @user2");const escapedMentionCalls=mockCore.info.mock.calls.filter(call=>call[0].includes("Escaped mention"));expect(escapedMentionCalls).toHaveLength(0)})}),describe("XML comments removal",()=>{it("should remove XML comments",()=>{const result=sanitizeContent("Hello \x3c!-- comment --\x3e world");expect(result).toBe("Hello  world")}),it("should remove malformed XML comments",()=>{const result=sanitizeContent("Hello \x3c!--! comment --!> world");expect(result).toBe("Hello  world")}),it("should remove multiline XML comments",()=>{const result=sanitizeContent("Hello \x3c!-- multi\nline\ncomment --\x3e world");expect(result).toBe("Hello  world")})}),describe("XML/HTML tag conversion",()=>{it("should convert opening tags to parentheses",()=>{const result=sanitizeContent("Hello <div>world</div>");expect(result).toBe("Hello (div)world(/div)")}),it("should convert tags with attributes to parentheses",()=>{const result=sanitizeContent('<div class="test">content</div>');expect(result).toBe('(div class="test")content(/div)')}),it("should preserve allowed safe tags",()=>{["b","blockquote","br","code","details","em","h1","h2","h3","h4","h5","h6","hr","i","li","ol","p","pre","strong","sub","summary","sup","table","tbody","td","th","thead","tr","ul"].forEach(tag=>{const result=sanitizeContent(`<${tag}>content</${tag}>`);expect(result).toBe(`<${tag}>content</${tag}>`)})}),it("should preserve self-closing br tags",()=>{const result=sanitizeContent("Hello <br/> world");expect(result).toBe("Hello <br/> world")}),it("should preserve br tags without slash",()=>{const result=sanitizeContent("Hello <br> world");expect(result).toBe("Hello <br> world")}),it("should convert self-closing tags that are not allowed",()=>{const result=sanitizeContent("Hello <img/> world");expect(result).toBe("Hello (img/) world")}),it("should handle CDATA sections",()=>{const result=sanitizeContent("<![CDATA[<script>alert('xss')<\/script>]]>");expect(result).toBe("(![CDATA[(script)alert('xss')(/script)]])")}),it("should preserve inline formatting tags",()=>{const input="This is <strong>bold</strong>, <i>italic</i>, and <b>bold too</b> text.",result=sanitizeContent(input);expect(result).toBe(input)}),it("should preserve list structure tags",()=>{const input="<ul><li>Item 1</li><li>Item 2</li></ul>",result=sanitizeContent(input);expect(result).toBe(input)}),it("should preserve ordered list tags",()=>{const input="<ol><li>First</li><li>Second</li></ol>",result=sanitizeContent(input);expect(result).toBe(input)}),it("should preserve blockquote tags",()=>{const input="<blockquote>This is a quote</blockquote>",result=sanitizeContent(input);expect(result).toBe(input)}),it("should handle mixed allowed tags with formatting",()=>{const input="<p>This is <strong>bold</strong> and <em>italic</em> text.<br>New line here.</p>",result=sanitizeContent(input);expect(result).toBe(input)}),it("should handle nested list structure",()=>{const input="<ul><li>Item 1<ul><li>Nested item</li></ul></li><li>Item 2</li></ul>",result=sanitizeContent(input);expect(result).toBe(input)}),it("should preserve details and summary tags",()=>{const result1=sanitizeContent("<details>content</details>");expect(result1).toBe("<details>content</details>");const result2=sanitizeContent("<summary>content</summary>");expect(result2).toBe("<summary>content</summary>")}),it("should convert removed tags that are no longer allowed",()=>{const result3=sanitizeContent("<u>content</u>");expect(result3).toBe("(u)content(/u)")}),it("should preserve heading tags h1-h6",()=>{["h1","h2","h3","h4","h5","h6"].forEach(tag=>{const input=`<${tag}>Heading</${tag}>`,result=sanitizeContent(input);expect(result).toBe(input)})}),it("should preserve hr tag",()=>{const result=sanitizeContent("Content before<hr>Content after");expect(result).toBe("Content before<hr>Content after")}),it("should preserve pre tag",()=>{const input="<pre>Code block content</pre>",result=sanitizeContent(input);expect(result).toBe(input)}),it("should preserve sub and sup tags",()=>{const result1=sanitizeContent("H<sub>2</sub>O");expect(result1).toBe("H<sub>2</sub>O");const result2=sanitizeContent("E=mc<sup>2</sup>");expect(result2).toBe("E=mc<sup>2</sup>")}),it("should preserve table structure tags",()=>{const input="<table><thead><tr><th>Header</th></tr></thead><tbody><tr><td>Data</td></tr></tbody></table>",result=sanitizeContent(input);expect(result).toBe(input)})}),describe("ANSI escape sequence removal",()=>{it("should remove ANSI color codes",()=>{const result=sanitizeContent("[31mred text[0m");expect(result).toBe("red text")}),it("should remove various ANSI codes",()=>{const result=sanitizeContent("[1;32mBold Green[0m");expect(result).toBe("Bold Green")})}),describe("control character removal",()=>{it("should remove control characters",()=>{const result=sanitizeContent("test\0content");expect(result).toBe("testcontent")}),it("should preserve newlines and tabs",()=>{const result=sanitizeContent("test\ncontent\twith\ttabs");expect(result).toBe("test\ncontent\twith\ttabs")}),it("should remove DEL character",()=>{const result=sanitizeContent("testcontent");expect(result).toBe("testcontent")})}),describe("URL protocol sanitization",()=>{it("should allow HTTPS URLs",()=>{const result=sanitizeContent("Visit https://github.com");expect(result).toBe("Visit https://github.com")}),it("should redact HTTP URLs",()=>{const result=sanitizeContent("Visit http://example.com");expect(result).toContain("(redacted)"),expect(mockCore.info).toHaveBeenCalled()}),it("should redact javascript: URLs",()=>{const result=sanitizeContent("Click javascript:alert('xss')");expect(result).toContain("(redacted)")}),it("should redact data: URLs",()=>{const result=sanitizeContent("Image data:image/png;base64,abc123");expect(result).toContain("(redacted)")}),it("should preserve file paths with colons",()=>{const result=sanitizeContent("C:\\path\\to\\file");expect(result).toBe("C:\\path\\to\\file")}),it("should preserve namespace patterns",()=>{const result=sanitizeContent("std::vector::push_back");expect(result).toBe("std::vector::push_back")})}),describe("URL domain filtering",()=>{it("should allow default GitHub domains",()=>{["https://github.com/repo","https://api.github.com/endpoint","https://raw.githubusercontent.com/file","https://example.github.io/page"].forEach(url=>{const result=sanitizeContent(`Visit ${url}`);expect(result).toBe(`Visit ${url}`)})}),it("should redact disallowed domains",()=>{const result=sanitizeContent("Visit https://evil.com/malicious");expect(result).toContain("(redacted)"),expect(mockCore.info).toHaveBeenCalled()}),it("should use custom allowed domains from environment",()=>{process.env.GH_AW_ALLOWED_DOMAINS="example.com,trusted.net";const result=sanitizeContent("Visit https://example.com/page");expect(result).toBe("Visit https://example.com/page")}),it("should extract and allow GitHub Enterprise domains",()=>{process.env.GITHUB_SERVER_URL="https://github.company.com";const result=sanitizeContent("Visit https://github.company.com/repo");expect(result).toBe("Visit https://github.company.com/repo")}),it("should allow subdomains of allowed domains",()=>{const result=sanitizeContent("Visit https://subdomain.github.com/page");expect(result).toBe("Visit https://subdomain.github.com/page")}),it("should log redacted domains",()=>{sanitizeContent("Visit https://verylongdomainnamefortest.com/page"),expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("Redacted URL:")),expect(mockCore.debug).toHaveBeenCalledWith(expect.stringContaining("Redacted URL (full):"))})}),describe("bot trigger neutralization",()=>{it("should neutralize 'fixes #123' patterns",()=>{const result=sanitizeContent("This fixes #123");expect(result).toBe("This `fixes #123`")}),it("should neutralize 'closes #456' patterns",()=>{const result=sanitizeContent("PR closes #456");expect(result).toBe("PR `closes #456`")}),it("should neutralize 'resolves #789' patterns",()=>{const result=sanitizeContent("This resolves #789");expect(result).toBe("This `resolves #789`")}),it("should handle various bot trigger verbs",()=>{["fix","fixes","close","closes","resolve","resolves"].forEach(verb=>{const result=sanitizeContent(`This ${verb} #123`);expect(result).toBe(`This \`${verb} #123\``)})}),it("should neutralize alphanumeric issue references",()=>{const result=sanitizeContent("fixes #abc123def");expect(result).toBe("`fixes #abc123def`")})}),describe("content truncation",()=>{it("should truncate content exceeding max length",()=>{const longContent="x".repeat(6e5),result=sanitizeContent(longContent);expect(result.length).toBeLessThan(longContent.length),expect(result).toContain("[Content truncated due to length]")}),it("should truncate content exceeding max lines",()=>{const manyLines=Array(7e4).fill("line").join("\n"),result=sanitizeContent(manyLines);expect(result.split("\n").length).toBeLessThan(7e4),expect(result).toContain("[Content truncated due to line count]")}),it("should respect custom max length parameter",()=>{const content="x".repeat(200),result=sanitizeContent(content,100);expect(result.length).toBeLessThanOrEqual(150),expect(result).toContain("[Content truncated")}),it("should not truncate short content",()=>{const result=sanitizeContent("This is a short message");expect(result).toBe("This is a short message"),expect(result).not.toContain("[Content truncated")})}),describe("combined sanitization",()=>{it("should apply all sanitizations correctly",()=>{const result=sanitizeContent("  \n        \x3c!-- comment --\x3e\n        Hello @user, visit https://github.com\n        <script>alert('xss')<\/script>\n        This fixes #123\n        [31mRed text[0m\n      ");expect(result).not.toContain("\x3c!-- comment --\x3e"),expect(result).toContain("`@user`"),expect(result).toContain("https://github.com"),expect(result).not.toContain("<script>"),expect(result).toContain("(script)"),expect(result).toContain("`fixes #123`"),expect(result).not.toContain("[31m"),expect(result).toContain("Red text")}),it("should handle malicious XSS attempts",()=>{['<img src=x onerror="alert(1)">',"javascript:alert(document.cookie)",'<svg onload="alert(1)">',"data:text/html,<script>alert(1)<\/script>"].forEach(input=>{const result=sanitizeContent(input);expect(result).not.toContain("<img"),expect(result).not.toContain("javascript:"),expect(result).not.toContain("<svg"),expect(result).not.toContain("data:")})}),it("should preserve allowed HTML in safe context",()=>{const input="<table><thead><tr><th>Header</th></tr></thead><tbody><tr><td>Data</td></tr></tbody></table>",result=sanitizeContent(input);expect(result).toBe(input)})}),describe("edge cases",()=>{it("should handle empty string",()=>{expect(sanitizeContent("")).toBe("")}),it("should handle whitespace-only input",()=>{expect(sanitizeContent("   \n\t  ")).toBe("")}),it("should handle content with only control characters",()=>{const result=sanitizeContent("\0");expect(result).toBe("")}),it("should handle content with multiple consecutive spaces",()=>{const result=sanitizeContent("hello     world");expect(result).toBe("hello     world")}),it("should handle Unicode characters",()=>{const result=sanitizeContent("Hello ä¸–ç•Œ ðŸŒ");expect(result).toBe("Hello ä¸–ç•Œ ðŸŒ")}),it("should handle URLs in query parameters",()=>{const result=sanitizeContent("https://github.com/redirect?url=https://github.com/target");expect(result).toContain("github.com"),expect(result).not.toContain("(redacted)")}),it("should handle nested backticks",()=>{const result=sanitizeContent("Already `@user` and @other");expect(result).toBe("Already `@user` and `@other`")})}),describe("redacted domains collection",()=>{let getRedactedDomains,clearRedactedDomains,writeRedactedDomainsLog;const fs=require("fs"),path=require("path");beforeEach(async()=>{const module=await import("./sanitize_content.cjs");getRedactedDomains=module.getRedactedDomains,clearRedactedDomains=module.clearRedactedDomains,writeRedactedDomainsLog=module.writeRedactedDomainsLog,clearRedactedDomains()}),it("should collect redacted HTTPS domains",()=>{sanitizeContent("Visit https://evil.com/malware");const domains=getRedactedDomains();expect(domains.length).toBe(1),expect(domains[0]).toBe("evil.com")}),it("should collect redacted HTTP domains",()=>{sanitizeContent("Visit http://example.com");const domains=getRedactedDomains();expect(domains.length).toBe(1),expect(domains[0]).toBe("example.com")}),it("should collect redacted dangerous protocols",()=>{sanitizeContent("Click javascript:alert(1)");const domains=getRedactedDomains();expect(domains.length).toBe(1),expect(domains[0]).toBe("javascript:")}),it("should collect multiple redacted domains",()=>{sanitizeContent("Visit https://bad1.com and http://bad2.com");const domains=getRedactedDomains();expect(domains.length).toBe(2),expect(domains).toContain("bad1.com"),expect(domains).toContain("bad2.com")}),it("should not collect allowed domains",()=>{sanitizeContent("Visit https://github.com/repo");const domains=getRedactedDomains();expect(domains.length).toBe(0)}),it("should clear collected domains",()=>{sanitizeContent("Visit https://evil.com"),expect(getRedactedDomains().length).toBe(1),clearRedactedDomains(),expect(getRedactedDomains().length).toBe(0)}),it("should return a copy of domains array",()=>{sanitizeContent("Visit https://evil.com");const domains1=getRedactedDomains(),domains2=getRedactedDomains();expect(domains1).not.toBe(domains2),expect(domains1).toEqual(domains2)}),describe("writeRedactedDomainsLog",()=>{const testDir="/tmp/gh-aw-test-redacted",testFile=`${testDir}/redacted-urls.log`;afterEach(()=>{fs.existsSync(testFile)&&fs.unlinkSync(testFile),fs.existsSync(testDir)&&fs.rmdirSync(testDir,{recursive:!0})}),it("should return null when no domains collected",()=>{const result=writeRedactedDomainsLog(testFile);expect(result).toBeNull(),expect(fs.existsSync(testFile)).toBe(!1)}),it("should write domains to log file",()=>{sanitizeContent("Visit https://evil.com/malware");const result=writeRedactedDomainsLog(testFile);expect(result).toBe(testFile),expect(fs.existsSync(testFile)).toBe(!0);const content=fs.readFileSync(testFile,"utf8");expect(content).toContain("evil.com"),expect(content).not.toContain("https://evil.com/malware")}),it("should write multiple domains to log file",()=>{sanitizeContent("Visit https://bad1.com and http://bad2.com"),writeRedactedDomainsLog(testFile);const content=fs.readFileSync(testFile,"utf8"),lines=content.trim().split("\n");expect(lines.length).toBe(2),expect(content).toContain("bad1.com"),expect(content).toContain("bad2.com")}),it("should create directory if it does not exist",()=>{const nestedFile=`${testDir}/nested/redacted-urls.log`;sanitizeContent("Visit https://evil.com"),writeRedactedDomainsLog(nestedFile),expect(fs.existsSync(nestedFile)).toBe(!0),fs.unlinkSync(nestedFile),fs.rmdirSync(path.dirname(nestedFile))}),it("should use default path when not specified",()=>{const defaultPath="/tmp/gh-aw/redacted-urls.log";sanitizeContent("Visit https://evil.com");const result=writeRedactedDomainsLog();expect(result).toBe(defaultPath),expect(fs.existsSync(defaultPath)).toBe(!0),fs.unlinkSync(defaultPath)})})})});