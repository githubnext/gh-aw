/**
 * Generate footer with AI attribution and workflow installation instructions
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)
 * @param {string} workflowSourceURL - GitHub URL for the workflow source
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow
 * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow
 * @returns {string} Footer text
 */
function generateFooter(
  workflowName,
  runUrl,
  workflowSource,
  workflowSourceURL,
  triggeringIssueNumber,
  triggeringPRNumber,
  triggeringDiscussionNumber
) {
  let footer = `\n\n> AI generated by [${workflowName}](${runUrl})`;

  // Add reference to triggering issue/PR/discussion if available
  if (triggeringIssueNumber) {
    footer += ` for #${triggeringIssueNumber}`;
  } else if (triggeringPRNumber) {
    footer += ` for #${triggeringPRNumber}`;
  } else if (triggeringDiscussionNumber) {
    footer += ` for discussion #${triggeringDiscussionNumber}`;
  }

  if (workflowSource && workflowSourceURL) {
    footer += `\n>\n> To add this workflow in your repository, run \`gh aw add ${workflowSource}\`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).`;
  }

  footer += "\n";
  return footer;
}

async function main() {
  // Check if we're in staged mode
  const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";

  // Helper function to get the repository URL for different purposes
  function getRepositoryUrl() {
    // For trial mode, use target repository for issue/PR URLs but execution context for action runs
    const targetRepoSlug = process.env.GITHUB_AW_TARGET_REPO_SLUG;

    if (targetRepoSlug) {
      // Use target repository for issue/PR URLs in trial mode
      const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
      return `${githubServer}/${targetRepoSlug}`;
    } else if (context.payload.repository) {
      // Use execution context repository (default behavior)
      return context.payload.repository.html_url;
    } else {
      // Final fallback for action runs when context repo is not available
      const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
      return `${githubServer}/${context.repo.owner}/${context.repo.repo}`;
    }
  }

  // Read the validated output content from environment variable
  const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
  if (!outputContent) {
    core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
    return;
  }

  if (outputContent.trim() === "") {
    core.info("Agent output content is empty");
    return;
  }

  core.info(`Agent output content length: ${outputContent.length}`);

  // Parse the validated output JSON
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
    return;
  }

  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    core.info("No valid items found in agent output");
    return;
  }

  // Find all create-pull-request-review-comment items
  const reviewCommentItems = validatedOutput.items.filter(
    /** @param {any} item */ item => item.type === "create_pull_request_review_comment"
  );
  if (reviewCommentItems.length === 0) {
    core.info("No create-pull-request-review-comment items found in agent output");
    return;
  }

  core.info(`Found ${reviewCommentItems.length} create-pull-request-review-comment item(s)`);

  // If in staged mode, emit step summary instead of creating review comments
  if (isStaged) {
    let summaryContent = "## 🎭 Staged Mode: Create PR Review Comments Preview\n\n";
    summaryContent += "The following review comments would be created if staged mode was disabled:\n\n";

    for (let i = 0; i < reviewCommentItems.length; i++) {
      const item = reviewCommentItems[i];
      summaryContent += `### Review Comment ${i + 1}\n`;
      if (item.pull_request_number) {
        const repoUrl = getRepositoryUrl();
        const pullUrl = `${repoUrl}/pull/${item.pull_request_number}`;
        summaryContent += `**Target PR:** [#${item.pull_request_number}](${pullUrl})\n\n`;
      } else {
        summaryContent += `**Target:** Current PR\n\n`;
      }
      summaryContent += `**File:** ${item.path || "No path provided"}\n\n`;
      summaryContent += `**Line:** ${item.line || "No line provided"}\n\n`;
      if (item.start_line) {
        summaryContent += `**Start Line:** ${item.start_line}\n\n`;
      }
      summaryContent += `**Side:** ${item.side || "RIGHT"}\n\n`;
      summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
      summaryContent += "---\n\n";
    }

    // Write to step summary
    await core.summary.addRaw(summaryContent).write();
    core.info("📝 PR review comment creation preview written to step summary");
    return;
  }

  // Get the side configuration from environment variable
  const defaultSide = process.env.GITHUB_AW_PR_REVIEW_COMMENT_SIDE || "RIGHT";
  core.info(`Default comment side configuration: ${defaultSide}`);

  // Get the target configuration from environment variable
  const commentTarget = process.env.GITHUB_AW_PR_REVIEW_COMMENT_TARGET || "triggering";
  core.info(`PR review comment target configuration: ${commentTarget}`);

  // Check if we're in a pull request context, or an issue comment context on a PR
  const isPRContext =
    context.eventName === "pull_request" ||
    context.eventName === "pull_request_review" ||
    context.eventName === "pull_request_review_comment" ||
    (context.eventName === "issue_comment" && context.payload.issue && context.payload.issue.pull_request);

  // Validate context based on target configuration
  if (commentTarget === "triggering" && !isPRContext) {
    core.info('Target is "triggering" but not running in pull request context, skipping review comment creation');
    return;
  }

  // Extract triggering context for footer generation
  const triggeringIssueNumber =
    context.payload?.issue?.number && !context.payload?.issue?.pull_request ? context.payload.issue.number : undefined;
  const triggeringPRNumber =
    context.payload?.pull_request?.number || (context.payload?.issue?.pull_request ? context.payload.issue.number : undefined);
  const triggeringDiscussionNumber = context.payload?.discussion?.number;

  const createdComments = [];

  // Process each review comment item
  for (let i = 0; i < reviewCommentItems.length; i++) {
    const commentItem = reviewCommentItems[i];
    core.info(
      `Processing create-pull-request-review-comment item ${i + 1}/${reviewCommentItems.length}: bodyLength=${commentItem.body ? commentItem.body.length : "undefined"}, path=${commentItem.path}, line=${commentItem.line}, startLine=${commentItem.start_line}`
    );

    // Validate required fields
    if (!commentItem.path) {
      core.info('Missing required field "path" in review comment item');
      continue;
    }

    if (!commentItem.line || (typeof commentItem.line !== "number" && typeof commentItem.line !== "string")) {
      core.info('Missing or invalid required field "line" in review comment item');
      continue;
    }

    if (!commentItem.body || typeof commentItem.body !== "string") {
      core.info('Missing or invalid required field "body" in review comment item');
      continue;
    }

    // Determine the PR number for this review comment
    let pullRequestNumber;
    let pullRequest;

    if (commentTarget === "*") {
      // For target "*", we need an explicit PR number from the comment item
      if (commentItem.pull_request_number) {
        pullRequestNumber = parseInt(commentItem.pull_request_number, 10);
        if (isNaN(pullRequestNumber) || pullRequestNumber <= 0) {
          core.info(`Invalid pull request number specified: ${commentItem.pull_request_number}`);
          continue;
        }
      } else {
        core.info('Target is "*" but no pull_request_number specified in comment item');
        continue;
      }
    } else if (commentTarget && commentTarget !== "triggering") {
      // Explicit PR number specified in target
      pullRequestNumber = parseInt(commentTarget, 10);
      if (isNaN(pullRequestNumber) || pullRequestNumber <= 0) {
        core.info(`Invalid pull request number in target configuration: ${commentTarget}`);
        continue;
      }
    } else {
      // Default behavior: use triggering PR
      if (context.payload.pull_request) {
        pullRequestNumber = context.payload.pull_request.number;
        pullRequest = context.payload.pull_request;
      } else if (context.payload.issue && context.payload.issue.pull_request) {
        pullRequestNumber = context.payload.issue.number;
      } else {
        core.info("Pull request context detected but no pull request found in payload");
        continue;
      }
    }

    if (!pullRequestNumber) {
      core.info("Could not determine pull request number");
      continue;
    }

    // If we don't have the full PR details yet, fetch them
    if (!pullRequest || !pullRequest.head || !pullRequest.head.sha) {
      try {
        const { data: fullPR } = await github.rest.pulls.get({
          owner: context.repo.owner,
          repo: context.repo.repo,
          pull_number: pullRequestNumber,
        });
        pullRequest = fullPR;
        core.info(`Fetched full pull request details for PR #${pullRequestNumber}`);
      } catch (error) {
        core.info(
          `Failed to fetch pull request details for PR #${pullRequestNumber}: ${error instanceof Error ? error.message : String(error)}`
        );
        continue;
      }
    }

    // Check if we have the commit SHA needed for creating review comments
    if (!pullRequest || !pullRequest.head || !pullRequest.head.sha) {
      core.info(`Pull request head commit SHA not found for PR #${pullRequestNumber} - cannot create review comment`);
      continue;
    }

    core.info(`Creating review comment on PR #${pullRequestNumber}`);

    // Parse line numbers
    const line = parseInt(commentItem.line, 10);
    if (isNaN(line) || line <= 0) {
      core.info(`Invalid line number: ${commentItem.line}`);
      continue;
    }

    let startLine = undefined;
    if (commentItem.start_line) {
      startLine = parseInt(commentItem.start_line, 10);
      if (isNaN(startLine) || startLine <= 0 || startLine > line) {
        core.info(`Invalid start_line number: ${commentItem.start_line} (must be <= line: ${line})`);
        continue;
      }
    }

    // Determine side (LEFT or RIGHT)
    const side = commentItem.side || defaultSide;
    if (side !== "LEFT" && side !== "RIGHT") {
      core.info(`Invalid side value: ${side} (must be LEFT or RIGHT)`);
      continue;
    }

    // Extract body from the JSON item
    let body = commentItem.body.trim();

    // Add AI disclaimer with workflow name and run url
    const workflowName = process.env.GITHUB_AW_WORKFLOW_NAME || "Workflow";
    const workflowSource = process.env.GITHUB_AW_WORKFLOW_SOURCE || "";
    const workflowSourceURL = process.env.GITHUB_AW_WORKFLOW_SOURCE_URL || "";
    const runId = context.runId;
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    const runUrl = context.payload.repository
      ? `${context.payload.repository.html_url}/actions/runs/${runId}`
      : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
    body += generateFooter(
      workflowName,
      runUrl,
      workflowSource,
      workflowSourceURL,
      triggeringIssueNumber,
      triggeringPRNumber,
      triggeringDiscussionNumber
    );

    core.info(
      `Creating review comment on PR #${pullRequestNumber} at ${commentItem.path}:${line}${startLine ? ` (lines ${startLine}-${line})` : ""} [${side}]`
    );
    core.info(`Comment content length: ${body.length}`);

    try {
      // Prepare the request parameters
      /** @type {any} */
      const requestParams = {
        owner: context.repo.owner,
        repo: context.repo.repo,
        pull_number: pullRequestNumber,
        body: body,
        path: commentItem.path,
        commit_id: pullRequest && pullRequest.head ? pullRequest.head.sha : "", // Required for creating review comments
        line: line,
        side: side,
      };

      // Add start_line for multi-line comments
      if (startLine !== undefined) {
        requestParams.start_line = startLine;
        requestParams.start_side = side; // start_side should match side for consistency
      }

      // Create the review comment using GitHub API
      const { data: comment } = await github.rest.pulls.createReviewComment(requestParams);

      core.info("Created review comment #" + comment.id + ": " + comment.html_url);
      createdComments.push(comment);

      // Set output for the last created comment (for backward compatibility)
      if (i === reviewCommentItems.length - 1) {
        core.setOutput("review_comment_id", comment.id);
        core.setOutput("review_comment_url", comment.html_url);
      }
    } catch (error) {
      core.error(`✗ Failed to create review comment: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  // Write summary for all created comments
  if (createdComments.length > 0) {
    let summaryContent = "\n\n## GitHub PR Review Comments\n";
    for (const comment of createdComments) {
      summaryContent += `- Review Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }

  core.info(`Successfully created ${createdComments.length} review comment(s)`);
  return createdComments;
}
await main();
