import{describe,it,expect,beforeEach,afterEach,vi}from"vitest";import fs from"fs";import path from"path";import os from"os";describe("safe_inputs_mcp_server.cjs",()=>{let tempDir;beforeEach(()=>{vi.resetModules(),vi.spyOn(process.stderr,"write").mockImplementation(()=>!0),tempDir=fs.mkdtempSync(path.join(os.tmpdir(),"safe-inputs-test-"))}),afterEach(()=>{tempDir&&fs.existsSync(tempDir)&&fs.rmSync(tempDir,{recursive:!0})}),describe("loadConfig",()=>{it("should load configuration from a valid JSON file",async()=>{const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({serverName:"test-server",version:"1.0.0",tools:[{name:"test_tool",description:"A test tool",inputSchema:{type:"object",properties:{}}}]}));const loadedConfig=loadConfig(configPath);expect(loadedConfig.serverName).toBe("test-server"),expect(loadedConfig.version).toBe("1.0.0"),expect(loadedConfig.tools).toHaveLength(1),expect(loadedConfig.tools[0].name).toBe("test_tool")}),it("should throw error for non-existent file",async()=>{const{loadConfig}=await import("./safe_inputs_mcp_server.cjs");expect(()=>loadConfig("/non/existent/config.json")).toThrow("Configuration file not found")}),it("should throw error for invalid JSON",async()=>{const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),configPath=path.join(tempDir,"invalid.json");fs.writeFileSync(configPath,"not valid json"),expect(()=>loadConfig(configPath)).toThrow()}),it("should throw error for missing tools array",async()=>{const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),configPath=path.join(tempDir,"no-tools.json");fs.writeFileSync(configPath,JSON.stringify({serverName:"test"})),expect(()=>loadConfig(configPath)).toThrow("Configuration must contain a 'tools' array")}),it("should throw error for tools that is not an array",async()=>{const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),configPath=path.join(tempDir,"tools-not-array.json");fs.writeFileSync(configPath,JSON.stringify({tools:"not an array"})),expect(()=>loadConfig(configPath)).toThrow("Configuration must contain a 'tools' array")})}),describe("createToolConfig",()=>{it("should create a valid tool configuration",async()=>{const{createToolConfig}=await import("./safe_inputs_mcp_server.cjs"),config=createToolConfig("my_tool","My tool description",{type:"object",properties:{input:{type:"string"}}},"my_tool.cjs");expect(config.name).toBe("my_tool"),expect(config.description).toBe("My tool description"),expect(config.inputSchema).toEqual({type:"object",properties:{input:{type:"string"}}}),expect(config.handler).toBe("my_tool.cjs")})}),describe("startSafeInputsServer integration",()=>{it("should start server with JavaScript handler",async()=>{const handlerPath=path.join(tempDir,"test_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = function(args) {\n          return { result: "hello " + args.name };\n        };');const configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({serverName:"test-safe-inputs",version:"1.0.0",tools:[{name:"greet",description:"Greet someone",inputSchema:{type:"object",properties:{name:{type:"string"}}},handler:"test_handler.cjs"}]}));const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),{createServer,registerTool,loadToolHandlers,handleMessage}=await import("./mcp_server_core.cjs"),loadedConfig=loadConfig(configPath),server=createServer({name:loadedConfig.serverName||"safeinputs",version:loadedConfig.version||"1.0.0"}),tools=loadToolHandlers(server,loadedConfig.tools,tempDir);for(const tool of tools)registerTool(server,tool);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"greet",arguments:{name:"world"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toContain("hello world")}),it("should start server with shell script handler",async()=>{const handlerPath=path.join(tempDir,"test_handler.sh");fs.writeFileSync(handlerPath,'#!/bin/bash\necho "Shell says: $INPUT_NAME"\necho "greeting=Hello from shell" >> $GITHUB_OUTPUT\n',{mode:493});const configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({tools:[{name:"shell_greet",description:"Greet from shell",inputSchema:{type:"object",properties:{name:{type:"string"}}},handler:"test_handler.sh"}]}));const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),{createServer,registerTool,loadToolHandlers,handleMessage}=await import("./mcp_server_core.cjs"),loadedConfig=loadConfig(configPath),server=createServer({name:"safeinputs",version:"1.0.0"}),tools=loadToolHandlers(server,loadedConfig.tools,tempDir);for(const tool of tools)registerTool(server,tool);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"shell_greet",arguments:{name:"tester"}}}),expect(results).toHaveLength(1);const resultContent=JSON.parse(results[0].result.content[0].text);expect(resultContent.stdout).toContain("Shell says: tester"),expect(resultContent.outputs.greeting).toBe("Hello from shell")}),it("should handle tools/list request",async()=>{const configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({serverName:"test-server",version:"2.0.0",tools:[{name:"tool_one",description:"First tool",inputSchema:{type:"object",properties:{a:{type:"string"}}}},{name:"tool_two",description:"Second tool",inputSchema:{type:"object",properties:{b:{type:"number"}}}}]}));const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),{createServer,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),loadedConfig=loadConfig(configPath),server=createServer({name:loadedConfig.serverName,version:loadedConfig.version});for(const tool of loadedConfig.tools)registerTool(server,tool);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/list"}),expect(results).toHaveLength(1),expect(results[0].result.tools).toHaveLength(2);const toolNames=results[0].result.tools.map(t=>t.name);expect(toolNames).toContain("tool_one"),expect(toolNames).toContain("tool_two")}),it("should handle initialize request",async()=>{const configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({tools:[{name:"dummy",description:"dummy",inputSchema:{}}]}));const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),{createServer,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),loadedConfig=loadConfig(configPath),server=createServer({name:"safeinputs",version:"1.0.0"});for(const tool of loadedConfig.tools)registerTool(server,tool);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"initialize",params:{protocolVersion:"2024-11-05"}}),expect(results).toHaveLength(1),expect(results[0].result.serverInfo).toEqual({name:"safeinputs",version:"1.0.0"}),expect(results[0].result.protocolVersion).toBe("2024-11-05"),expect(results[0].result.capabilities).toEqual({tools:{}})}),it("should use default server name and version if not provided",async()=>{const configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({tools:[{name:"test",description:"test",inputSchema:{}}]}));const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),{createServer,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),loadedConfig=loadConfig(configPath),server=createServer({name:loadedConfig.serverName||"safeinputs",version:loadedConfig.version||"1.0.0"});for(const tool of loadedConfig.tools)registerTool(server,tool);const results=[];server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"initialize",params:{}}),expect(results[0].result.serverInfo.name).toBe("safeinputs"),expect(results[0].result.serverInfo.version).toBe("1.0.0")})}),describe("error handling",()=>{it("should return error for unknown tool",async()=>{const configPath=path.join(tempDir,"config.json");fs.writeFileSync(configPath,JSON.stringify({tools:[{name:"known_tool",description:"test",inputSchema:{}}]}));const{loadConfig}=await import("./safe_inputs_mcp_server.cjs"),{createServer,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),loadedConfig=loadConfig(configPath),server=createServer({name:"safeinputs",version:"1.0.0"});for(const tool of loadedConfig.tools)registerTool(server,tool);const results=[];server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"unknown_tool",arguments:{}}}),expect(results).toHaveLength(1),expect(results[0].error.code).toBe(-32601),expect(results[0].error.message).toContain("Tool not found")})}),describe("end-to-end server process",()=>{it("should write files, launch server, initialize, call echo tool and verify result",async()=>{const{spawn}=await import("child_process"),mcpServerCorePath=path.join(tempDir,"mcp_server_core.cjs"),mcpServerCoreContent=fs.readFileSync(path.join(__dirname,"mcp_server_core.cjs"),"utf-8");fs.writeFileSync(mcpServerCorePath,mcpServerCoreContent);const readBufferPath=path.join(tempDir,"read_buffer.cjs"),readBufferContent=fs.readFileSync(path.join(__dirname,"read_buffer.cjs"),"utf-8");fs.writeFileSync(readBufferPath,readBufferContent);const configLoaderPath=path.join(tempDir,"safe_inputs_config_loader.cjs"),configLoaderContent=fs.readFileSync(path.join(__dirname,"safe_inputs_config_loader.cjs"),"utf-8");fs.writeFileSync(configLoaderPath,configLoaderContent);const toolFactoryPath=path.join(tempDir,"safe_inputs_tool_factory.cjs"),toolFactoryContent=fs.readFileSync(path.join(__dirname,"safe_inputs_tool_factory.cjs"),"utf-8");fs.writeFileSync(toolFactoryPath,toolFactoryContent);const validationPath=path.join(tempDir,"safe_inputs_validation.cjs"),validationContent=fs.readFileSync(path.join(__dirname,"safe_inputs_validation.cjs"),"utf-8");fs.writeFileSync(validationPath,validationContent);const bootstrapPath=path.join(tempDir,"safe_inputs_bootstrap.cjs"),bootstrapContent=fs.readFileSync(path.join(__dirname,"safe_inputs_bootstrap.cjs"),"utf-8");fs.writeFileSync(bootstrapPath,bootstrapContent);const pythonHandlerPath=path.join(tempDir,"mcp_handler_python.cjs"),pythonHandlerContent=fs.readFileSync(path.join(__dirname,"mcp_handler_python.cjs"),"utf-8");fs.writeFileSync(pythonHandlerPath,pythonHandlerContent);const shellHandlerPath=path.join(tempDir,"mcp_handler_shell.cjs"),shellHandlerContent=fs.readFileSync(path.join(__dirname,"mcp_handler_shell.cjs"),"utf-8");fs.writeFileSync(shellHandlerPath,shellHandlerContent);const safeinputsServerPath=path.join(tempDir,"safe_inputs_mcp_server.cjs"),safeinputsServerContent=fs.readFileSync(path.join(__dirname,"safe_inputs_mcp_server.cjs"),"utf-8");fs.writeFileSync(safeinputsServerPath,safeinputsServerContent);const echoHandlerPath=path.join(tempDir,"echo.cjs");fs.writeFileSync(echoHandlerPath,'module.exports = function(args) {\n  return { message: "Echo: " + args.message };\n};');const toolsConfigPath=path.join(tempDir,"tools.json");fs.writeFileSync(toolsConfigPath,JSON.stringify({serverName:"test-safeinputs",version:"1.0.0",tools:[{name:"echo",description:"Echoes the input message back",inputSchema:{type:"object",properties:{message:{type:"string",description:"The message to echo"}},required:["message"]},handler:"echo.cjs"}]},null,2));const serverProcess=spawn("node",[safeinputsServerPath,toolsConfigPath],{cwd:tempDir,stdio:["pipe","pipe","pipe"],env:{...process.env}});let stderrOutput="";serverProcess.stderr.on("data",chunk=>{stderrOutput+=chunk.toString()});let stdoutBuffer="";const receivedMessages=[];function sendAndWait(message,timeoutMs=5e3){return new Promise((resolve,reject)=>{const startLength=receivedMessages.length,startTime=Date.now();serverProcess.stdin.write(JSON.stringify(message)+"\n");const checkInterval=setInterval(()=>{receivedMessages.length>startLength?(clearInterval(checkInterval),resolve(receivedMessages[receivedMessages.length-1])):Date.now()-startTime>timeoutMs&&(clearInterval(checkInterval),reject(new Error(`Timeout waiting for response to ${message.method}. Stderr: ${stderrOutput}`)))},10)})}serverProcess.stdout.on("data",chunk=>{stdoutBuffer+=chunk.toString();const lines=stdoutBuffer.split("\n");stdoutBuffer=lines.pop()||"";for(const line of lines)if(line.trim())try{receivedMessages.push(JSON.parse(line))}catch(e){}});try{await new Promise(resolve=>setTimeout(resolve,100));const initResponse=await sendAndWait({jsonrpc:"2.0",id:1,method:"initialize",params:{protocolVersion:"2024-11-05"}});expect(initResponse.jsonrpc).toBe("2.0"),expect(initResponse.id).toBe(1),expect(initResponse.result).toBeDefined(),expect(initResponse.result.serverInfo.name).toBe("test-safeinputs"),expect(initResponse.result.serverInfo.version).toBe("1.0.0"),expect(initResponse.result.protocolVersion).toBe("2024-11-05"),expect(initResponse.result.capabilities).toEqual({tools:{}}),serverProcess.stdin.write(JSON.stringify({jsonrpc:"2.0",method:"notifications/initialized"})+"\n");const echoResponse=await sendAndWait({jsonrpc:"2.0",id:2,method:"tools/call",params:{name:"echo",arguments:{message:"Hello, MCP!"}}});expect(echoResponse.jsonrpc).toBe("2.0"),expect(echoResponse.id).toBe(2),expect(echoResponse.result).toBeDefined(),expect(echoResponse.result.content).toBeDefined(),expect(echoResponse.result.content.length).toBe(1),expect(echoResponse.result.content[0].type).toBe("text");const echoResult=JSON.parse(echoResponse.result.content[0].text);expect(echoResult.message).toBe("Echo: Hello, MCP!")}finally{serverProcess.kill("SIGTERM"),await new Promise(resolve=>serverProcess.on("close",resolve))}},15e3),it("should handle tools/list request in spawned process",async()=>{const{spawn}=await import("child_process"),mcpServerCorePath=path.join(tempDir,"mcp_server_core.cjs"),mcpServerCoreContent=fs.readFileSync(path.join(__dirname,"mcp_server_core.cjs"),"utf-8");fs.writeFileSync(mcpServerCorePath,mcpServerCoreContent);const readBufferPath=path.join(tempDir,"read_buffer.cjs"),readBufferContent=fs.readFileSync(path.join(__dirname,"read_buffer.cjs"),"utf-8");fs.writeFileSync(readBufferPath,readBufferContent);const configLoaderPath=path.join(tempDir,"safe_inputs_config_loader.cjs"),configLoaderContent=fs.readFileSync(path.join(__dirname,"safe_inputs_config_loader.cjs"),"utf-8");fs.writeFileSync(configLoaderPath,configLoaderContent);const toolFactoryPath=path.join(tempDir,"safe_inputs_tool_factory.cjs"),toolFactoryContent=fs.readFileSync(path.join(__dirname,"safe_inputs_tool_factory.cjs"),"utf-8");fs.writeFileSync(toolFactoryPath,toolFactoryContent);const validationPath=path.join(tempDir,"safe_inputs_validation.cjs"),validationContent=fs.readFileSync(path.join(__dirname,"safe_inputs_validation.cjs"),"utf-8");fs.writeFileSync(validationPath,validationContent);const bootstrapPath=path.join(tempDir,"safe_inputs_bootstrap.cjs"),bootstrapContent=fs.readFileSync(path.join(__dirname,"safe_inputs_bootstrap.cjs"),"utf-8");fs.writeFileSync(bootstrapPath,bootstrapContent);const pythonHandlerPath=path.join(tempDir,"mcp_handler_python.cjs"),pythonHandlerContent=fs.readFileSync(path.join(__dirname,"mcp_handler_python.cjs"),"utf-8");fs.writeFileSync(pythonHandlerPath,pythonHandlerContent);const shellHandlerPath=path.join(tempDir,"mcp_handler_shell.cjs"),shellHandlerContent=fs.readFileSync(path.join(__dirname,"mcp_handler_shell.cjs"),"utf-8");fs.writeFileSync(shellHandlerPath,shellHandlerContent);const safeinputsServerPath=path.join(tempDir,"safe_inputs_mcp_server.cjs"),safeinputsServerContent=fs.readFileSync(path.join(__dirname,"safe_inputs_mcp_server.cjs"),"utf-8");fs.writeFileSync(safeinputsServerPath,safeinputsServerContent);const toolsConfigPath=path.join(tempDir,"tools.json");fs.writeFileSync(toolsConfigPath,JSON.stringify({serverName:"list-test-server",version:"2.0.0",tools:[{name:"tool_one",description:"First test tool",inputSchema:{type:"object",properties:{a:{type:"string"}}}},{name:"tool_two",description:"Second test tool",inputSchema:{type:"object",properties:{b:{type:"number"}}}}]},null,2));const serverProcess=spawn("node",[safeinputsServerPath,toolsConfigPath],{cwd:tempDir,stdio:["pipe","pipe","pipe"]});let stderrOutput="";serverProcess.stderr.on("data",chunk=>{stderrOutput+=chunk.toString()});let stdoutBuffer="";const receivedMessages=[];function sendAndWait(message,timeoutMs=5e3){return new Promise((resolve,reject)=>{const startLength=receivedMessages.length,startTime=Date.now();serverProcess.stdin.write(JSON.stringify(message)+"\n");const checkInterval=setInterval(()=>{receivedMessages.length>startLength?(clearInterval(checkInterval),resolve(receivedMessages[receivedMessages.length-1])):Date.now()-startTime>timeoutMs&&(clearInterval(checkInterval),reject(new Error(`Timeout. Stderr: ${stderrOutput}`)))},10)})}serverProcess.stdout.on("data",chunk=>{stdoutBuffer+=chunk.toString();const lines=stdoutBuffer.split("\n");stdoutBuffer=lines.pop()||"";for(const line of lines)if(line.trim())try{receivedMessages.push(JSON.parse(line))}catch(e){}});try{await new Promise(resolve=>setTimeout(resolve,100)),await sendAndWait({jsonrpc:"2.0",id:1,method:"initialize",params:{}});const listResponse=await sendAndWait({jsonrpc:"2.0",id:2,method:"tools/list"});expect(listResponse.result.tools).toHaveLength(2);const toolNames=listResponse.result.tools.map(t=>t.name);expect(toolNames).toContain("tool_one"),expect(toolNames).toContain("tool_two")}finally{serverProcess.kill("SIGTERM"),await new Promise(resolve=>serverProcess.on("close",resolve))}},15e3),it("should handle shell script echo tool in spawned process",async()=>{const{spawn}=await import("child_process"),mcpServerCorePath=path.join(tempDir,"mcp_server_core.cjs"),mcpServerCoreContent=fs.readFileSync(path.join(__dirname,"mcp_server_core.cjs"),"utf-8");fs.writeFileSync(mcpServerCorePath,mcpServerCoreContent);const readBufferPath=path.join(tempDir,"read_buffer.cjs"),readBufferContent=fs.readFileSync(path.join(__dirname,"read_buffer.cjs"),"utf-8");fs.writeFileSync(readBufferPath,readBufferContent);const configLoaderPath=path.join(tempDir,"safe_inputs_config_loader.cjs"),configLoaderContent=fs.readFileSync(path.join(__dirname,"safe_inputs_config_loader.cjs"),"utf-8");fs.writeFileSync(configLoaderPath,configLoaderContent);const toolFactoryPath=path.join(tempDir,"safe_inputs_tool_factory.cjs"),toolFactoryContent=fs.readFileSync(path.join(__dirname,"safe_inputs_tool_factory.cjs"),"utf-8");fs.writeFileSync(toolFactoryPath,toolFactoryContent);const validationPath=path.join(tempDir,"safe_inputs_validation.cjs"),validationContent=fs.readFileSync(path.join(__dirname,"safe_inputs_validation.cjs"),"utf-8");fs.writeFileSync(validationPath,validationContent);const bootstrapPath=path.join(tempDir,"safe_inputs_bootstrap.cjs"),bootstrapContent=fs.readFileSync(path.join(__dirname,"safe_inputs_bootstrap.cjs"),"utf-8");fs.writeFileSync(bootstrapPath,bootstrapContent);const pythonHandlerPath=path.join(tempDir,"mcp_handler_python.cjs"),pythonHandlerContent=fs.readFileSync(path.join(__dirname,"mcp_handler_python.cjs"),"utf-8");fs.writeFileSync(pythonHandlerPath,pythonHandlerContent);const shellHandlerPath=path.join(tempDir,"mcp_handler_shell.cjs"),shellHandlerContent=fs.readFileSync(path.join(__dirname,"mcp_handler_shell.cjs"),"utf-8");fs.writeFileSync(shellHandlerPath,shellHandlerContent);const safeinputsServerPath=path.join(tempDir,"safe_inputs_mcp_server.cjs"),safeinputsServerContent=fs.readFileSync(path.join(__dirname,"safe_inputs_mcp_server.cjs"),"utf-8");fs.writeFileSync(safeinputsServerPath,safeinputsServerContent);const echoShPath=path.join(tempDir,"echo.sh");fs.writeFileSync(echoShPath,'#!/bin/bash\necho "Shell echo: $INPUT_MESSAGE"\necho "result=Shell echo: $INPUT_MESSAGE" >> $GITHUB_OUTPUT\n',{mode:493});const toolsConfigPath=path.join(tempDir,"tools.json");fs.writeFileSync(toolsConfigPath,JSON.stringify({serverName:"shell-echo-server",version:"1.0.0",tools:[{name:"shell_echo",description:"Echoes message using shell script",inputSchema:{type:"object",properties:{message:{type:"string"}},required:["message"]},handler:"echo.sh"}]},null,2));const serverProcess=spawn("node",[safeinputsServerPath,toolsConfigPath],{cwd:tempDir,stdio:["pipe","pipe","pipe"]});let stderrOutput="";serverProcess.stderr.on("data",chunk=>{stderrOutput+=chunk.toString()});let stdoutBuffer="";const receivedMessages=[];function sendAndWait(message,timeoutMs=5e3){return new Promise((resolve,reject)=>{const startLength=receivedMessages.length,startTime=Date.now();serverProcess.stdin.write(JSON.stringify(message)+"\n");const checkInterval=setInterval(()=>{receivedMessages.length>startLength?(clearInterval(checkInterval),resolve(receivedMessages[receivedMessages.length-1])):Date.now()-startTime>timeoutMs&&(clearInterval(checkInterval),reject(new Error(`Timeout. Stderr: ${stderrOutput}`)))},10)})}serverProcess.stdout.on("data",chunk=>{stdoutBuffer+=chunk.toString();const lines=stdoutBuffer.split("\n");stdoutBuffer=lines.pop()||"";for(const line of lines)if(line.trim())try{receivedMessages.push(JSON.parse(line))}catch(e){}});try{await new Promise(resolve=>setTimeout(resolve,100)),await sendAndWait({jsonrpc:"2.0",id:1,method:"initialize",params:{}});const echoResponse=await sendAndWait({jsonrpc:"2.0",id:2,method:"tools/call",params:{name:"shell_echo",arguments:{message:"Hello from shell!"}}});expect(echoResponse.result).toBeDefined(),expect(echoResponse.result.content).toBeDefined();const resultContent=JSON.parse(echoResponse.result.content[0].text);expect(resultContent.stdout).toContain("Shell echo: Hello from shell!"),expect(resultContent.outputs.result).toBe("Shell echo: Hello from shell!")}finally{serverProcess.kill("SIGTERM"),await new Promise(resolve=>serverProcess.on("close",resolve))}},15e3)})});