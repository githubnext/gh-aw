// @ts-check
/// <reference types="@actions/github-script" />

/**
 * @typedef {Object} SafeOutputMessages
 * @property {string} [footer] - Custom footer message template
 * @property {string} [footerInstall] - Custom installation instructions template
 * @property {string} [stagedTitle] - Custom staged mode title template
 * @property {string} [stagedDescription] - Custom staged mode description template
 */

/**
 * @typedef {Object} FooterContext
 * @property {string} workflowName - Name of the workflow
 * @property {string} runUrl - URL of the workflow run
 * @property {string} [workflowSource] - Source of the workflow (owner/repo/path@ref)
 * @property {string} [workflowSourceUrl] - GitHub URL for the workflow source
 * @property {number|string} [triggeringNumber] - Issue, PR, or discussion number that triggered this workflow
 */

/**
 * @typedef {Object} StagedContext
 * @property {string} operation - The operation name (e.g., "Create Issues", "Add Comments")
 */

// Cache for parsed messages config
let cachedMessages = null;
let cacheInitialized = false;

/**
 * Get the safe-output messages configuration from environment variable.
 * Results are cached for performance.
 * @returns {SafeOutputMessages|null} Parsed messages config or null if not set
 */
function getMessages() {
  if (cacheInitialized) {
    return cachedMessages;
  }

  const messagesEnv = process.env.GH_AW_SAFE_OUTPUT_MESSAGES;
  if (!messagesEnv) {
    cacheInitialized = true;
    cachedMessages = null;
    return null;
  }

  try {
    // Parse JSON, converting camelCase keys from Go struct
    const rawMessages = JSON.parse(messagesEnv);

    // Map Go struct field names (PascalCase in JSON) to camelCase
    cachedMessages = {
      footer: rawMessages.Footer || rawMessages.footer,
      footerInstall: rawMessages.FooterInstall || rawMessages.footerInstall,
      stagedTitle: rawMessages.StagedTitle || rawMessages.stagedTitle,
      stagedDescription: rawMessages.StagedDescription || rawMessages.stagedDescription,
    };
    cacheInitialized = true;
    core.debug(`Loaded custom messages config: ${JSON.stringify(cachedMessages)}`);
    return cachedMessages;
  } catch (error) {
    core.warning(`Failed to parse GH_AW_SAFE_OUTPUT_MESSAGES: ${error instanceof Error ? error.message : String(error)}`);
    cacheInitialized = true;
    cachedMessages = null;
    return null;
  }
}

/**
 * Clear the cached messages (useful for testing)
 */
function clearMessagesCache() {
  cachedMessages = null;
  cacheInitialized = false;
}

/**
 * Replace placeholders in a template string with values from context.
 * Supports {key} syntax for placeholder replacement.
 * @param {string} template - Template string with {key} placeholders
 * @param {Record<string, string|number|undefined>} context - Key-value pairs for replacement
 * @returns {string} Template with placeholders replaced
 */
function renderTemplate(template, context) {
  return template.replace(/\{(\w+)\}/g, (match, key) => {
    const value = context[key];
    return value !== undefined && value !== null ? String(value) : match;
  });
}

/**
 * Convert context object keys to snake_case for template rendering
 * @param {Record<string, any>} obj - Object with camelCase keys
 * @returns {Record<string, any>} Object with snake_case keys
 */
function toSnakeCase(obj) {
  /** @type {Record<string, any>} */
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    // Convert camelCase to snake_case
    const snakeKey = key.replace(/([A-Z])/g, "_$1").toLowerCase();
    result[snakeKey] = value;
    // Also keep original key for backwards compatibility
    result[key] = value;
  }
  return result;
}

/**
 * Get the footer message, using custom template if configured.
 * @param {FooterContext} ctx - Context for footer generation
 * @returns {string} Footer message
 */
function getFooterMessage(ctx) {
  const messages = getMessages();

  // Create context with both camelCase and snake_case keys
  const templateContext = toSnakeCase(ctx);

  // Default footer template
  const defaultFooter = "> AI generated by [{workflow_name}]({run_url})";

  // Use custom footer if configured
  let footer = messages?.footer ? renderTemplate(messages.footer, templateContext) : renderTemplate(defaultFooter, templateContext);

  // Add triggering reference if available
  if (ctx.triggeringNumber) {
    footer += ` for #${ctx.triggeringNumber}`;
  }

  return footer;
}

/**
 * Get the footer installation instructions, using custom template if configured.
 * @param {FooterContext} ctx - Context for footer generation
 * @returns {string} Footer installation message or empty string if no source
 */
function getFooterInstallMessage(ctx) {
  if (!ctx.workflowSource || !ctx.workflowSourceUrl) {
    return "";
  }

  const messages = getMessages();

  // Create context with both camelCase and snake_case keys
  const templateContext = toSnakeCase(ctx);

  // Default installation template
  const defaultInstall =
    "> To add this workflow in your repository, run `gh aw add {workflow_source}`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).";

  // Use custom installation message if configured
  return messages?.footerInstall
    ? renderTemplate(messages.footerInstall, templateContext)
    : renderTemplate(defaultInstall, templateContext);
}

/**
 * Generate the complete footer with AI attribution and optional installation instructions.
 * This is a drop-in replacement for the original generateFooter function.
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)
 * @param {string} workflowSourceURL - GitHub URL for the workflow source
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow
 * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow
 * @returns {string} Complete footer text
 */
function generateFooterWithMessages(
  workflowName,
  runUrl,
  workflowSource,
  workflowSourceURL,
  triggeringIssueNumber,
  triggeringPRNumber,
  triggeringDiscussionNumber
) {
  // Determine triggering number (issue takes precedence, then PR, then discussion)
  let triggeringNumber;
  if (triggeringIssueNumber) {
    triggeringNumber = triggeringIssueNumber;
  } else if (triggeringPRNumber) {
    triggeringNumber = triggeringPRNumber;
  } else if (triggeringDiscussionNumber) {
    triggeringNumber = `discussion #${triggeringDiscussionNumber}`;
  }

  const ctx = {
    workflowName,
    runUrl,
    workflowSource,
    workflowSourceUrl: workflowSourceURL,
    triggeringNumber,
  };

  let footer = "\n\n" + getFooterMessage(ctx);

  // Add installation instructions if source is available
  const installMessage = getFooterInstallMessage(ctx);
  if (installMessage) {
    footer += "\n>\n" + installMessage;
  }

  footer += "\n";
  return footer;
}

/**
 * Get the staged mode title, using custom template if configured.
 * @param {StagedContext} ctx - Context for staged title generation
 * @returns {string} Staged mode title
 */
function getStagedTitle(ctx) {
  const messages = getMessages();

  // Create context with both camelCase and snake_case keys
  const templateContext = toSnakeCase(ctx);

  // Default staged title template
  const defaultTitle = "## ðŸŽ­ Staged Mode: {operation} Preview";

  // Use custom title if configured
  return messages?.stagedTitle ? renderTemplate(messages.stagedTitle, templateContext) : renderTemplate(defaultTitle, templateContext);
}

/**
 * Get the staged mode description, using custom template if configured.
 * @param {StagedContext} ctx - Context for staged description generation
 * @returns {string} Staged mode description
 */
function getStagedDescription(ctx) {
  const messages = getMessages();

  // Create context with both camelCase and snake_case keys
  const templateContext = toSnakeCase(ctx);

  // Default staged description template
  const defaultDescription = "The following would be created if staged mode was disabled:";

  // Use custom description if configured
  return messages?.stagedDescription
    ? renderTemplate(messages.stagedDescription, templateContext)
    : renderTemplate(defaultDescription, templateContext);
}

module.exports = {
  getMessages,
  clearMessagesCache,
  renderTemplate,
  getFooterMessage,
  getFooterInstallMessage,
  generateFooterWithMessages,
  getStagedTitle,
  getStagedDescription,
};
