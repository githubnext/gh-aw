// @ts-check
/// <reference types="@actions/github-script" />

const { loadAgentOutput } = require("./load_agent_output.cjs");
const { generateStagedPreview } = require("./staged_preview.cjs");

async function main() {
  // Check if we're in staged mode
  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";

  const result = loadAgentOutput();
  if (!result.success) {
    return;
  }

  // Find all update-release items
  const updateItems = result.items.filter(/** @param {any} item */ item => item.type === "update_release");
  if (updateItems.length === 0) {
    core.info("No update-release items found in agent output");
    return;
  }

  core.info(`Found ${updateItems.length} update-release item(s)`);

  // If in staged mode, emit step summary instead of updating releases
  if (isStaged) {
    await generateStagedPreview({
      title: "Update Releases",
      description: "The following release updates would be applied if staged mode was disabled:",
      items: updateItems,
      renderItem: (item, index) => {
        let content = `#### Release Update ${index + 1}\n`;
        content += `**Tag:** ${item.tag || "(inferred from event context)"}\n`;
        content += `**Operation:** ${item.operation}\n\n`;
        content += `**Body Content:**\n${item.body}\n\n`;
        return content;
      },
    });
    return;
  }

  // Get workflow run URL for AI attribution
  const workflowName = process.env.GH_AW_WORKFLOW_NAME || "GitHub Agentic Workflow";
  const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

  const updatedReleases = [];

  // Process each update item
  for (let i = 0; i < updateItems.length; i++) {
    const updateItem = updateItems[i];
    core.info(`Processing update-release item ${i + 1}/${updateItems.length}`);

    try {
      // Infer tag from event context if not provided
      let releaseTag = updateItem.tag;
      if (!releaseTag) {
        // Try to get tag from release event context
        if (context.eventName === "release" && context.payload.release && context.payload.release.tag_name) {
          releaseTag = context.payload.release.tag_name;
          core.info(`Inferred release tag from event context: ${releaseTag}`);
        } else if (context.eventName === "workflow_dispatch" && context.payload.inputs) {
          // Try to extract from release_url input
          const releaseUrl = context.payload.inputs.release_url;
          if (releaseUrl) {
            const urlMatch = releaseUrl.match(/github\.com\/[^\/]+\/[^\/]+\/releases\/tag\/([^\/\?#]+)/);
            if (urlMatch && urlMatch[1]) {
              releaseTag = decodeURIComponent(urlMatch[1]);
              core.info(`Inferred release tag from release_url input: ${releaseTag}`);
            }
          }
          // Try to fetch from release_id input
          if (!releaseTag && context.payload.inputs.release_id) {
            const releaseId = context.payload.inputs.release_id;
            core.info(`Fetching release with ID: ${releaseId}`);
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: parseInt(releaseId, 10),
            });
            releaseTag = release.tag_name;
            core.info(`Inferred release tag from release_id input: ${releaseTag}`);
          }
        }

        if (!releaseTag) {
          core.error("No tag provided and unable to infer from event context");
          core.setFailed("Release tag is required but not provided and cannot be inferred from event context");
          return;
        }
      }

      // Get the release by tag
      core.info(`Fetching release with tag: ${releaseTag}`);
      const { data: release } = await github.rest.repos.getReleaseByTag({
        owner: context.repo.owner,
        repo: context.repo.repo,
        tag: releaseTag,
      });

      core.info(`Found release: ${release.name || release.tag_name} (ID: ${release.id})`);

      // Determine new body based on operation
      let newBody;
      if (updateItem.operation === "replace") {
        // Replace: just use the new content
        newBody = updateItem.body;
        core.info("Operation: replace (full body replacement)");
      } else if (updateItem.operation === "prepend") {
        // Prepend: add content, AI footer, and horizontal line at the start
        const aiFooter = `\n\n> AI generated by [${workflowName}](${runUrl})`;
        const prependSection = `${updateItem.body}${aiFooter}\n\n---\n\n`;
        newBody = prependSection + (release.body || "");
        core.info("Operation: prepend (add to start with separator)");
      } else {
        // Append: add horizontal line, content, and AI footer at the end
        const aiFooter = `\n\n> AI generated by [${workflowName}](${runUrl})`;
        const appendSection = `\n\n---\n\n${updateItem.body}${aiFooter}`;
        newBody = (release.body || "") + appendSection;
        core.info("Operation: append (add to end with separator)");
      }

      // Update the release
      const { data: updatedRelease } = await github.rest.repos.updateRelease({
        owner: context.repo.owner,
        repo: context.repo.repo,
        release_id: release.id,
        body: newBody,
      });

      core.info(`Successfully updated release: ${updatedRelease.html_url}`);

      updatedReleases.push({
        tag: releaseTag,
        url: updatedRelease.html_url,
        id: updatedRelease.id,
      });

      // Set outputs for the first release
      if (i === 0) {
        core.setOutput("release_id", updatedRelease.id);
        core.setOutput("release_url", updatedRelease.html_url);
        core.setOutput("release_tag", updatedRelease.tag_name);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const tagInfo = updateItem.tag || "inferred from context";
      core.error(`Failed to update release with tag ${tagInfo}: ${errorMessage}`);

      // Check for specific error cases
      if (errorMessage.includes("Not Found")) {
        core.error(`Release with tag '${tagInfo}' not found. Please ensure the tag exists.`);
      }

      core.setFailed(`Failed to update release: ${errorMessage}`);
      return;
    }
  }

  // Generate step summary
  let summaryContent = `## âœ… Release Updates Complete\n\n`;
  summaryContent += `Updated ${updatedReleases.length} release(s):\n\n`;

  for (const rel of updatedReleases) {
    summaryContent += `- **${rel.tag}**: [View Release](${rel.url})\n`;
  }

  await core.summary.addRaw(summaryContent).write();
}

// Call the main function
await main();
