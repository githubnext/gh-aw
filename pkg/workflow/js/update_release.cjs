// @ts-check
/// <reference types="@actions/github-script" />

const { loadAgentOutput } = require("./load_agent_output.cjs");
const { generateStagedPreview } = require("./staged_preview.cjs");

async function main() {
  // Check if we're in staged mode
  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";

  const result = loadAgentOutput();
  if (!result.success) {
    return;
  }

  // Find all update-release items
  const updateItems = result.items.filter(/** @param {any} item */ item => item.type === "update_release");
  if (updateItems.length === 0) {
    core.info("No update-release items found in agent output");
    return;
  }

  core.info(`Found ${updateItems.length} update-release item(s)`);

  // If in staged mode, emit step summary instead of updating releases
  if (isStaged) {
    await generateStagedPreview({
      title: "Update Releases",
      description: "The following release updates would be applied if staged mode was disabled:",
      items: updateItems,
      renderItem: (item, index) => {
        let content = `### Release Update ${index + 1}\n`;
        content += `**Tag:** ${item.tag}\n`;
        content += `**Operation:** ${item.operation}\n\n`;
        content += `**Body Content:**\n${item.body}\n\n`;
        return content;
      },
    });
    return;
  }

  // Get workflow run URL for AI attribution
  const workflowName = process.env.GH_AW_WORKFLOW_NAME || "GitHub Agentic Workflow";
  const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

  const updatedReleases = [];

  // Process each update item
  for (let i = 0; i < updateItems.length; i++) {
    const updateItem = updateItems[i];
    core.info(`Processing update-release item ${i + 1}/${updateItems.length}`);

    try {
      // Get the release by tag
      core.info(`Fetching release with tag: ${updateItem.tag}`);
      const { data: release } = await github.rest.repos.getReleaseByTag({
        owner: context.repo.owner,
        repo: context.repo.repo,
        tag: updateItem.tag,
      });

      core.info(`Found release: ${release.name || release.tag_name} (ID: ${release.id})`);

      // Determine new body based on operation
      let newBody;
      if (updateItem.operation === "replace") {
        // Replace: just use the new content
        newBody = updateItem.body;
        core.info("Operation: replace (full body replacement)");
      } else {
        // Append: add horizontal line, content, and AI footer
        const aiFooter = `\n\n> AI generated by [${workflowName}](${runUrl})`;
        const appendSection = `\n\n---\n\n${updateItem.body}${aiFooter}`;
        newBody = (release.body || "") + appendSection;
        core.info("Operation: append (add to end with separator)");
      }

      // Update the release
      const { data: updatedRelease } = await github.rest.repos.updateRelease({
        owner: context.repo.owner,
        repo: context.repo.repo,
        release_id: release.id,
        body: newBody,
      });

      core.info(`Successfully updated release: ${updatedRelease.html_url}`);

      updatedReleases.push({
        tag: updateItem.tag,
        url: updatedRelease.html_url,
        id: updatedRelease.id,
      });

      // Set outputs for the first release
      if (i === 0) {
        core.setOutput("release_id", updatedRelease.id);
        core.setOutput("release_url", updatedRelease.html_url);
        core.setOutput("release_tag", updatedRelease.tag_name);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      core.error(`Failed to update release with tag ${updateItem.tag}: ${errorMessage}`);

      // Check for specific error cases
      if (errorMessage.includes("Not Found")) {
        core.error(`Release with tag '${updateItem.tag}' not found. Please ensure the tag exists.`);
      }

      core.setFailed(`Failed to update release: ${errorMessage}`);
      return;
    }
  }

  // Generate step summary
  let summaryContent = `## âœ… Release Updates Complete\n\n`;
  summaryContent += `Updated ${updatedReleases.length} release(s):\n\n`;

  for (const rel of updatedReleases) {
    summaryContent += `- **${rel.tag}**: [View Release](${rel.url})\n`;
  }

  await core.summary.addRaw(summaryContent).write();
}

// Call the main function
await main();
