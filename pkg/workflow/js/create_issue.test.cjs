import { describe, it, expect, beforeEach, vi } from "vitest";
import fs from "fs";
import path from "path";

// Mock the global objects that GitHub Actions provides
const mockCore = {
  // Core logging functions
  debug: vi.fn(),
  info: vi.fn(),
  notice: vi.fn(),
  warning: vi.fn(),
  error: vi.fn(),

  // Core workflow functions
  setFailed: vi.fn(),
  setOutput: vi.fn(),
  exportVariable: vi.fn(),
  setSecret: vi.fn(),

  // Input/state functions (less commonly used but included for completeness)
  getInput: vi.fn(),
  getBooleanInput: vi.fn(),
  getMultilineInput: vi.fn(),
  getState: vi.fn(),
  saveState: vi.fn(),

  // Group functions
  startGroup: vi.fn(),
  endGroup: vi.fn(),
  group: vi.fn(),

  // Other utility functions
  addPath: vi.fn(),
  setCommandEcho: vi.fn(),
  isDebug: vi.fn().mockReturnValue(false),
  getIDToken: vi.fn(),
  toPlatformPath: vi.fn(),
  toPosixPath: vi.fn(),
  toWin32Path: vi.fn(),

  // Summary object with chainable methods
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn().mockResolvedValue(),
  },
};

const mockGithub = {
  rest: {
    issues: {
      create: vi.fn(),
      createComment: vi.fn(),
    },
  },
  graphql: vi.fn(),
};

const mockContext = {
  runId: 12345,
  repo: {
    owner: "testowner",
    repo: "testrepo",
  },
  payload: {
    repository: {
      html_url: "https://github.com/testowner/testrepo",
    },
  },
};

// Set up global variables
global.core = mockCore;
global.github = mockGithub;
global.context = mockContext;

describe("create_issue.cjs", () => {
  let createIssueScript;

  let tempFilePath;

  // Helper function to set agent output via file
  const setAgentOutput = data => {
    tempFilePath = path.join("/tmp", `test_agent_output_${Date.now()}_${Math.random().toString(36).slice(2)}.json`);
    const content = typeof data === "string" ? data : JSON.stringify(data);
    fs.writeFileSync(tempFilePath, content);
    process.env.GH_AW_AGENT_OUTPUT = tempFilePath;
  };

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();

    // Reset environment variables
    delete process.env.GH_AW_AGENT_OUTPUT;
    delete process.env.GH_AW_ISSUE_LABELS;
    delete process.env.GH_AW_ISSUE_TITLE_PREFIX;

    // Reset context
    delete global.context.payload.issue;

    // Read the script content
    const scriptPath = path.join(process.cwd(), "create_issue.cjs");
    createIssueScript = fs.readFileSync(scriptPath, "utf8");
    createIssueScript = createIssueScript.replace("export {};", "");
  });

  afterEach(() => {
    // Clean up temporary file
    if (tempFilePath && require("fs").existsSync(tempFilePath)) {
      require("fs").unlinkSync(tempFilePath);
      tempFilePath = undefined;
    }
  });

  it("should skip when no agent output is provided", async () => {
    delete process.env.GH_AW_AGENT_OUTPUT;

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockCore.info).toHaveBeenCalledWith("No GH_AW_AGENT_OUTPUT environment variable found");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
  });

  it("should skip when agent output is empty", async () => {
    setAgentOutput("");

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockCore.info).toHaveBeenCalledWith("Agent output content is empty");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
  });

  it("should create issue with default title when only body content provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          body: "This is the issue body content",
        },
      ],
    });

    const mockIssue = {
      number: 456,
      html_url: "https://github.com/testowner/testrepo/issues/456",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalledWith({
      owner: "testowner",
      repo: "testrepo",
      title: "This is the issue body content",
      body: expect.stringContaining("AI generated by"),
      labels: [],
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", 456);
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", mockIssue.html_url);
  });

  it("should extract title from markdown heading", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Bug Report",
          body: "This is a detailed bug description\n\nSteps to reproduce:\n1. Step one",
        },
      ],
    });

    const mockIssue = {
      number: 789,
      html_url: "https://github.com/testowner/testrepo/issues/789",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("Bug Report");
    expect(callArgs.body).toContain("This is a detailed bug description");
    expect(callArgs.body).toContain("Steps to reproduce:");
  });

  it("should handle labels from environment variable", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with labels",
          body: "Issue with labels",
        },
      ],
    });
    process.env.GH_AW_ISSUE_LABELS = "bug, enhancement, high-priority";

    const mockIssue = {
      number: 101,
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual(["bug", "enhancement", "high-priority"]);
  });

  it("should apply title prefix when provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Simple issue title",
          body: "Simple issue title",
        },
      ],
    });
    process.env.GH_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 202,
      html_url: "https://github.com/testowner/testrepo/issues/202",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Simple issue title");
  });

  it("should not duplicate title prefix when already present", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "[AUTO] Issue title already prefixed",
          body: "Issue body content",
        },
      ],
    });
    process.env.GH_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 203,
      html_url: "https://github.com/testowner/testrepo/issues/203",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Issue title already prefixed"); // Should not be duplicated
  });

  it("should handle parent issue context and create comment", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Child issue content",
          body: "Child issue content",
        },
      ],
    });
    global.context.payload.issue = { number: 555 };

    const mockIssue = {
      number: 666,
      html_url: "https://github.com/testowner/testrepo/issues/666",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql calls for sub-issue linking
    let graphqlCallCount = 0;
    mockGithub.graphql.mockImplementation(() => {
      graphqlCallCount++;
      if (graphqlCallCount === 1) {
        return Promise.resolve({ repository: { issue: { id: "parent-node-id-555" } } });
      }
      if (graphqlCallCount === 2) {
        return Promise.resolve({ repository: { issue: { id: "child-node-id-666" } } });
      }
      if (graphqlCallCount === 3) {
        return Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-666", number: 666 } } });
      }
      return Promise.reject(new Error("Unexpected graphql call"));
    });

    mockGithub.rest.issues.createComment.mockResolvedValue({});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should create the child issue with reference to parent
    const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(createArgs.body).toContain("Related to #555");

    // Note: GraphQL sub-issue linking and comment creation are tested in integration tests
  });

  it("should handle empty labels gracefully", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue without labels",
          body: "Issue without labels",
        },
      ],
    });
    process.env.GH_AW_ISSUE_LABELS = "  , , ";

    const mockIssue = {
      number: 303,
      html_url: "https://github.com/testowner/testrepo/issues/303",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual([]);
  });

  it("should include run information in issue body", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test issue content",
          body: "Test issue content",
        },
      ],
    });

    const mockIssue = {
      number: 404,
      html_url: "https://github.com/testowner/testrepo/issues/404",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.body).toContain("AI generated by");
    expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345");
  });

  it("should handle disabled issues repository gracefully", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test issue",
          body: "This should fail gracefully",
        },
      ],
    });

    // Mock GitHub API to throw the specific error for disabled issues
    const disabledError = new Error("Issues has been disabled in this repository.");
    mockGithub.rest.issues.create.mockRejectedValue(disabledError);

    const consoleErrorSpy = vi.spyOn(console, "error").mockImplementation(() => {});

    // Execute the script - should not throw error
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning message instead of error
    expect(mockCore.info).toHaveBeenCalledWith('⚠ Cannot create issue "Test issue": Issues are disabled for this repository');
    expect(mockCore.info).toHaveBeenCalledWith(
      "Consider enabling issues in repository settings if you want to create issues automatically"
    );

    // Should not have called console.error for this specific error
    expect(consoleErrorSpy).not.toHaveBeenCalledWith(expect.stringContaining("✗ Failed to create issue"));

    // Should still log successful completion with 0 issues
    expect(mockCore.info).toHaveBeenCalledWith("Successfully created 0 issue(s)");

    // Should have initialized outputs to empty strings
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", "");
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", "");

    consoleErrorSpy.mockRestore();
  });

  it("should continue processing other issues when one fails due to disabled repository", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "First issue",
          body: "This will fail",
        },
        {
          type: "create_issue",
          title: "Second issue",
          body: "This should succeed",
        },
      ],
    });

    const disabledError = new Error("Issues has been disabled in this repository.");
    const mockIssue = {
      number: 505,
      html_url: "https://github.com/testowner/testrepo/issues/505",
    };

    // First call fails with disabled error, second call succeeds
    mockGithub.rest.issues.create.mockRejectedValueOnce(disabledError).mockResolvedValueOnce({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning for first issue
    expect(mockCore.info).toHaveBeenCalledWith('⚠ Cannot create issue "First issue": Issues are disabled for this repository');

    // Both API calls should have been made
    expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(2);
  });

  it("should handle duplicate labels by removing duplicates", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with duplicate labels",
          body: "Testing duplicate label handling",
          labels: ["bug", "enhancement", "bug", "automation"],
        },
      ],
    });
    process.env.GH_AW_ISSUE_LABELS = "bug,enhancement,automation"; // Duplicates environment labels

    const mockIssue = {
      number: 606,
      html_url: "https://github.com/testowner/testrepo/issues/606",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should only have unique labels and not duplicates
    expect(callArgs.labels).toEqual(["bug", "enhancement", "automation"]);
    expect(callArgs.labels).toHaveLength(3); // No duplicates
  });

  it("should sanitize labels by removing problematic characters", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with problematic labels",
          body: "Testing label sanitization",
          labels: ["bug<script>", "enhancement@user", "automation&test", "normal-label"],
        },
      ],
    });

    const mockIssue = {
      number: 707,
      html_url: "https://github.com/testowner/testrepo/issues/707",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should sanitize problematic characters
    expect(callArgs.labels).toEqual(["bugscript", "enhancement@user", "automationtest", "normal-label"]);
  });

  it("should limit label length to 64 characters", async () => {
    const longLabel = "a".repeat(100); // 100 character label
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with long labels",
          body: "Testing label length limiting",
          labels: [longLabel, "short"],
        },
      ],
    });

    const mockIssue = {
      number: 808,
      html_url: "https://github.com/testowner/testrepo/issues/808",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should limit long label to 64 characters
    expect(callArgs.labels[0]).toHaveLength(64);
    expect(callArgs.labels[0]).toBe("a".repeat(64));
    expect(callArgs.labels[1]).toBe("short");
  });

  it("should remove empty and whitespace-only labels", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with empty labels",
          body: "Testing empty label removal",
          labels: ["bug", "", "   ", "enhancement", null, undefined, 0, false],
        },
      ],
    });

    const mockIssue = {
      number: 909,
      html_url: "https://github.com/testowner/testrepo/issues/909",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should only keep valid non-empty labels
    expect(callArgs.labels).toEqual(["bug", "enhancement"]);
  });

  it("should include workflow source in footer when GH_AW_WORKFLOW_SOURCE is provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test Issue",
          body: "Test issue with source",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";
    process.env.GH_AW_WORKFLOW_SOURCE = "githubnext/agentics/workflows/ci-doctor.md@v1.0.0";
    process.env.GH_AW_WORKFLOW_SOURCE_URL = "https://github.com/githubnext/agentics/tree/v1.0.0/workflows/ci-doctor.md";

    const mockIssue = {
      number: 101,
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalled();
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the body contains the expected elements
    expect(callArgs.body).toContain("Test issue with source");
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345");
    expect(callArgs.body).toContain("gh aw add githubnext/agentics/workflows/ci-doctor.md@v1.0.0");
    expect(callArgs.body).toContain("usage guide");
  });

  it("should not include workflow source footer when GH_AW_WORKFLOW_SOURCE is not provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test Issue",
          body: "Test issue without source",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";
    delete process.env.GH_AW_WORKFLOW_SOURCE; // Ensure it's not set

    const mockIssue = {
      number: 102,
      html_url: "https://github.com/testowner/testrepo/issues/102",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalled();
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the body does NOT contain the workflow source
    expect(callArgs.body).toContain("Test issue without source");
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).not.toContain("gh aw add");
    expect(callArgs.body).not.toContain("usage guide");
  });

  it("should include triggering issue number in footer when in issue context", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "New issue from issue context",
          body: "Created from issue #42",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Simulate issue context
    global.context.payload.issue = { number: 42 };

    const mockIssue = {
      number: 999,
      html_url: "https://github.com/testowner/testrepo/issues/999",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql for sub-issue linking
    mockGithub.graphql.mockResolvedValue({
      repository: { issue: { id: "test-id" } },
      addSubIssue: { subIssue: { id: "test-id", number: 999 } },
    });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer includes reference to triggering issue
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).toContain("for #42");
  });

  it("should include triggering PR number in footer when in PR context", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "New issue from PR context",
          body: "Created from PR",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Simulate PR context (issue with pull_request object)
    delete global.context.payload.issue;
    global.context.payload.pull_request = { number: 123 };

    const mockIssue = {
      number: 888,
      html_url: "https://github.com/testowner/testrepo/issues/888",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer includes reference to triggering PR
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).toContain("for #123");

    // Clean up
    delete global.context.payload.pull_request;
  });

  it("should not include triggering reference when no context available", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "New issue without context",
          body: "No triggering context",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Ensure no context
    delete global.context.payload.issue;
    delete global.context.payload.pull_request;
    delete global.context.payload.discussion;

    const mockIssue = {
      number: 777,
      html_url: "https://github.com/testowner/testrepo/issues/777",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer does not include "for #" reference
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).not.toMatch(/for #\d+/);
    expect(callArgs.body).not.toMatch(/for discussion #\d+/);
  });

  it("should handle parent discussion context and add reference in body", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Child issue from discussion",
          body: "Child issue content from discussion",
        },
      ],
    });
    global.context.payload.discussion = { number: 888 };

    const mockIssue = {
      number: 999,
      html_url: "https://github.com/testowner/testrepo/issues/999",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql to fail for discussion (since GitHub doesn't support querying discussions as issues)
    mockGithub.graphql.mockRejectedValue(new Error("Could not resolve to a node with the global id"));

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(1);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("Child issue from discussion");
    expect(callArgs.body).toContain("Related to #888");

    // Verify that the parent context was detected
    expect(mockCore.info).toHaveBeenCalledWith("Detected issue or discussion context, parent #888");
  });

  it("should include triggering discussion number in footer when in discussion context", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue from discussion",
          body: "Issue content from discussion",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Discussion Workflow";
    global.context.payload.discussion = { number: 444 };

    const mockIssue = {
      number: 555,
      html_url: "https://github.com/testowner/testrepo/issues/555",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql to simulate successful linking
    mockGithub.graphql.mockResolvedValue({
      repository: { issue: { id: "node-id" } },
      addSubIssue: { subIssue: { id: "node-id", number: 555 } },
    });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer includes discussion reference
    expect(callArgs.body).toContain("AI generated by [Discussion Workflow]");
    expect(callArgs.body).toContain("for discussion #444");
  });
});
