import { describe, it, expect, beforeEach, vi } from "vitest";
import fs from "fs";
import path from "path";

// Mock the global objects that GitHub Actions provides
const mockCore = {
  // Core logging functions
  debug: vi.fn(),
  info: vi.fn(),
  notice: vi.fn(),
  warning: vi.fn(),
  error: vi.fn(),

  // Core workflow functions
  setFailed: vi.fn(),
  setOutput: vi.fn(),
  exportVariable: vi.fn(),
  setSecret: vi.fn(),

  // Input/state functions (less commonly used but included for completeness)
  getInput: vi.fn(),
  getBooleanInput: vi.fn(),
  getMultilineInput: vi.fn(),
  getState: vi.fn(),
  saveState: vi.fn(),

  // Group functions
  startGroup: vi.fn(),
  endGroup: vi.fn(),
  group: vi.fn(),

  // Other utility functions
  addPath: vi.fn(),
  setCommandEcho: vi.fn(),
  isDebug: vi.fn().mockReturnValue(false),
  getIDToken: vi.fn(),
  toPlatformPath: vi.fn(),
  toPosixPath: vi.fn(),
  toWin32Path: vi.fn(),

  // Summary object with chainable methods
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn().mockResolvedValue(),
  },
};

const mockGithub = {
  rest: {
    issues: {
      create: vi.fn(),
      createComment: vi.fn(),
    },
  },
  graphql: vi.fn(),
};

const mockContext = {
  runId: 12345,
  repo: {
    owner: "testowner",
    repo: "testrepo",
  },
  payload: {
    repository: {
      html_url: "https://github.com/testowner/testrepo",
    },
  },
};

// Set up global variables
global.core = mockCore;
global.github = mockGithub;
global.context = mockContext;

describe("create_issue.cjs", () => {
  let createIssueScript;

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();

    // Reset environment variables
    delete process.env.GITHUB_AW_AGENT_OUTPUT;
    delete process.env.GITHUB_AW_ISSUE_LABELS;
    delete process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;

    // Reset context
    delete global.context.payload.issue;

    // Read the script content
    const scriptPath = path.join(process.cwd(), "create_issue.cjs");
    createIssueScript = fs.readFileSync(scriptPath, "utf8");
    createIssueScript = createIssueScript.replace("export {};", "");
  });

  it("should skip when no agent output is provided", async () => {
    delete process.env.GITHUB_AW_AGENT_OUTPUT;

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockCore.info).toHaveBeenCalledWith("No GITHUB_AW_AGENT_OUTPUT environment variable found");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
  });

  it("should skip when agent output is empty", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = "   ";

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockCore.info).toHaveBeenCalledWith("Agent output content is empty");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
  });

  it("should create issue with default title when only body content provided", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          body: "This is the issue body content",
        },
      ],
    });

    const mockIssue = {
      number: 456,
      html_url: "https://github.com/testowner/testrepo/issues/456",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalledWith({
      owner: "testowner",
      repo: "testrepo",
      title: "This is the issue body content",
      body: expect.stringContaining("AI generated by"),
      labels: [],
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", 456);
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", mockIssue.html_url);
  });

  it("should extract title from markdown heading", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Bug Report",
          body: "This is a detailed bug description\n\nSteps to reproduce:\n1. Step one",
        },
      ],
    });

    const mockIssue = {
      number: 789,
      html_url: "https://github.com/testowner/testrepo/issues/789",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("Bug Report");
    expect(callArgs.body).toContain("This is a detailed bug description");
    expect(callArgs.body).toContain("Steps to reproduce:");
  });

  it("should handle labels from environment variable", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue with labels",
          body: "Issue with labels",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_LABELS = "bug, enhancement, high-priority";

    const mockIssue = {
      number: 101,
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual(["bug", "enhancement", "high-priority"]);
  });

  it("should apply title prefix when provided", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Simple issue title",
          body: "Simple issue title",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 202,
      html_url: "https://github.com/testowner/testrepo/issues/202",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Simple issue title");
  });

  it("should not duplicate title prefix when already present", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "[AUTO] Issue title already prefixed",
          body: "Issue body content",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 203,
      html_url: "https://github.com/testowner/testrepo/issues/203",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Issue title already prefixed"); // Should not be duplicated
  });

  it("should handle parent issue context and create comment", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Child issue content",
          body: "Child issue content",
        },
      ],
    });
    global.context.payload.issue = { number: 555 };

    const mockIssue = {
      number: 666,
      html_url: "https://github.com/testowner/testrepo/issues/666",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql calls for sub-issue linking
    let graphqlCallCount = 0;
    mockGithub.graphql.mockImplementation(() => {
      graphqlCallCount++;
      if (graphqlCallCount === 1) {
        return Promise.resolve({ repository: { issue: { id: "parent-node-id-555" } } });
      }
      if (graphqlCallCount === 2) {
        return Promise.resolve({ repository: { issue: { id: "child-node-id-666" } } });
      }
      if (graphqlCallCount === 3) {
        return Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-666", number: 666 } } });
      }
      return Promise.reject(new Error("Unexpected graphql call"));
    });

    mockGithub.rest.issues.createComment.mockResolvedValue({});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should create the child issue with reference to parent
    const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(createArgs.body).toContain("Related to #555");

    // Note: GraphQL sub-issue linking and comment creation are tested in integration tests
  });

  it("should handle empty labels gracefully", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue without labels",
          body: "Issue without labels",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_LABELS = "  , , ";

    const mockIssue = {
      number: 303,
      html_url: "https://github.com/testowner/testrepo/issues/303",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual([]);
  });

  it("should include run information in issue body", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Test issue content",
          body: "Test issue content",
        },
      ],
    });

    const mockIssue = {
      number: 404,
      html_url: "https://github.com/testowner/testrepo/issues/404",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.body).toContain("AI generated by");
    expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345");
  });

  it("should handle disabled issues repository gracefully", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Test issue",
          body: "This should fail gracefully",
        },
      ],
    });

    // Mock GitHub API to throw the specific error for disabled issues
    const disabledError = new Error("Issues has been disabled in this repository.");
    mockGithub.rest.issues.create.mockRejectedValue(disabledError);

    const consoleErrorSpy = vi.spyOn(console, "error").mockImplementation(() => {});

    // Execute the script - should not throw error
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning message instead of error
    expect(mockCore.info).toHaveBeenCalledWith('⚠ Cannot create issue "Test issue": Issues are disabled for this repository');
    expect(mockCore.info).toHaveBeenCalledWith(
      "Consider enabling issues in repository settings if you want to create issues automatically"
    );

    // Should not have called console.error for this specific error
    expect(consoleErrorSpy).not.toHaveBeenCalledWith(expect.stringContaining("✗ Failed to create issue"));

    // Should still log successful completion with 0 issues
    expect(mockCore.info).toHaveBeenCalledWith("Successfully created 0 issue(s)");

    // Should not set outputs since no issues were created
    expect(mockCore.setOutput).not.toHaveBeenCalled();

    consoleErrorSpy.mockRestore();
  });

  it("should continue processing other issues when one fails due to disabled repository", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "First issue",
          body: "This will fail",
        },
        {
          type: "create-issue",
          title: "Second issue",
          body: "This should succeed",
        },
      ],
    });

    const disabledError = new Error("Issues has been disabled in this repository.");
    const mockIssue = {
      number: 505,
      html_url: "https://github.com/testowner/testrepo/issues/505",
    };

    // First call fails with disabled error, second call succeeds
    mockGithub.rest.issues.create.mockRejectedValueOnce(disabledError).mockResolvedValueOnce({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning for first issue
    expect(mockCore.info).toHaveBeenCalledWith('⚠ Cannot create issue "First issue": Issues are disabled for this repository');

    // Both API calls should have been made
    expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(2);
  });

  it("should handle duplicate labels by removing duplicates", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue with duplicate labels",
          body: "Testing duplicate label handling",
          labels: ["bug", "enhancement", "bug", "automation"],
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_LABELS = "bug,enhancement,automation"; // Duplicates environment labels

    const mockIssue = {
      number: 606,
      html_url: "https://github.com/testowner/testrepo/issues/606",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should only have unique labels and not duplicates
    expect(callArgs.labels).toEqual(["bug", "enhancement", "automation"]);
    expect(callArgs.labels).toHaveLength(3); // No duplicates
  });

  it("should sanitize labels by removing problematic characters", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue with problematic labels",
          body: "Testing label sanitization",
          labels: ["bug<script>", "enhancement@user", "automation&test", "normal-label"],
        },
      ],
    });

    const mockIssue = {
      number: 707,
      html_url: "https://github.com/testowner/testrepo/issues/707",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should sanitize problematic characters
    expect(callArgs.labels).toEqual(["bugscript", "enhancement@user", "automationtest", "normal-label"]);
  });

  it("should limit label length to 64 characters", async () => {
    const longLabel = "a".repeat(100); // 100 character label
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue with long labels",
          body: "Testing label length limiting",
          labels: [longLabel, "short"],
        },
      ],
    });

    const mockIssue = {
      number: 808,
      html_url: "https://github.com/testowner/testrepo/issues/808",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should limit long label to 64 characters
    expect(callArgs.labels[0]).toHaveLength(64);
    expect(callArgs.labels[0]).toBe("a".repeat(64));
    expect(callArgs.labels[1]).toBe("short");
  });

  it("should remove empty and whitespace-only labels", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue with empty labels",
          body: "Testing empty label removal",
          labels: ["bug", "", "   ", "enhancement", null, undefined, 0, false],
        },
      ],
    });

    const mockIssue = {
      number: 909,
      html_url: "https://github.com/testowner/testrepo/issues/909",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should only keep valid non-empty labels
    expect(callArgs.labels).toEqual(["bug", "enhancement"]);
  });
});
