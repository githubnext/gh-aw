import { describe, it, expect, beforeEach, vi } from "vitest";
import fs from "fs";
import path from "path";

// Mock the global objects that GitHub Actions provides
const mockCore = {
  // Core logging functions
  debug: vi.fn(),
  info: vi.fn(),
  notice: vi.fn(),
  warning: vi.fn(),
  error: vi.fn(),

  // Core workflow functions
  setFailed: vi.fn(),
  setOutput: vi.fn(),
  exportVariable: vi.fn(),
  setSecret: vi.fn(),

  // Input/state functions (less commonly used but included for completeness)
  getInput: vi.fn(),
  getBooleanInput: vi.fn(),
  getMultilineInput: vi.fn(),
  getState: vi.fn(),
  saveState: vi.fn(),

  // Group functions
  startGroup: vi.fn(),
  endGroup: vi.fn(),
  group: vi.fn(),

  // Other utility functions
  addPath: vi.fn(),
  setCommandEcho: vi.fn(),
  isDebug: vi.fn().mockReturnValue(false),
  getIDToken: vi.fn(),
  toPlatformPath: vi.fn(),
  toPosixPath: vi.fn(),
  toWin32Path: vi.fn(),

  // Summary object with chainable methods
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn().mockResolvedValue(),
  },
};

const mockGithub = {
  rest: {
    issues: {
      create: vi.fn(),
      createComment: vi.fn(),
    },
  },
  graphql: vi.fn(),
};

const mockContext = {
  runId: 12345,
  repo: {
    owner: "testowner",
    repo: "testrepo",
  },
  payload: {
    repository: {
      html_url: "https://github.com/testowner/testrepo",
    },
  },
};

// Set up global variables
global.core = mockCore;
global.github = mockGithub;
global.context = mockContext;

describe("create_issue.cjs", () => {
  let createIssueScript;

  let tempFilePath;

  // Helper function to set agent output via file
  const setAgentOutput = data => {
    tempFilePath = path.join("/tmp", `test_agent_output_${Date.now()}_${Math.random().toString(36).slice(2)}.json`);
    const content = typeof data === "string" ? data : JSON.stringify(data);
    fs.writeFileSync(tempFilePath, content);
    process.env.GH_AW_AGENT_OUTPUT = tempFilePath;
  };

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();

    // Reset environment variables
    delete process.env.GH_AW_AGENT_OUTPUT;
    delete process.env.GH_AW_ISSUE_LABELS;
    delete process.env.GH_AW_ISSUE_TITLE_PREFIX;

    // Reset context
    delete global.context.payload.issue;

    // Read the script content
    const scriptPath = path.join(process.cwd(), "create_issue.cjs");
    createIssueScript = fs.readFileSync(scriptPath, "utf8");
    createIssueScript = createIssueScript.replace("export {};", "");
    // Remove the outer async IIFE wrapper so we can properly await main()
    createIssueScript = createIssueScript.replace(/\(async \(\) => \{\s*await main\(\);\s*\}\)\(\);?\s*$/, "await main();");
  });

  afterEach(() => {
    // Clean up temporary file
    if (tempFilePath && require("fs").existsSync(tempFilePath)) {
      require("fs").unlinkSync(tempFilePath);
      tempFilePath = undefined;
    }
  });

  it("should skip when no agent output is provided", async () => {
    delete process.env.GH_AW_AGENT_OUTPUT;

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockCore.info).toHaveBeenCalledWith("No GH_AW_AGENT_OUTPUT environment variable found");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
  });

  it("should skip when agent output is empty", async () => {
    setAgentOutput("");

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockCore.info).toHaveBeenCalledWith("Agent output content is empty");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
  });

  it("should create issue with default title when only body content provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          body: "This is the issue body content",
        },
      ],
    });

    const mockIssue = {
      number: 456,
      html_url: "https://github.com/testowner/testrepo/issues/456",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalledWith({
      owner: "testowner",
      repo: "testrepo",
      title: "This is the issue body content",
      body: expect.stringContaining("AI generated by"),
      labels: [],
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", 456);
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", mockIssue.html_url);
  });

  it("should extract title from markdown heading", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Bug Report",
          body: "This is a detailed bug description\n\nSteps to reproduce:\n1. Step one",
        },
      ],
    });

    const mockIssue = {
      number: 789,
      html_url: "https://github.com/testowner/testrepo/issues/789",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("Bug Report");
    expect(callArgs.body).toContain("This is a detailed bug description");
    expect(callArgs.body).toContain("Steps to reproduce:");
  });

  it("should handle labels from environment variable", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with labels",
          body: "Issue with labels",
        },
      ],
    });
    process.env.GH_AW_ISSUE_LABELS = "bug, enhancement, high-priority";

    const mockIssue = {
      number: 101,
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual(["bug", "enhancement", "high-priority"]);
  });

  it("should apply title prefix when provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Simple issue title",
          body: "Simple issue title",
        },
      ],
    });
    process.env.GH_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 202,
      html_url: "https://github.com/testowner/testrepo/issues/202",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Simple issue title");
  });

  it("should not duplicate title prefix when already present", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "[AUTO] Issue title already prefixed",
          body: "Issue body content",
        },
      ],
    });
    process.env.GH_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 203,
      html_url: "https://github.com/testowner/testrepo/issues/203",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Issue title already prefixed"); // Should not be duplicated
  });

  it("should handle parent issue context and create comment", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Child issue content",
          body: "Child issue content",
        },
      ],
    });
    global.context.payload.issue = { number: 555 };

    const mockIssue = {
      number: 666,
      html_url: "https://github.com/testowner/testrepo/issues/666",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql calls for sub-issue linking
    let graphqlCallCount = 0;
    mockGithub.graphql.mockImplementation(() => {
      graphqlCallCount++;
      if (graphqlCallCount === 1) {
        return Promise.resolve({ repository: { issue: { id: "parent-node-id-555" } } });
      }
      if (graphqlCallCount === 2) {
        return Promise.resolve({ repository: { issue: { id: "child-node-id-666" } } });
      }
      if (graphqlCallCount === 3) {
        return Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-666", number: 666 } } });
      }
      return Promise.reject(new Error("Unexpected graphql call"));
    });

    mockGithub.rest.issues.createComment.mockResolvedValue({});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should create the child issue with reference to parent
    const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(createArgs.body).toContain("Related to #555");

    // Note: GraphQL sub-issue linking and comment creation are tested in integration tests
  });

  it("should handle empty labels gracefully", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue without labels",
          body: "Issue without labels",
        },
      ],
    });
    process.env.GH_AW_ISSUE_LABELS = "  , , ";

    const mockIssue = {
      number: 303,
      html_url: "https://github.com/testowner/testrepo/issues/303",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual([]);
  });

  it("should include run information in issue body", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test issue content",
          body: "Test issue content",
        },
      ],
    });

    const mockIssue = {
      number: 404,
      html_url: "https://github.com/testowner/testrepo/issues/404",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.body).toContain("AI generated by");
    expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345");
  });

  it("should handle disabled issues repository gracefully", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test issue",
          body: "This should fail gracefully",
        },
      ],
    });

    // Mock GitHub API to throw the specific error for disabled issues
    const disabledError = new Error("Issues has been disabled in this repository.");
    mockGithub.rest.issues.create.mockRejectedValue(disabledError);

    const consoleErrorSpy = vi.spyOn(console, "error").mockImplementation(() => {});

    // Execute the script - should not throw error
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning message instead of error
    expect(mockCore.info).toHaveBeenCalledWith('âš  Cannot create issue "Test issue": Issues are disabled for this repository');
    expect(mockCore.info).toHaveBeenCalledWith(
      "Consider enabling issues in repository settings if you want to create issues automatically"
    );

    // Should not have called console.error for this specific error
    expect(consoleErrorSpy).not.toHaveBeenCalledWith(expect.stringContaining("âœ— Failed to create issue"));

    // Should still log successful completion with 0 issues
    expect(mockCore.info).toHaveBeenCalledWith("Successfully created 0 issue(s)");

    // Should have initialized outputs to empty strings
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", "");
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", "");

    consoleErrorSpy.mockRestore();
  });

  it("should continue processing other issues when one fails due to disabled repository", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "First issue",
          body: "This will fail",
        },
        {
          type: "create_issue",
          title: "Second issue",
          body: "This should succeed",
        },
      ],
    });

    const disabledError = new Error("Issues has been disabled in this repository.");
    const mockIssue = {
      number: 505,
      html_url: "https://github.com/testowner/testrepo/issues/505",
    };

    // First call fails with disabled error, second call succeeds
    mockGithub.rest.issues.create.mockRejectedValueOnce(disabledError).mockResolvedValueOnce({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning for first issue
    expect(mockCore.info).toHaveBeenCalledWith('âš  Cannot create issue "First issue": Issues are disabled for this repository');

    // Both API calls should have been made
    expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(2);
  });

  it("should handle duplicate labels by removing duplicates", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with duplicate labels",
          body: "Testing duplicate label handling",
          labels: ["bug", "enhancement", "bug", "automation"],
        },
      ],
    });
    process.env.GH_AW_ISSUE_LABELS = "bug,enhancement,automation"; // Duplicates environment labels

    const mockIssue = {
      number: 606,
      html_url: "https://github.com/testowner/testrepo/issues/606",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should only have unique labels and not duplicates
    expect(callArgs.labels).toEqual(["bug", "enhancement", "automation"]);
    expect(callArgs.labels).toHaveLength(3); // No duplicates
  });

  it("should sanitize labels by removing problematic characters", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with problematic labels",
          body: "Testing label sanitization",
          labels: ["bug<script>", "enhancement@user", "automation&test", "normal-label"],
        },
      ],
    });

    const mockIssue = {
      number: 707,
      html_url: "https://github.com/testowner/testrepo/issues/707",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should sanitize problematic characters
    expect(callArgs.labels).toEqual(["bugscript", "enhancement@user", "automationtest", "normal-label"]);
  });

  it("should limit label length to 64 characters", async () => {
    const longLabel = "a".repeat(100); // 100 character label
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with long labels",
          body: "Testing label length limiting",
          labels: [longLabel, "short"],
        },
      ],
    });

    const mockIssue = {
      number: 808,
      html_url: "https://github.com/testowner/testrepo/issues/808",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should limit long label to 64 characters
    expect(callArgs.labels[0]).toHaveLength(64);
    expect(callArgs.labels[0]).toBe("a".repeat(64));
    expect(callArgs.labels[1]).toBe("short");
  });

  it("should remove empty and whitespace-only labels", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with empty labels",
          body: "Testing empty label removal",
          labels: ["bug", "", "   ", "enhancement", null, undefined, 0, false],
        },
      ],
    });

    const mockIssue = {
      number: 909,
      html_url: "https://github.com/testowner/testrepo/issues/909",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    // Should only keep valid non-empty labels
    expect(callArgs.labels).toEqual(["bug", "enhancement"]);
  });

  it("should include workflow source in footer when GH_AW_WORKFLOW_SOURCE is provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test Issue",
          body: "Test issue with source",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";
    process.env.GH_AW_WORKFLOW_SOURCE = "githubnext/agentics/workflows/ci-doctor.md@v1.0.0";
    process.env.GH_AW_WORKFLOW_SOURCE_URL = "https://github.com/githubnext/agentics/tree/v1.0.0/workflows/ci-doctor.md";

    const mockIssue = {
      number: 101,
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalled();
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the body contains the expected elements
    expect(callArgs.body).toContain("Test issue with source");
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345");
    expect(callArgs.body).toContain("gh aw add githubnext/agentics/workflows/ci-doctor.md@v1.0.0");
    expect(callArgs.body).toContain("usage guide");
  });

  it("should not include workflow source footer when GH_AW_WORKFLOW_SOURCE is not provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Test Issue",
          body: "Test issue without source",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";
    delete process.env.GH_AW_WORKFLOW_SOURCE; // Ensure it's not set

    const mockIssue = {
      number: 102,
      html_url: "https://github.com/testowner/testrepo/issues/102",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalled();
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the body does NOT contain the workflow source
    expect(callArgs.body).toContain("Test issue without source");
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).not.toContain("gh aw add");
    expect(callArgs.body).not.toContain("usage guide");
  });

  it("should include triggering issue number in footer when in issue context", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "New issue from issue context",
          body: "Created from issue #42",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Simulate issue context
    global.context.payload.issue = { number: 42 };

    const mockIssue = {
      number: 999,
      html_url: "https://github.com/testowner/testrepo/issues/999",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Mock graphql for sub-issue linking
    mockGithub.graphql.mockResolvedValue({
      repository: { issue: { id: "test-id" } },
      addSubIssue: { subIssue: { id: "test-id", number: 999 } },
    });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer includes reference to triggering issue
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).toContain("for #42");
  });

  it("should include triggering PR number in footer when in PR context", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "New issue from PR context",
          body: "Created from PR",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Simulate PR context (issue with pull_request object)
    delete global.context.payload.issue;
    global.context.payload.pull_request = { number: 123 };

    const mockIssue = {
      number: 888,
      html_url: "https://github.com/testowner/testrepo/issues/888",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer includes reference to triggering PR
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).toContain("for #123");

    // Clean up
    delete global.context.payload.pull_request;
  });

  it("should not include triggering reference when no context available", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "New issue without context",
          body: "No triggering context",
        },
      ],
    });
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Ensure no context
    delete global.context.payload.issue;
    delete global.context.payload.pull_request;
    delete global.context.payload.discussion;

    const mockIssue = {
      number: 777,
      html_url: "https://github.com/testowner/testrepo/issues/777",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];

    // Check that the footer does not include "for #" reference
    expect(callArgs.body).toContain("AI generated by [Test Workflow]");
    expect(callArgs.body).not.toMatch(/for #\d+/);
    expect(callArgs.body).not.toMatch(/for discussion #\d+/);
  });

  it("should log summary content to core.info in staged mode", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Staged Issue Title",
          body: "Staged issue body content",
          labels: ["bug", "enhancement"],
        },
      ],
    });
    process.env.GH_AW_SAFE_OUTPUTS_STAGED = "true";

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should not create any issues in staged mode
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();

    // Should write to step summary
    expect(mockCore.summary.addRaw).toHaveBeenCalled();
    expect(mockCore.summary.write).toHaveBeenCalled();

    // Should log the summary content to core.info
    const infoCall = mockCore.info.mock.calls.find(call => call[0].includes("ðŸŽ­ Staged Mode: Create Issues Preview"));
    expect(infoCall).toBeDefined();
    expect(infoCall[0]).toContain("### Issue 1");
    expect(infoCall[0]).toContain("**Title:** Staged Issue Title");
    expect(infoCall[0]).toContain("**Body:**");
    expect(infoCall[0]).toContain("Staged issue body content");
    expect(infoCall[0]).toContain("**Labels:** bug, enhancement");

    // Should also log the completion message
    expect(mockCore.info).toHaveBeenCalledWith("ðŸ“ Create Issues preview written to step summary");

    // Clean up
    delete process.env.GH_AW_SAFE_OUTPUTS_STAGED;
  });

  it("should generate temporary_id_map output with created issues", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Parent Issue",
          body: "This is a parent issue",
          temporary_id: "aw_abc123def456",
        },
      ],
    });

    const mockIssue = {
      number: 100,
      title: "Parent Issue",
      html_url: "https://github.com/testowner/testrepo/issues/100",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should set the temporary_id_map output - find all calls and get the last non-empty one
    const setOutputCalls = mockCore.setOutput.mock.calls;
    const tempIdMapCalls = setOutputCalls.filter(call => call[0] === "temporary_id_map");
    // Get the last call (the one with actual data)
    const lastTempIdMapCall = tempIdMapCalls[tempIdMapCalls.length - 1];
    expect(lastTempIdMapCall).toBeDefined();
    expect(JSON.parse(lastTempIdMapCall[1])).toEqual({ aw_abc123def456: 100 });
    expect(mockCore.info).toHaveBeenCalledWith("Stored temporary ID mapping: aw_abc123def456 -> #100");
  });

  it("should resolve parent temporary_id to issue number when creating sub-issues", async () => {
    // Create both parent and sub-issue in same workflow run
    // Use valid aw_ prefixed hex strings for temporary IDs
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Parent Issue",
          body: "This is a parent issue",
          temporary_id: "aw_aabbccdd1122", // Valid aw_ prefixed hex string
        },
        {
          type: "create_issue",
          title: "Sub Issue",
          body: "This is a sub-issue",
          parent: "aw_aabbccdd1122", // Reference parent by temporary_id
        },
      ],
    });

    const parentIssue = {
      number: 100,
      title: "Parent Issue",
      html_url: "https://github.com/testowner/testrepo/issues/100",
    };

    const subIssue = {
      number: 101,
      title: "Sub Issue",
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    // First call creates parent, second creates sub-issue
    mockGithub.rest.issues.create.mockResolvedValueOnce({ data: parentIssue }).mockResolvedValueOnce({ data: subIssue });

    // Mock graphql for sub-issue linking
    mockGithub.graphql.mockResolvedValue({
      repository: { issue: { id: "test-node-id" } },
      addSubIssue: { subIssue: { id: "test-child-id", number: 101 } },
    });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should have resolved parent temporary_id to issue #100
    expect(mockCore.info).toHaveBeenCalledWith("Resolved parent temporary ID 'aw_aabbccdd1122' to issue #100");

    // Both issues should be created
    expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(2);
  });

  it("should replace #aw_ID references in issue body with real issue numbers", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Parent Issue",
          body: "This is a parent issue",
          temporary_id: "aw_aabbccdd1122",
        },
        {
          type: "create_issue",
          title: "Sub Issue",
          body: "This issue references #aw_aabbccdd1122 in the body",
        },
      ],
    });

    const parentIssue = {
      number: 200,
      title: "Parent Issue",
      html_url: "https://github.com/testowner/testrepo/issues/200",
    };

    const subIssue = {
      number: 201,
      title: "Sub Issue",
      html_url: "https://github.com/testowner/testrepo/issues/201",
    };

    mockGithub.rest.issues.create.mockResolvedValueOnce({ data: parentIssue }).mockResolvedValueOnce({ data: subIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // The second issue body should have the reference replaced
    const secondCallArgs = mockGithub.rest.issues.create.mock.calls[1][0];
    expect(secondCallArgs.body).toContain("#200");
    expect(secondCallArgs.body).not.toContain("#aw_aabbccdd1122");
  });

  it("should generate auto temporary_id when none is provided", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue without explicit temporary_id",
          body: "Body content",
        },
      ],
    });

    const mockIssue = {
      number: 300,
      title: "Issue without explicit temporary_id",
      html_url: "https://github.com/testowner/testrepo/issues/300",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should output temporary_id_map with auto-generated ID
    const setOutputCalls = mockCore.setOutput.mock.calls;
    // Find all temporary_id_map calls and get the last one
    const tempIdMapCalls = setOutputCalls.filter(call => call[0] === "temporary_id_map");
    const lastTempIdMapCall = tempIdMapCalls[tempIdMapCalls.length - 1];
    expect(lastTempIdMapCall).toBeDefined();

    const tempIdMap = JSON.parse(lastTempIdMapCall[1]);
    const keys = Object.keys(tempIdMap);
    expect(keys.length).toBe(1);
    // Auto-generated ID should be aw_ prefix + 12 hex characters
    expect(keys[0]).toMatch(/^aw_[0-9a-f]{12}$/);
    expect(tempIdMap[keys[0]]).toBe(300);
  });

  it("should show temporary_id in staged mode preview", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Issue with temp ID",
          body: "Body content",
          temporary_id: "aw_a1b2c3d4e5f6", // Valid aw_ prefixed hex string
        },
      ],
    });
    process.env.GH_AW_SAFE_OUTPUTS_STAGED = "true";

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should include temporary_id in preview
    const infoCall = mockCore.info.mock.calls.find(call => call[0].includes("ðŸŽ­ Staged Mode: Create Issues Preview"));
    expect(infoCall).toBeDefined();
    expect(infoCall[0]).toContain("**Temporary ID:** aw_a1b2c3d4e5f6");

    // Clean up
    delete process.env.GH_AW_SAFE_OUTPUTS_STAGED;
  });

  it("should warn when parent temporary_id is not found", async () => {
    setAgentOutput({
      items: [
        {
          type: "create_issue",
          title: "Sub Issue",
          body: "References non-existent parent",
          parent: "aw_000000000000", // Valid aw_ format but doesn't exist
        },
      ],
    });

    const mockIssue = {
      number: 400,
      title: "Sub Issue",
      html_url: "https://github.com/testowner/testrepo/issues/400",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should warn about missing parent
    expect(mockCore.warning).toHaveBeenCalledWith(expect.stringContaining("Parent temporary ID 'aw_000000000000' not found"));
  });
});
