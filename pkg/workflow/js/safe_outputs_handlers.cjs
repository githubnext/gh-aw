const fs=require("fs"),path=require("path"),crypto=require("crypto"),{normalizeBranchName}=require("./normalize_branch_name.cjs"),{estimateTokens}=require("./estimate_tokens.cjs"),{writeLargeContentToFile}=require("./write_large_content_to_file.cjs"),{getCurrentBranch}=require("./get_current_branch.cjs"),{getBaseBranch}=require("./get_base_branch.cjs"),{generateGitPatch}=require("./generate_git_patch.cjs");function createHandlers(server,appendSafeOutput,config={}){return{defaultHandler:type=>args=>{const entry={...args||{},type};let largeContent=null,largeFieldName=null;for(const[key,value]of Object.entries(entry))if("string"==typeof value){const tokens=estimateTokens(value);if(tokens>16e3){largeContent=value,largeFieldName=key,server.debug(`Field '${key}' has ${tokens} tokens (exceeds 16000)`);break}}if(largeContent&&largeFieldName){const fileInfo=writeLargeContentToFile(largeContent);return entry[largeFieldName]=`[Content too large, saved to file: ${fileInfo.filename}]`,appendSafeOutput(entry),{content:[{type:"text",text:JSON.stringify(fileInfo)}]}}return appendSafeOutput(entry),{content:[{type:"text",text:JSON.stringify({result:"success"})}]}},uploadAssetHandler:args=>{const branchName=process.env.GH_AW_ASSETS_BRANCH;if(!branchName)throw new Error("GH_AW_ASSETS_BRANCH not set");const normalizedBranchName=normalizeBranchName(branchName),{path:filePath}=args,absolutePath=path.resolve(filePath),workspaceDir=process.env.GITHUB_WORKSPACE||process.cwd(),isInWorkspace=absolutePath.startsWith(path.resolve(workspaceDir)),isInTmp=absolutePath.startsWith("/tmp");if(!isInWorkspace&&!isInTmp)throw new Error(`File path must be within workspace directory (${workspaceDir}) or /tmp directory. Provided path: ${filePath} (resolved to: ${absolutePath})`);if(!fs.existsSync(filePath))throw new Error(`File not found: ${filePath}`);const sizeBytes=fs.statSync(filePath).size,sizeKB=Math.ceil(sizeBytes/1024),maxSizeKB=process.env.GH_AW_ASSETS_MAX_SIZE_KB?parseInt(process.env.GH_AW_ASSETS_MAX_SIZE_KB,10):10240;if(sizeKB>maxSizeKB)throw new Error(`File size ${sizeKB} KB exceeds maximum allowed size ${maxSizeKB} KB`);const ext=path.extname(filePath).toLowerCase(),allowedExts=process.env.GH_AW_ASSETS_ALLOWED_EXTS?process.env.GH_AW_ASSETS_ALLOWED_EXTS.split(",").map(ext=>ext.trim()):[".png",".jpg",".jpeg"];if(!allowedExts.includes(ext))throw new Error(`File extension '${ext}' is not allowed. Allowed extensions: ${allowedExts.join(", ")}`);const assetsDir="/tmp/gh-aw/safeoutputs/assets";fs.existsSync(assetsDir)||fs.mkdirSync(assetsDir,{recursive:!0});const fileContent=fs.readFileSync(filePath),sha=crypto.createHash("sha256").update(fileContent).digest("hex"),fileName=path.basename(filePath),fileExt=path.extname(fileName).toLowerCase(),targetPath=path.join(assetsDir,fileName);fs.copyFileSync(filePath,targetPath);const targetFileName=(sha+fileExt).toLowerCase(),githubServer=process.env.GITHUB_SERVER_URL||"https://github.com",repo=process.env.GITHUB_REPOSITORY||"owner/repo",url=`${githubServer.replace("github.com","raw.githubusercontent.com")}/${repo}/${normalizedBranchName}/${targetFileName}`;return appendSafeOutput({type:"upload_asset",path:filePath,fileName,sha,size:sizeBytes,url,targetFileName}),{content:[{type:"text",text:JSON.stringify({result:url})}]}},createPullRequestHandler:args=>{const entry={...args,type:"create_pull_request"},baseBranch=getBaseBranch();if(!entry.branch||""===entry.branch.trim()||entry.branch===baseBranch){const detectedBranch=getCurrentBranch();entry.branch===baseBranch?server.debug(`Branch equals base branch (${baseBranch}), detecting actual working branch: ${detectedBranch}`):server.debug(`Using current branch for create_pull_request: ${detectedBranch}`),entry.branch=detectedBranch}if(!0===config.create_pull_request?.allow_empty)return server.debug("allow-empty is enabled for create_pull_request - skipping patch generation"),appendSafeOutput(entry),{content:[{type:"text",text:JSON.stringify({result:"success",message:"Pull request prepared (allow-empty mode - no patch generated)",branch:entry.branch})}]};server.debug(`Generating patch for create_pull_request with branch: ${entry.branch}`);const patchResult=generateGitPatch(entry.branch);if(!patchResult.success){const errorMsg=patchResult.error||"Failed to generate patch";throw server.debug(`Patch generation failed: ${errorMsg}`),new Error(errorMsg)}return server.debug(`Patch generated successfully: ${patchResult.patchPath} (${patchResult.patchSize} bytes, ${patchResult.patchLines} lines)`),appendSafeOutput(entry),{content:[{type:"text",text:JSON.stringify({result:"success",patch:{path:patchResult.patchPath,size:patchResult.patchSize,lines:patchResult.patchLines}})}]}},pushToPullRequestBranchHandler:args=>{const entry={...args,type:"push_to_pull_request_branch"},baseBranch=getBaseBranch();if(!entry.branch||""===entry.branch.trim()||entry.branch===baseBranch){const detectedBranch=getCurrentBranch();entry.branch===baseBranch?server.debug(`Branch equals base branch (${baseBranch}), detecting actual working branch: ${detectedBranch}`):server.debug(`Using current branch for push_to_pull_request_branch: ${detectedBranch}`),entry.branch=detectedBranch}server.debug(`Generating patch for push_to_pull_request_branch with branch: ${entry.branch}`);const patchResult=generateGitPatch(entry.branch);if(!patchResult.success){const errorMsg=patchResult.error||"Failed to generate patch";throw server.debug(`Patch generation failed: ${errorMsg}`),new Error(errorMsg)}return server.debug(`Patch generated successfully: ${patchResult.patchPath} (${patchResult.patchSize} bytes, ${patchResult.patchLines} lines)`),appendSafeOutput(entry),{content:[{type:"text",text:JSON.stringify({result:"success",patch:{path:patchResult.patchPath,size:patchResult.patchSize,lines:patchResult.patchLines}})}]}}}}module.exports={createHandlers};