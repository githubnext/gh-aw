import{describe,it,expect,beforeEach,vi}from"vitest";const mockExistsSync=vi.fn(()=>!1),mockReadFileSync=vi.fn(()=>"");vi.mock("fs",()=>({existsSync:mockExistsSync,readFileSync:mockReadFileSync,default:{existsSync:mockExistsSync,readFileSync:mockReadFileSync}}));const mockCore={info:vi.fn(),warning:vi.fn(),error:vi.fn(),setFailed:vi.fn()};global.core=mockCore,describe("safe_output_validator.cjs",()=>{let validator;beforeEach(async()=>{vi.clearAllMocks(),mockExistsSync.mockReturnValue(!1),mockReadFileSync.mockReturnValue(""),validator=await import("./safe_output_validator.cjs")}),describe.skip("loadSafeOutputsConfig",()=>{it("should load and parse config file",()=>{mockExistsSync.mockReturnValue(!0),mockReadFileSync.mockReturnValue(JSON.stringify({add_labels:{max:5}}));const config=validator.loadSafeOutputsConfig();expect(config).toEqual({add_labels:{max:5}}),expect(mockReadFileSync).toHaveBeenCalledWith("/tmp/gh-aw/safeoutputs/config.json","utf8")}),it("should return empty object if config file does not exist",()=>{mockExistsSync.mockReturnValue(!1);const config=validator.loadSafeOutputsConfig();expect(config).toEqual({}),expect(mockCore.warning).toHaveBeenCalledWith(expect.stringContaining("Config file not found"))}),it("should return empty object on parse error",()=>{mockExistsSync.mockReturnValue(!0),mockReadFileSync.mockReturnValue("invalid json");const config=validator.loadSafeOutputsConfig();expect(config).toEqual({}),expect(mockCore.warning).toHaveBeenCalledWith(expect.stringContaining("Failed to load config"))})}),describe.skip("getSafeOutputConfig",()=>{it("should return config for specific output type",()=>{mockExistsSync.mockReturnValue(!0),mockReadFileSync.mockReturnValue(JSON.stringify({add_labels:{max:5,allowed:["bug","enhancement"]},update_issue:{max:1}}));const config=validator.getSafeOutputConfig("add_labels");expect(config).toEqual({max:5,allowed:["bug","enhancement"]})}),it("should return empty object for unknown output type",()=>{mockExistsSync.mockReturnValue(!0),mockReadFileSync.mockReturnValue(JSON.stringify({add_labels:{max:5}}));const config=validator.getSafeOutputConfig("unknown_type");expect(config).toEqual({})})}),describe("validateTitle",()=>{it("should validate valid title",()=>{const result=validator.validateTitle("  Valid Title  ");expect(result.valid).toBe(!0),expect(result.value).toBe("Valid Title")}),it("should reject undefined title",()=>{const result=validator.validateTitle(void 0);expect(result.valid).toBe(!1),expect(result.error).toContain("required")}),it("should reject non-string title",()=>{const result=validator.validateTitle(123);expect(result.valid).toBe(!1),expect(result.error).toContain("must be a string")}),it("should reject empty title",()=>{const result=validator.validateTitle("   ");expect(result.valid).toBe(!1),expect(result.error).toContain("cannot be empty")}),it("should use custom field name in error messages",()=>{const result=validator.validateTitle(void 0,"name");expect(result.error).toContain("name is required")})}),describe("validateBody",()=>{it("should validate valid body",()=>{const result=validator.validateBody("Some content");expect(result.valid).toBe(!0),expect(result.value).toBe("Some content")}),it("should allow undefined body when not required",()=>{const result=validator.validateBody(void 0,"body",!1);expect(result.valid).toBe(!0),expect(result.value).toBe("")}),it("should reject undefined body when required",()=>{const result=validator.validateBody(void 0,"body",!0);expect(result.valid).toBe(!1),expect(result.error).toContain("required")}),it("should reject non-string body",()=>{const result=validator.validateBody(123);expect(result.valid).toBe(!1),expect(result.error).toContain("must be a string")})}),describe("validateLabels",()=>{it("should validate and sanitize valid labels",()=>{const result=validator.validateLabels(["bug","  enhancement  ","documentation"],void 0,10);expect(result.valid).toBe(!0),expect(result.value).toContain("bug"),expect(result.value).toContain("enhancement"),expect(result.value).toContain("documentation")}),it("should reject labels array with removal attempts",()=>{const result=validator.validateLabels(["-bug","enhancement"],void 0,10);expect(result.valid).toBe(!1),expect(result.error).toContain("Label removal is not permitted")}),it("should filter labels based on allowed list",()=>{const result=validator.validateLabels(["bug","custom","enhancement"],["bug","enhancement"],10);expect(result.valid).toBe(!0),expect(result.value).toHaveLength(2),expect(result.value).toContain("bug"),expect(result.value).toContain("enhancement"),expect(result.value).not.toContain("custom")}),it("should limit labels to max count",()=>{const result=validator.validateLabels(["a","b","c","d","e"],void 0,3);expect(result.valid).toBe(!0),expect(result.value).toHaveLength(3),expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("limiting to 3"))}),it("should deduplicate labels",()=>{const result=validator.validateLabels(["bug","bug","enhancement"],void 0,10);expect(result.valid).toBe(!0),expect(result.value).toHaveLength(2)}),it("should truncate labels longer than 64 characters",()=>{const longLabel="a".repeat(100),result=validator.validateLabels([longLabel],void 0,10);expect(result.valid).toBe(!0),expect(result.value[0]).toHaveLength(64)}),it("should reject non-array labels",()=>{const result=validator.validateLabels("bug",void 0,10);expect(result.valid).toBe(!1),expect(result.error).toContain("must be an array")}),it("should reject when no valid labels remain",()=>{const result=validator.validateLabels([null,void 0,!1,0],void 0,10);expect(result.valid).toBe(!1),expect(result.error).toContain("No valid labels found")})}),describe("validateMaxCount",()=>{it("should use fallback default when no config or env",()=>{const result=validator.validateMaxCount(void 0,void 0);expect(result.valid).toBe(!0),expect(result.value).toBe(1)}),it("should use config default when provided",()=>{const result=validator.validateMaxCount(void 0,5);expect(result.valid).toBe(!0),expect(result.value).toBe(5)}),it("should prefer env value over config",()=>{const result=validator.validateMaxCount("7",5);expect(result.valid).toBe(!0),expect(result.value).toBe(7)}),it("should use custom fallback when provided",()=>{const result=validator.validateMaxCount(void 0,void 0,10);expect(result.valid).toBe(!0),expect(result.value).toBe(10)}),it("should reject invalid env value",()=>{const result=validator.validateMaxCount("invalid",5);expect(result.valid).toBe(!1),expect(result.error).toContain("Invalid max value")}),it("should reject negative env value",()=>{const result=validator.validateMaxCount("-1",5);expect(result.valid).toBe(!1),expect(result.error).toContain("Invalid max value")}),it("should reject zero env value",()=>{const result=validator.validateMaxCount("0",5);expect(result.valid).toBe(!1),expect(result.error).toContain("Invalid max value")})})});