const fs=require("fs"),path=require("path"),{ReadBuffer}=require("./read_buffer.cjs"),{validateRequiredFields}=require("./safe_inputs_validation.cjs"),encoder=new TextEncoder;function initLogFile(server){if(!server.logFileInitialized&&server.logDir&&server.logFilePath)try{fs.existsSync(server.logDir)||fs.mkdirSync(server.logDir,{recursive:!0});const timestamp=(new Date).toISOString();fs.writeFileSync(server.logFilePath,`# ${server.serverInfo.name} MCP Server Log\n# Started: ${timestamp}\n# Version: ${server.serverInfo.version}\n\n`),server.logFileInitialized=!0}catch{}}function createDebugFunction(server){return msg=>{const formattedMsg=`[${(new Date).toISOString()}] [${server.serverInfo.name}] ${msg}\n`;if(process.stderr.write(formattedMsg),server.logDir&&server.logFilePath&&(server.logFileInitialized||initLogFile(server),server.logFileInitialized))try{fs.appendFileSync(server.logFilePath,formattedMsg)}catch{}}}function createDebugErrorFunction(server){return(prefix,error)=>{const errorMessage=error instanceof Error?error.message:String(error);server.debug(`${prefix}${errorMessage}`),error instanceof Error&&error.stack&&server.debug(`${prefix}Stack trace: ${error.stack}`)}}function createWriteMessageFunction(server){return obj=>{const json=JSON.stringify(obj);server.debug(`send: ${json}`);const message=json+"\n",bytes=encoder.encode(message);fs.writeSync(1,bytes)}}function createReplyResultFunction(server){return(id,result)=>{if(null==id)return;const res={jsonrpc:"2.0",id,result};server.writeMessage(res)}}function createReplyErrorFunction(server){return(id,code,message)=>{if(null==id)return void server.debug(`Error for notification: ${message}`);const res={jsonrpc:"2.0",id,error:{code,message}};server.writeMessage(res)}}function createServer(serverInfo,options={}){const logDir=options.logDir||void 0,logFilePath=logDir?path.join(logDir,"server.log"):void 0,server={serverInfo,tools:{},debug:()=>{},debugError:()=>{},writeMessage:()=>{},replyResult:()=>{},replyError:()=>{},readBuffer:new ReadBuffer,logDir,logFilePath,logFileInitialized:!1};return server.debug=createDebugFunction(server),server.debugError=createDebugErrorFunction(server),server.writeMessage=createWriteMessageFunction(server),server.replyResult=createReplyResultFunction(server),server.replyError=createReplyErrorFunction(server),server}function createWrappedHandler(server,toolName,handlerFn){return async args=>{server.debug(`  [${toolName}] Invoking handler with args: ${JSON.stringify(args)}`);try{const result=await Promise.resolve(handlerFn(args));if(server.debug(`  [${toolName}] Handler returned result type: ${typeof result}`),result&&"object"==typeof result&&Array.isArray(result.content))return server.debug(`  [${toolName}] Result is already in MCP format`),result;let serializedResult;try{serializedResult=JSON.stringify(result)}catch(serializationError){server.debugError(`  [${toolName}] Serialization error: `,serializationError),serializedResult=String(result)}return server.debug(`  [${toolName}] Serialized result: ${serializedResult.substring(0,200)}${serializedResult.length>200?"...":""}`),{content:[{type:"text",text:serializedResult}]}}catch(error){throw server.debugError(`  [${toolName}] Handler threw error: `,error),error}}}function loadToolHandlers(server,tools,basePath){server.debug("Loading tool handlers..."),server.debug(`  Total tools to process: ${tools.length}`),server.debug(`  Base path: ${basePath||"(not specified)"}`);let loadedCount=0,skippedCount=0,errorCount=0;for(const tool of tools){const toolName=tool.name||"(unnamed)";if(!tool.handler){server.debug(`  [${toolName}] No handler path specified, skipping handler load`),skippedCount++;continue}const handlerPath=tool.handler;server.debug(`  [${toolName}] Handler path specified: ${handlerPath}`);let resolvedPath=handlerPath;if(basePath&&!path.isAbsolute(handlerPath)){resolvedPath=path.resolve(basePath,handlerPath),server.debug(`  [${toolName}] Resolved relative path to: ${resolvedPath}`);const normalizedBase=path.resolve(basePath),normalizedResolved=path.resolve(resolvedPath);if(!normalizedResolved.startsWith(normalizedBase+path.sep)&&normalizedResolved!==normalizedBase){server.debug(`  [${toolName}] ERROR: Handler path escapes base directory: ${resolvedPath} is not within ${basePath}`),errorCount++;continue}}else path.isAbsolute(handlerPath)&&server.debug(`  [${toolName}] Using absolute path (bypasses basePath validation): ${handlerPath}`);tool.handlerPath=handlerPath;try{if(server.debug(`  [${toolName}] Loading handler from: ${resolvedPath}`),!fs.existsSync(resolvedPath)){server.debug(`  [${toolName}] ERROR: Handler file does not exist: ${resolvedPath}`),errorCount++;continue}const ext=path.extname(resolvedPath).toLowerCase();if(server.debug(`  [${toolName}] Handler file extension: ${ext}`),".sh"===ext){server.debug(`  [${toolName}] Detected shell script handler`);try{fs.accessSync(resolvedPath,fs.constants.X_OK),server.debug(`  [${toolName}] Shell script is executable`)}catch{try{fs.chmodSync(resolvedPath,493),server.debug(`  [${toolName}] Made shell script executable`)}catch(chmodError){server.debugError(`  [${toolName}] Warning: Could not make shell script executable: `,chmodError)}}const{createShellHandler}=require("./mcp_handler_shell.cjs"),timeout=tool.timeout||60;tool.handler=createShellHandler(server,toolName,resolvedPath,timeout),loadedCount++,server.debug(`  [${toolName}] Shell handler created successfully with timeout: ${timeout}s`)}else if(".py"===ext){server.debug(`  [${toolName}] Detected Python script handler`);try{fs.accessSync(resolvedPath,fs.constants.X_OK),server.debug(`  [${toolName}] Python script is executable`)}catch{try{fs.chmodSync(resolvedPath,493),server.debug(`  [${toolName}] Made Python script executable`)}catch(chmodError){server.debugError(`  [${toolName}] Warning: Could not make Python script executable: `,chmodError)}}const{createPythonHandler}=require("./mcp_handler_python.cjs"),timeout=tool.timeout||60;tool.handler=createPythonHandler(server,toolName,resolvedPath,timeout),loadedCount++,server.debug(`  [${toolName}] Python handler created successfully with timeout: ${timeout}s`)}else{server.debug(`  [${toolName}] Loading JavaScript handler module`);const handlerModule=require(resolvedPath);server.debug(`  [${toolName}] Handler module loaded successfully`),server.debug(`  [${toolName}] Module type: ${typeof handlerModule}`);let handlerFn=handlerModule;if(handlerModule&&"object"==typeof handlerModule&&"function"==typeof handlerModule.default&&(handlerFn=handlerModule.default,server.debug(`  [${toolName}] Using module.default export`)),"function"!=typeof handlerFn){server.debug(`  [${toolName}] ERROR: Handler is not a function, got: ${typeof handlerFn}`),server.debug(`  [${toolName}] Module keys: ${Object.keys(handlerModule||{}).join(", ")||"(none)"}`),errorCount++;continue}server.debug(`  [${toolName}] Handler function validated successfully`),server.debug(`  [${toolName}] Handler function name: ${handlerFn.name||"(anonymous)"}`),tool.handler=createWrappedHandler(server,toolName,handlerFn),loadedCount++,server.debug(`  [${toolName}] JavaScript handler loaded and wrapped successfully`)}}catch(error){server.debugError(`  [${toolName}] ERROR loading handler: `,error),errorCount++}}return server.debug("Handler loading complete:"),server.debug(`  Loaded: ${loadedCount}`),server.debug(`  Skipped (no handler path): ${skippedCount}`),server.debug(`  Errors: ${errorCount}`),tools}function registerTool(server,tool){const normalizedName=normalizeTool(tool.name);server.tools[normalizedName]={...tool,name:normalizedName},server.debug(`Registered tool: ${normalizedName}`)}function normalizeTool(name){return name.replace(/-/g,"_").toLowerCase()}async function handleRequest(server,request,defaultHandler){const{id,method,params}=request;try{if(!("id"in request))return null;let result;if("initialize"===method)result={protocolVersion:params?.protocolVersion||"2024-11-05",serverInfo:server.serverInfo,capabilities:{tools:{}}};else if("ping"===method)result={};else if("tools/list"===method){const list=[];Object.values(server.tools).forEach(tool=>{const toolDef={name:tool.name,description:tool.description,inputSchema:tool.inputSchema};list.push(toolDef)}),result={tools:list}}else{if("tools/call"!==method){if(/^notifications\//.test(method))return null;throw{code:-32601,message:`Method not found: ${method}`}}{const name=params?.name,args=params?.arguments??{};if(!name||"string"!=typeof name)throw{code:-32602,message:"Invalid params: 'name' must be a string"};const tool=server.tools[normalizeTool(name)];if(!tool)throw{code:-32602,message:`Tool '${name}' not found`};let handler=tool.handler;if(!handler&&defaultHandler&&(handler=defaultHandler(tool.name)),!handler)throw{code:-32603,message:`No handler for tool: ${name}`};const missing=validateRequiredFields(args,tool.inputSchema);if(missing.length)throw{code:-32602,message:`Invalid arguments: missing or empty ${missing.map(m=>`'${m}'`).join(", ")}`};const handlerResult=await Promise.resolve(handler(args));result={content:handlerResult&&handlerResult.content?handlerResult.content:[],isError:!1}}}return{jsonrpc:"2.0",id,result}}catch(error){const err=error;return{jsonrpc:"2.0",id,error:{code:err.code||-32603,message:err.message||"Internal error"}}}}async function handleMessage(server,req,defaultHandler){if(!req||"object"!=typeof req)return void server.debug("Invalid message: not an object");if("2.0"!==req.jsonrpc)return void server.debug("Invalid message: missing or invalid jsonrpc field");const{id,method,params}=req;if(method&&"string"==typeof method)try{if("initialize"===method){const clientInfo=params?.clientInfo??{};server.debug(`client info: ${JSON.stringify(clientInfo)}`);const protocolVersion=params?.protocolVersion??void 0,result={serverInfo:server.serverInfo,...protocolVersion?{protocolVersion}:{},capabilities:{tools:{}}};server.replyResult(id,result)}else if("tools/list"===method){const list=[];Object.values(server.tools).forEach(tool=>{const toolDef={name:tool.name,description:tool.description,inputSchema:tool.inputSchema};list.push(toolDef)}),server.replyResult(id,{tools:list})}else if("tools/call"===method){const name=params?.name,args=params?.arguments??{};if(!name||"string"!=typeof name)return void server.replyError(id,-32602,"Invalid params: 'name' must be a string");const tool=server.tools[normalizeTool(name)];if(!tool)return void server.replyError(id,-32601,`Tool not found: ${name} (${normalizeTool(name)})`);let handler=tool.handler;if(!handler&&defaultHandler&&(handler=defaultHandler(tool.name)),!handler)return void server.replyError(id,-32603,`No handler for tool: ${name}`);const missing=validateRequiredFields(args,tool.inputSchema);if(missing.length)return void server.replyError(id,-32602,`Invalid arguments: missing or empty ${missing.map(m=>`'${m}'`).join(", ")}`);server.debug(`Calling handler for tool: ${name}`);const result=await Promise.resolve(handler(args));server.debug(`Handler returned for tool: ${name}`);const content=result&&result.content?result.content:[];server.replyResult(id,{content,isError:!1})}else/^notifications\//.test(method)?server.debug(`ignore ${method}`):server.replyError(id,-32601,`Method not found: ${method}`)}catch(e){server.replyError(id,-32603,e instanceof Error?e.message:String(e))}else server.replyError(id,-32600,"Invalid Request: method must be a string")}async function processReadBuffer(server,defaultHandler){for(;;)try{const message=server.readBuffer.readMessage();if(!message)break;server.debug(`recv: ${JSON.stringify(message)}`),await handleMessage(server,message,defaultHandler)}catch(error){server.debug(`Parse error: ${error instanceof Error?error.message:String(error)}`)}}function start(server,options={}){const{defaultHandler}=options;if(server.debug(`v${server.serverInfo.version} ready on stdio`),server.debug(`  tools: ${Object.keys(server.tools).join(", ")}`),!Object.keys(server.tools).length)throw new Error("No tools registered");process.stdin.on("data",async chunk=>{server.readBuffer.append(chunk),await processReadBuffer(server,defaultHandler)}),process.stdin.on("error",err=>server.debug(`stdin error: ${err}`)),process.stdin.resume(),server.debug("listening...")}module.exports={createServer,registerTool,normalizeTool,handleRequest,handleMessage,processReadBuffer,start,loadToolHandlers};