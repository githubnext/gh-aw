function sanitizeLabelContent(content) {
  if (!content || typeof content !== "string") {
    return "";
  }
  let sanitized = content.trim();
  sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
  sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
  sanitized = sanitized.replace(
    /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
    (_m, p1, p2) => `${p1}\`@${p2}\``
  );
  sanitized = sanitized.replace(/[<>&'"]/g, "");
  return sanitized.trim();
}

/**
 * Generate footer with AI attribution and workflow installation instructions
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)
 * @param {string} workflowSourceURL - GitHub URL for the workflow source
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow
 * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow
 * @returns {string} Footer text
 */
function generateFooter(
  workflowName,
  runUrl,
  workflowSource,
  workflowSourceURL,
  triggeringIssueNumber,
  triggeringPRNumber,
  triggeringDiscussionNumber
) {
  let footer = `\n\n> AI generated by [${workflowName}](${runUrl})`;

  // Add reference to triggering issue/PR/discussion if available
  if (triggeringIssueNumber) {
    footer += ` for #${triggeringIssueNumber}`;
  } else if (triggeringPRNumber) {
    footer += ` for #${triggeringPRNumber}`;
  } else if (triggeringDiscussionNumber) {
    footer += ` for discussion #${triggeringDiscussionNumber}`;
  }

  if (workflowSource && workflowSourceURL) {
    footer += `\n>\n> To add this workflow in your repository, run \`gh aw add ${workflowSource}\`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).`;
  }

  footer += "\n";
  return footer;
}

async function main() {
  const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
  const agentOutputFile = process.env.GITHUB_AW_AGENT_OUTPUT;
  if (!agentOutputFile) {
    core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
    return;
  }

  // Read agent output from file
  let outputContent;
  try {
    outputContent = require("fs").readFileSync(agentOutputFile, "utf8");
  } catch (error) {
    core.setFailed(`Error reading agent output file: ${error instanceof Error ? error.message : String(error)}`);
    return;
  }

  if (outputContent.trim() === "") {
    core.info("Agent output content is empty");
    return;
  }
  core.info(`Agent output content length: ${outputContent.length}`);
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
    return;
  }
  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    core.info("No valid items found in agent output");
    return;
  }
  const createIssueItems = validatedOutput.items.filter(item => item.type === "create_issue");
  if (createIssueItems.length === 0) {
    core.info("No create-issue items found in agent output");
    return;
  }
  core.info(`Found ${createIssueItems.length} create-issue item(s)`);
  if (isStaged) {
    let summaryContent = "## 🎭 Staged Mode: Create Issues Preview\n\n";
    summaryContent += "The following issues would be created if staged mode was disabled:\n\n";
    for (let i = 0; i < createIssueItems.length; i++) {
      const item = createIssueItems[i];
      summaryContent += `### Issue ${i + 1}\n`;
      summaryContent += `**Title:** ${item.title || "No title provided"}\n\n`;
      if (item.body) {
        summaryContent += `**Body:**\n${item.body}\n\n`;
      }
      if (item.labels && item.labels.length > 0) {
        summaryContent += `**Labels:** ${item.labels.join(", ")}\n\n`;
      }
      summaryContent += "---\n\n";
    }
    await core.summary.addRaw(summaryContent).write();
    core.info("📝 Issue creation preview written to step summary");
    return;
  }
  const parentIssueNumber = context.payload?.issue?.number;

  // Extract triggering context for footer generation
  const triggeringIssueNumber =
    context.payload?.issue?.number && !context.payload?.issue?.pull_request ? context.payload.issue.number : undefined;
  const triggeringPRNumber =
    context.payload?.pull_request?.number || (context.payload?.issue?.pull_request ? context.payload.issue.number : undefined);
  const triggeringDiscussionNumber = context.payload?.discussion?.number;

  const labelsEnv = process.env.GITHUB_AW_ISSUE_LABELS;
  let envLabels = labelsEnv
    ? labelsEnv
        .split(",")
        .map(label => label.trim())
        .filter(label => label)
    : [];
  const createdIssues = [];
  for (let i = 0; i < createIssueItems.length; i++) {
    const createIssueItem = createIssueItems[i];
    core.info(
      `Processing create-issue item ${i + 1}/${createIssueItems.length}: title=${createIssueItem.title}, bodyLength=${createIssueItem.body.length}`
    );
    // Use the parent field from the item if provided, otherwise fall back to context
    const effectiveParentIssueNumber = createIssueItem.parent !== undefined ? createIssueItem.parent : parentIssueNumber;
    if (effectiveParentIssueNumber && createIssueItem.parent !== undefined) {
      core.info(`Using explicit parent issue number from item: #${effectiveParentIssueNumber}`);
    }
    let labels = [...envLabels];
    if (createIssueItem.labels && Array.isArray(createIssueItem.labels)) {
      labels = [...labels, ...createIssueItem.labels];
    }
    labels = labels
      .filter(label => !!label)
      .map(label => String(label).trim())
      .filter(label => label)
      .map(label => sanitizeLabelContent(label))
      .filter(label => label)
      .map(label => (label.length > 64 ? label.substring(0, 64) : label))
      .filter((label, index, arr) => arr.indexOf(label) === index);
    let title = createIssueItem.title ? createIssueItem.title.trim() : "";
    let bodyLines = createIssueItem.body.split("\n");
    if (!title) {
      title = createIssueItem.body || "Agent Output";
    }
    const titlePrefix = process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;
    if (titlePrefix && !title.startsWith(titlePrefix)) {
      title = titlePrefix + title;
    }
    if (effectiveParentIssueNumber) {
      core.info("Detected issue context, parent issue #" + effectiveParentIssueNumber);
      bodyLines.push(`Related to #${effectiveParentIssueNumber}`);
    }
    const workflowName = process.env.GITHUB_AW_WORKFLOW_NAME || "Workflow";
    const workflowSource = process.env.GITHUB_AW_WORKFLOW_SOURCE || "";
    const workflowSourceURL = process.env.GITHUB_AW_WORKFLOW_SOURCE_URL || "";
    const runId = context.runId;
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    const runUrl = context.payload.repository
      ? `${context.payload.repository.html_url}/actions/runs/${runId}`
      : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
    bodyLines.push(
      ``,
      ``,
      generateFooter(
        workflowName,
        runUrl,
        workflowSource,
        workflowSourceURL,
        triggeringIssueNumber,
        triggeringPRNumber,
        triggeringDiscussionNumber
      ).trimEnd(),
      ""
    );
    const body = bodyLines.join("\n").trim();
    core.info(`Creating issue with title: ${title}`);
    core.info(`Labels: ${labels}`);
    core.info(`Body length: ${body.length}`);
    try {
      // Check if we need to assign to a bot
      let assignToBot = process.env.GITHUB_AW_ISSUE_ASSIGN_TO_BOT;
      let issue;

      if (assignToBot) {
        // Normalize copilot name: "copilot" or "Copilot" -> "copilot-swe-agent"
        const originalBotName = assignToBot;
        if (assignToBot.toLowerCase() === "copilot") {
          assignToBot = "copilot-swe-agent";
          core.info(`Normalized bot name from "${originalBotName}" to "${assignToBot}"`);
        }

        try {
          // Get repository node ID
          core.info(`Fetching repository node ID`);
          const repoNodeIdQuery = `
            query($owner: String!, $repo: String!) {
              repository(owner: $owner, name: $repo) {
                id
              }
            }
          `;
          const repoResult = await github.graphql(repoNodeIdQuery, {
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          // @ts-ignore - graphql result type
          const repositoryId = repoResult.repository.id;
          core.info(`Repository node ID: ${repositoryId}`);

          // Get the bot user node ID
          core.info(`Fetching node ID for bot user: ${assignToBot}`);
          const botNodeIdQuery = `
            query($owner: String!, $repo: String!) {
              repository(owner: $owner, name: $repo) {
                suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                  nodes {
                    login
                    ... on User { id }
                    ... on Bot { id }
                  }
                }
              }
            }          
          `;
          const botResult = await github.graphql(botNodeIdQuery, {
            owner: context.repo.owner,
            repo: context.repo.repo,
            login: assignToBot,
          });
          core.info(JSON.stringify(botResult));
          // @ts-ignore - graphql result type
          const botNodeId = botResult.id;
          core.info(`Bot user node ID: ${botNodeId}`);

          // Create issue with bot assigned in one mutation
          core.info(`Creating issue and assigning to ${assignToBot} in one operation`);
          const createIssueMutation = `
            mutation($repositoryId: ID!, $title: String!, $body: String, $assigneeIds: [ID!]) {
              createIssue(input: {
                repositoryId: $repositoryId,
                title: $title,
                body: $body,
                assigneeIds: $assigneeIds
              }) {
                issue {
                  id
                  number
                  title
                  url
                  assignees(first: 10) {
                    nodes {
                      login
                    }
                  }
                }
              }
            }
          `;
          core.info(createIssueMutation)

          const createResult = await github.graphql(createIssueMutation, {
            repositoryId: repositoryId,
            title: title,
            body: body,
            assigneeIds: [botNodeId],
          });
          
          core.info(JSON.stringify(createResult))
          // @ts-ignore - graphql result type
          const createdIssue = createResult.createIssue.issue;
          
          // Convert GraphQL result to REST API format for consistency
          issue = {
            number: createdIssue.number,
            title: createdIssue.title,
            html_url: createdIssue.url,
            id: createdIssue.id,
          };

          core.info(`Created issue #${issue.number}: ${issue.html_url}`);

          // Validate assignment
          if (createdIssue.assignees && createdIssue.assignees.nodes) {
            const assignees = createdIssue.assignees.nodes;
            // @ts-ignore - assignee type
            const assignedLogins = assignees.map(a => a.login).join(", ");
            core.info(`Issue #${issue.number} assignees: ${assignedLogins}`);
            
            // @ts-ignore - assignee type
            const botAssigned = assignees.some(a => a.login === assignToBot);
            if (botAssigned) {
              core.info(`✓ Successfully created and assigned issue #${issue.number} to ${assignToBot}`);
            } else {
              core.warning(`Issue created but ${assignToBot} not found in assignees list. Current assignees: ${assignedLogins}`);
            }
          }

          // Add labels if specified (done separately as GraphQL createIssue doesn't support labels)
          if (labels && labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels,
            });
            core.info(`Added labels to issue #${issue.number}: ${labels.join(", ")}`);
          }
        } catch (error) {
          core.warning(
            `Failed to create issue with bot assignment: ${error instanceof Error ? error.message : String(error)}`
          );
          core.info(`Falling back to REST API issue creation`);
          
          // Fallback to REST API if GraphQL fails
          const { data: fallbackIssue } = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: title,
            body: body,
            labels: labels,
          });
          issue = fallbackIssue;
          core.info("Created issue (without assignment) #" + issue.number + ": " + issue.html_url);
        }
      } else {
        // No bot assignment requested, use REST API
        const { data: restIssue } = await github.rest.issues.create({
          owner: context.repo.owner,
          repo: context.repo.repo,
          title: title,
          body: body,
          labels: labels,
        });
        issue = restIssue;
        core.info("Created issue #" + issue.number + ": " + issue.html_url);
      }

      createdIssues.push(issue);

      if (effectiveParentIssueNumber) {
        try {
          // First, get the node IDs for both parent and child issues
          const getIssueNodeIdQuery = `
            query($owner: String!, $repo: String!, $issueNumber: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $issueNumber) {
                  id
                }
              }
            }
          `;

          // Get parent issue node ID
          const parentResult = await github.graphql(getIssueNodeIdQuery, {
            owner: context.repo.owner,
            repo: context.repo.repo,
            issueNumber: effectiveParentIssueNumber,
          });
          const parentNodeId = parentResult.repository.issue.id;

          // Get child issue node ID
          const childResult = await github.graphql(getIssueNodeIdQuery, {
            owner: context.repo.owner,
            repo: context.repo.repo,
            issueNumber: issue.number,
          });
          const childNodeId = childResult.repository.issue.id;

          // Link the child issue as a sub-issue of the parent
          const addSubIssueMutation = `
            mutation($parentId: ID!, $subIssueId: ID!) {
              addSubIssue(input: {
                parentId: $parentId,
                subIssueId: $subIssueId
              }) {
                subIssue {
                  id
                  number
                }
              }
            }
          `;

          await github.graphql(addSubIssueMutation, {
            parentId: parentNodeId,
            subIssueId: childNodeId,
          });

          core.info("Linked issue #" + issue.number + " as sub-issue of #" + effectiveParentIssueNumber);
        } catch (error) {
          core.info(`Warning: Could not link sub-issue to parent: ${error instanceof Error ? error.message : String(error)}`);
          // Fallback: add a comment if sub-issue linking fails
          try {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: effectiveParentIssueNumber,
              body: `Created related issue: #${issue.number}`,
            });
            core.info("Added comment to parent issue #" + effectiveParentIssueNumber + " (sub-issue linking not available)");
          } catch (commentError) {
            core.info(
              `Warning: Could not add comment to parent issue: ${commentError instanceof Error ? commentError.message : String(commentError)}`
            );
          }
        }
      }
      if (i === createIssueItems.length - 1) {
        core.setOutput("issue_number", issue.number);
        core.setOutput("issue_url", issue.html_url);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("Issues has been disabled in this repository")) {
        core.info(`⚠ Cannot create issue "${title}": Issues are disabled for this repository`);
        core.info("Consider enabling issues in repository settings if you want to create issues automatically");
        continue;
      }
      core.error(`✗ Failed to create issue "${title}": ${errorMessage}`);
      throw error;
    }
  }
  if (createdIssues.length > 0) {
    let summaryContent = "\n\n## GitHub Issues\n";
    for (const issue of createdIssues) {
      summaryContent += `- Issue #${issue.number}: [${issue.title}](${issue.html_url})\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }
  core.info(`Successfully created ${createdIssues.length} issue(s)`);
}
(async () => {
  await main();
})();
