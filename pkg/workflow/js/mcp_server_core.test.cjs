import{describe,it,expect,beforeEach,vi}from"vitest";import{Readable,Writable}from"stream";let mockStdinData=[],mockStdoutData=[];describe("mcp_server_core.cjs",()=>{beforeEach(()=>{vi.resetModules(),mockStdinData=[],mockStdoutData=[],delete process.env.GH_AW_MCP_LOG_DIR}),describe("createServer",()=>{it("should create a server with the given info",async()=>{const{createServer}=await import("./mcp_server_core.cjs"),server=createServer({name:"test-server",version:"1.0.0"});expect(server.serverInfo).toEqual({name:"test-server",version:"1.0.0"}),expect(server.tools).toEqual({}),expect(typeof server.debug).toBe("function"),expect(typeof server.writeMessage).toBe("function"),expect(typeof server.replyResult).toBe("function"),expect(typeof server.replyError).toBe("function")}),it("should accept log directory option",async()=>{const{createServer}=await import("./mcp_server_core.cjs"),server=createServer({name:"test-server",version:"1.0.0"},{logDir:"/tmp/test-logs"});expect(server.logDir).toBe("/tmp/test-logs"),expect(server.logFilePath).toBe("/tmp/test-logs/server.log")})}),describe("registerTool",()=>{it("should register a tool with the server",async()=>{const{createServer,registerTool}=await import("./mcp_server_core.cjs"),server=createServer({name:"test-server",version:"1.0.0"});registerTool(server,{name:"test_tool",description:"A test tool",inputSchema:{type:"object",properties:{}},handler:()=>({content:[{type:"text",text:"ok"}]})}),expect(server.tools.test_tool).toBeDefined(),expect(server.tools.test_tool.name).toBe("test_tool"),expect(server.tools.test_tool.description).toBe("A test tool")}),it("should normalize tool names with dashes to underscores",async()=>{const{createServer,registerTool}=await import("./mcp_server_core.cjs"),server=createServer({name:"test-server",version:"1.0.0"});registerTool(server,{name:"test-tool",description:"A test tool",inputSchema:{type:"object",properties:{}}}),expect(server.tools.test_tool).toBeDefined(),expect(server.tools.test_tool.name).toBe("test_tool")}),it("should normalize tool names to lowercase",async()=>{const{createServer,registerTool}=await import("./mcp_server_core.cjs"),server=createServer({name:"test-server",version:"1.0.0"});registerTool(server,{name:"Test-Tool",description:"A test tool",inputSchema:{type:"object",properties:{}}}),expect(server.tools.test_tool).toBeDefined()})}),describe("normalizeTool",()=>{it("should normalize tool names",async()=>{const{normalizeTool}=await import("./mcp_server_core.cjs");expect(normalizeTool("test-tool")).toBe("test_tool"),expect(normalizeTool("Test-Tool")).toBe("test_tool"),expect(normalizeTool("create_issue")).toBe("create_issue"),expect(normalizeTool("CREATE-ISSUE")).toBe("create_issue")}),it("should handle empty string input",async()=>{const{normalizeTool}=await import("./mcp_server_core.cjs");expect(normalizeTool("")).toBe("")})}),describe("handleMessage",()=>{let server,results=[];beforeEach(async()=>{vi.resetModules(),results=[],vi.spyOn(process.stderr,"write").mockImplementation(()=>!0);const{createServer,registerTool}=await import("./mcp_server_core.cjs");server=createServer({name:"test-server",version:"1.0.0"}),server.writeMessage=msg=>{results.push(msg)},server.replyResult=(id,result)=>{null!=id&&results.push({jsonrpc:"2.0",id,result})},server.replyError=(id,code,message)=>{null!=id&&results.push({jsonrpc:"2.0",id,error:{code,message}})},registerTool(server,{name:"test_tool",description:"A test tool",inputSchema:{type:"object",properties:{input:{type:"string"}},required:["input"]},handler:args=>({content:[{type:"text",text:`received: ${args.input}`}]})})}),it("should handle initialize method",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",id:1,method:"initialize",params:{protocolVersion:"2024-11-05"}}),expect(results).toHaveLength(1),expect(results[0].result.serverInfo).toEqual({name:"test-server",version:"1.0.0"}),expect(results[0].result.protocolVersion).toBe("2024-11-05"),expect(results[0].result.capabilities).toEqual({tools:{}})}),it("should handle tools/list method",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/list"}),expect(results).toHaveLength(1),expect(results[0].result.tools).toHaveLength(1),expect(results[0].result.tools[0].name).toBe("test_tool")}),it("should handle tools/call method with handler",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_tool",arguments:{input:"hello"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toBe("received: hello"),expect(results[0].result.isError).toBe(!1)}),it("should return error for unknown tool",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"unknown_tool",arguments:{}}}),expect(results).toHaveLength(1),expect(results[0].error.code).toBe(-32601),expect(results[0].error.message).toContain("Tool not found")}),it("should return error for missing required fields",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_tool",arguments:{}}}),expect(results).toHaveLength(1),expect(results[0].error.code).toBe(-32602),expect(results[0].error.message).toContain("missing or empty")}),it("should return error for unknown method",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",id:1,method:"unknown/method"}),expect(results).toHaveLength(1),expect(results[0].error.code).toBe(-32601),expect(results[0].error.message).toContain("Method not found")}),it("should ignore notifications (no response)",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"2.0",method:"notifications/initialized"}),expect(results).toHaveLength(0)}),it("should validate JSON-RPC version",async()=>{const{handleMessage}=await import("./mcp_server_core.cjs");await handleMessage(server,{jsonrpc:"1.0",id:1,method:"test"}),expect(results).toHaveLength(0)}),it("should use default handler when tool has no handler",async()=>{const{handleMessage,registerTool}=await import("./mcp_server_core.cjs");registerTool(server,{name:"no_handler_tool",description:"A tool without handler",inputSchema:{type:"object",properties:{}}});await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"no_handler_tool",arguments:{}}},type=>args=>({content:[{type:"text",text:`default handler for ${type}`}]})),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toBe("default handler for no_handler_tool")})}),describe("loadToolHandlers",()=>{let server;const fs=require("fs"),path=require("path"),os=require("os");let tempDir;beforeEach(async()=>{vi.resetModules(),vi.spyOn(process.stderr,"write").mockImplementation(()=>!0);const{createServer}=await import("./mcp_server_core.cjs");server=createServer({name:"test-server",version:"1.0.0"}),tempDir=fs.mkdtempSync(path.join(os.tmpdir(),"mcp-test-handlers-"))}),afterEach(()=>{tempDir&&fs.existsSync(tempDir)&&fs.rmSync(tempDir,{recursive:!0})}),it("should load a sync handler from file path",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"sync_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = function(args) {\n          return { result: "sync result: " + args.input };\n        };');const tools=[{name:"test_sync_tool",description:"A tool with sync handler",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),expect(typeof tools[0].handler).toBe("function"),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_sync_tool",arguments:{input:"hello"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toContain("sync result: hello")}),it("should load an async handler from file path",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"async_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = async function(args) {\n          await new Promise(resolve => setTimeout(resolve, 10));\n          return { result: "async result: " + args.input };\n        };');const tools=[{name:"test_async_tool",description:"A tool with async handler",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),expect(typeof tools[0].handler).toBe("function"),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_async_tool",arguments:{input:"world"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toContain("async result: world")}),it("should handle handler that returns MCP format directly",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"mcp_format_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = function(args) {\n          return {\n            content: [{ type: "text", text: "MCP format: " + args.input }]\n          };\n        };');const tools=[{name:"test_mcp_format",description:"A tool returning MCP format",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_mcp_format",arguments:{input:"test"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toBe("MCP format: test")}),it("should handle handler with module.default export pattern",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"default_export_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = {\n          default: function(args) {\n            return { result: "default export: " + args.input };\n          }\n        };');const tools=[{name:"test_default_export",description:"A tool with default export",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_default_export",arguments:{input:"hi"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toContain("default export: hi")}),it("should skip tools without handler path",async()=>{const{loadToolHandlers}=await import("./mcp_server_core.cjs"),tools=[{name:"tool_without_handler",description:"A tool without handler path",inputSchema:{type:"object",properties:{}}}],result=loadToolHandlers(server,tools,tempDir);expect(tools[0].handler).toBeUndefined(),expect(result).toBe(tools)}),it("should handle non-existent handler file",async()=>{const{loadToolHandlers}=await import("./mcp_server_core.cjs"),tools=[{name:"tool_with_missing_handler",description:"A tool with missing handler file",inputSchema:{type:"object",properties:{}},handler:"/non/existent/handler.cjs"}];loadToolHandlers(server,tools,tempDir),expect(tools[0].handler).toBe("/non/existent/handler.cjs")}),it("should handle handler that is not a function",async()=>{const{loadToolHandlers}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"not_a_function.cjs");fs.writeFileSync(handlerPath,"module.exports = { notAFunction: true };");const tools=[{name:"tool_with_invalid_handler",description:"A tool with invalid handler",inputSchema:{type:"object",properties:{}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),expect(tools[0].handler).toBe(handlerPath)}),it("should handle handler that throws error",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"error_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = function(args) {\n          throw new Error("Handler error: " + args.input);\n        };');const tools=[{name:"test_error_handler",description:"A tool that throws",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_error_handler",arguments:{input:"oops"}}}),expect(results).toHaveLength(1),expect(results[0].error.code).toBe(-32603),expect(results[0].error.message).toContain("Handler error: oops")}),it("should resolve relative paths from basePath",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),subDir=path.join(tempDir,"handlers");fs.mkdirSync(subDir,{recursive:!0});const handlerPath=path.join(subDir,"relative_handler.cjs");fs.writeFileSync(handlerPath,'module.exports = function(args) {\n          return { result: "relative: " + args.input };\n        };');const tools=[{name:"test_relative_path",description:"A tool with relative handler path",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:"handlers/relative_handler.cjs"}];loadToolHandlers(server,tools,tempDir),expect(typeof tools[0].handler).toBe("function"),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_relative_path",arguments:{input:"path"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toContain("relative: path")}),it("should prevent directory traversal attacks with relative paths",async()=>{const{loadToolHandlers}=await import("./mcp_server_core.cjs"),outsideDir=fs.mkdtempSync(path.join(os.tmpdir(),"mcp-outside-")),outsideHandlerPath=path.join(outsideDir,"outside_handler.cjs");fs.writeFileSync(outsideHandlerPath,'module.exports = function() { return "should not be loaded"; };');const tools=[{name:"traversal_attack_tool",description:"A tool trying to escape basePath",inputSchema:{type:"object",properties:{}},handler:"../../../"+path.basename(outsideDir)+"/outside_handler.cjs"}];loadToolHandlers(server,tools,tempDir),expect(tools[0].handler).toBe("../../../"+path.basename(outsideDir)+"/outside_handler.cjs"),fs.rmSync(outsideDir,{recursive:!0})}),it("should handle handler returning non-serializable value (circular reference)",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"circular_handler.cjs");fs.writeFileSync(handlerPath,"module.exports = function(args) {\n          const obj = { input: args.input };\n          obj.self = obj; // Circular reference\n          return obj;\n        };");const tools=[{name:"test_circular",description:"A tool returning circular reference",inputSchema:{type:"object",properties:{input:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_circular",arguments:{input:"test"}}}),expect(results).toHaveLength(1),expect(results[0].result.content[0].text).toBe("[object Object]")}),it("should load and execute shell script handler",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"test_handler.sh");fs.writeFileSync(handlerPath,'#!/bin/bash\necho "Hello from shell script"\necho "Input was: $INPUT_NAME"\necho "result=success" >> $GITHUB_OUTPUT\n',{mode:493});const tools=[{name:"test_shell",description:"A shell script tool",inputSchema:{type:"object",properties:{name:{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),expect(typeof tools[0].handler).toBe("function"),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_shell",arguments:{name:"world"}}}),expect(results).toHaveLength(1);const resultContent=JSON.parse(results[0].result.content[0].text);expect(resultContent.stdout).toContain("Hello from shell script"),expect(resultContent.stdout).toContain("Input was: world"),expect(resultContent.outputs.result).toBe("success")}),it("should handle shell script with multiple outputs",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"multi_output.sh");fs.writeFileSync(handlerPath,'#!/bin/bash\necho "first=value1" >> $GITHUB_OUTPUT\necho "second=value2" >> $GITHUB_OUTPUT\necho "third=value with spaces" >> $GITHUB_OUTPUT\n',{mode:493});const tools=[{name:"test_multi_output",description:"Shell script with multiple outputs",inputSchema:{type:"object",properties:{}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_multi_output",arguments:{}}}),expect(results).toHaveLength(1);const resultContent=JSON.parse(results[0].result.content[0].text);expect(resultContent.outputs.first).toBe("value1"),expect(resultContent.outputs.second).toBe("value2"),expect(resultContent.outputs.third).toBe("value with spaces")}),it("should handle shell script errors",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"error_handler.sh");fs.writeFileSync(handlerPath,'#!/bin/bash\necho "About to fail" >&2\nexit 1\n',{mode:493});const tools=[{name:"test_shell_error",description:"Shell script that errors",inputSchema:{type:"object",properties:{}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_shell_error",arguments:{}}}),expect(results).toHaveLength(1),expect(results[0].error).toBeDefined()}),it("should convert input names with dashes to underscores",async()=>{const{loadToolHandlers,registerTool,handleMessage}=await import("./mcp_server_core.cjs"),handlerPath=path.join(tempDir,"env_handler.sh");fs.writeFileSync(handlerPath,'#!/bin/bash\necho "my-input value: $INPUT_MY_INPUT"\necho "result=$INPUT_MY_INPUT" >> $GITHUB_OUTPUT\n',{mode:493});const tools=[{name:"test_env_conversion",description:"Tests env var conversion",inputSchema:{type:"object",properties:{"my-input":{type:"string"}}},handler:handlerPath}];loadToolHandlers(server,tools,tempDir),registerTool(server,tools[0]);const results=[];server.writeMessage=msg=>results.push(msg),server.replyResult=(id,result)=>results.push({jsonrpc:"2.0",id,result}),server.replyError=(id,code,message)=>results.push({jsonrpc:"2.0",id,error:{code,message}}),await handleMessage(server,{jsonrpc:"2.0",id:1,method:"tools/call",params:{name:"test_env_conversion",arguments:{"my-input":"test-value"}}}),expect(results).toHaveLength(1);const resultContent=JSON.parse(results[0].result.content[0].text);expect(resultContent.outputs.result).toBe("test-value")})})});