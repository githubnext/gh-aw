const http=require("http"),{randomUUID}=require("crypto"),{createServer,registerTool,handleRequest}=require("./mcp_server_core.cjs");class MCPServer{constructor(serverInfo,options={}){this._coreServer=createServer(serverInfo,options),this.serverInfo=serverInfo,this.capabilities=options.capabilities||{tools:{}},this.tools=new Map,this.transport=null,this.initialized=!1}tool(name,description,inputSchema,handler){this.tools.set(name,{name,description,inputSchema,handler}),registerTool(this._coreServer,{name,description,inputSchema,handler})}async connect(transport){this.transport=transport,transport.setServer(this),await transport.start()}async handleRequest(request){return"initialize"===request.method&&(this.initialized=!0),handleRequest(this._coreServer,request)}}class MCPHTTPTransport{constructor(options={}){this.sessionIdGenerator=options.sessionIdGenerator,this.enableJsonResponse=!1!==options.enableJsonResponse,this.enableDnsRebindingProtection=options.enableDnsRebindingProtection||!1,this.server=null,this.sessionId=null,this.started=!1}setServer(server){this.server=server}async start(){if(this.started)throw new Error("Transport already started");this.started=!0}async handleRequest(req,res,parsedBody){if(res.setHeader("Access-Control-Allow-Origin","*"),res.setHeader("Access-Control-Allow-Methods","GET, POST, OPTIONS"),res.setHeader("Access-Control-Allow-Headers","Content-Type, Accept, Mcp-Session-Id"),"OPTIONS"===req.method)return res.writeHead(200),void res.end();if("POST"!==req.method)return res.writeHead(405,{"Content-Type":"application/json"}),void res.end(JSON.stringify({error:"Method not allowed"}));try{let body=parsedBody;if(!body){const chunks=[];for await(const chunk of req)chunks.push(chunk);const bodyStr=Buffer.concat(chunks).toString();try{body=bodyStr?JSON.parse(bodyStr):null}catch(parseError){return res.writeHead(400,{"Content-Type":"application/json"}),void res.end(JSON.stringify({jsonrpc:"2.0",error:{code:-32700,message:"Parse error: Invalid JSON in request body"},id:null}))}}if(!body)return res.writeHead(400,{"Content-Type":"application/json"}),void res.end(JSON.stringify({jsonrpc:"2.0",error:{code:-32600,message:"Invalid Request: Empty request body"},id:null}));if(!body.jsonrpc||"2.0"!==body.jsonrpc)return res.writeHead(400,{"Content-Type":"application/json"}),void res.end(JSON.stringify({jsonrpc:"2.0",error:{code:-32600,message:"Invalid Request: jsonrpc must be '2.0'"},id:body.id||null}));if(this.sessionIdGenerator)if("initialize"===body.method)this.sessionId=this.sessionIdGenerator();else{const requestSessionId=req.headers["mcp-session-id"];if(!requestSessionId)return res.writeHead(400,{"Content-Type":"application/json"}),void res.end(JSON.stringify({jsonrpc:"2.0",error:{code:-32600,message:"Invalid Request: Missing Mcp-Session-Id header"},id:body.id||null}));if(requestSessionId!==this.sessionId)return res.writeHead(404,{"Content-Type":"application/json"}),void res.end(JSON.stringify({jsonrpc:"2.0",error:{code:-32001,message:"Session not found"},id:body.id||null}))}const response=await this.server.handleRequest(body);if(null===response)return res.writeHead(204),void res.end();const headers={"Content-Type":"application/json"};this.sessionId&&(headers["mcp-session-id"]=this.sessionId),res.writeHead(200,headers),res.end(JSON.stringify(response))}catch(error){res.headersSent||(res.writeHead(500,{"Content-Type":"application/json"}),res.end(JSON.stringify({jsonrpc:"2.0",error:{code:-32603,message:error instanceof Error?error.message:String(error)},id:null})))}}}module.exports={MCPServer,MCPHTTPTransport};