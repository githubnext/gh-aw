package workflow

import (
	"fmt"
	"strings"

	"github.com/githubnext/gh-aw/pkg/logger"
)

var compilerYamlArtifactsLog = logger.New("workflow:compiler_yaml_artifacts")

// generateUploadAgentLogs generates a step that uploads the agent's stdout/stderr logs
func (c *Compiler) generateUploadAgentLogs(yaml *strings.Builder, logFileFull string) error {
	compilerYamlArtifactsLog.Printf("Generating agent logs upload step: %s", logFileFull)
	return c.generateArtifactUpload(yaml, ArtifactUploadConfig{
		StepName:       "Upload Agent Stdio",
		ArtifactName:   "agent-stdio.log",
		UploadPaths:    []string{logFileFull},
		IfNoFilesFound: "warn",
	})
}

// generateUploadAssets generates a step that uploads safe outputs assets
func (c *Compiler) generateUploadAssets(yaml *strings.Builder) error {
	compilerYamlArtifactsLog.Print("Generating safe outputs assets upload step")
	return c.generateArtifactUpload(yaml, ArtifactUploadConfig{
		StepName:       "Upload safe outputs assets",
		ArtifactName:   "safe-outputs-assets",
		UploadPaths:    []string{"/tmp/gh-aw/safeoutputs/assets/"},
		IfNoFilesFound: "ignore",
	})
}

// generateUploadAwInfo generates a step that uploads the aw_info.json file
func (c *Compiler) generateUploadAwInfo(yaml *strings.Builder) error {
	return c.generateArtifactUpload(yaml, ArtifactUploadConfig{
		StepName:       "Upload agentic run info",
		ArtifactName:   "aw_info.json",
		UploadPaths:    []string{"/tmp/gh-aw/aw_info.json"},
		IfNoFilesFound: "warn",
	})
}

// generateUploadPrompt generates a step that uploads the prompt file
func (c *Compiler) generateUploadPrompt(yaml *strings.Builder) error {
	return c.generateArtifactUpload(yaml, ArtifactUploadConfig{
		StepName:       "Upload prompt",
		ArtifactName:   "prompt.txt",
		UploadPaths:    []string{"/tmp/gh-aw/aw-prompts/prompt.txt"},
		IfNoFilesFound: "warn",
	})
}

// generateExtractAccessLogs is a legacy method that no longer does anything
// Network filtering is now handled at the workflow level
func (c *Compiler) generateExtractAccessLogs(yaml *strings.Builder, tools map[string]any) {
	// No proxy tools anymore - network filtering is handled at workflow level
}

// generateUploadAccessLogs is a legacy method that no longer does anything
// Network filtering is now handled at the workflow level
func (c *Compiler) generateUploadAccessLogs(yaml *strings.Builder, tools map[string]any) {
	// No proxy tools anymore - network filtering is handled at workflow level
}

// generateUploadMCPLogs generates a step that uploads MCP server logs
func (c *Compiler) generateUploadMCPLogs(yaml *strings.Builder) error {
	return c.generateArtifactUpload(yaml, ArtifactUploadConfig{
		StepName:       "Upload MCP logs",
		ArtifactName:   "mcp-logs",
		UploadPaths:    []string{"/tmp/gh-aw/mcp-logs/"},
		IfNoFilesFound: "ignore",
	})
}

// generateUploadSafeInputsLogs generates a step that uploads SafeInputs logs
func (c *Compiler) generateUploadSafeInputsLogs(yaml *strings.Builder) error {
	return c.generateArtifactUpload(yaml, ArtifactUploadConfig{
		StepName:       "Upload SafeInputs logs",
		ArtifactName:   "safeinputs",
		UploadPaths:    []string{"/tmp/gh-aw/safe-inputs/logs/"},
		IfNoFilesFound: "ignore",
	})
}

// generateGitPatchUploadStep generates a step that uploads a git patch artifact
// The patch itself is generated by the safe-outputs MCP server when create_pull_request
// or push_to_pull_request_branch tools are called.
func (c *Compiler) generateGitPatchUploadStep(yaml *strings.Builder) {
	compilerYamlArtifactsLog.Print("Generating git patch upload step")
	yaml.WriteString("      - name: Upload git patch\n")
	yaml.WriteString("        if: always()\n")
	fmt.Fprintf(yaml, "        uses: %s\n", GetActionPin("actions/upload-artifact"))
	yaml.WriteString("        with:\n")
	yaml.WriteString("          name: aw.patch\n")
	yaml.WriteString("          path: /tmp/gh-aw/aw.patch\n")
	yaml.WriteString("          if-no-files-found: ignore\n")
}
