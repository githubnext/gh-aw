package workflow

import (
	"encoding/json"
	"fmt"
	"strings"
)

// NetworkHookGenerator generates network permission hooks for engine configurations
type NetworkHookGenerator struct{}

// GenerateNetworkHookScript generates a Python hook script for network permissions
func (g *NetworkHookGenerator) GenerateNetworkHookScript(allowedDomains []string) string {
	// Convert domain list to JSON for embedding in Python
	domainsJSON, _ := json.Marshal(allowedDomains)

	return fmt.Sprintf(`#!/usr/bin/env python3
"""
Network permissions validator for Claude Code engine.
Generated by gh-aw from engine network permissions configuration.
"""

import json
import sys
import urllib.parse
import re

# Domain whitelist (populated during generation)
ALLOWED_DOMAINS = %s

def extract_domain(url_or_query):
    """Extract domain from URL or search query."""
    if not url_or_query:
        return None
    
    if url_or_query.startswith(('http://', 'https://')):
        return urllib.parse.urlparse(url_or_query).netloc.lower()
    
    # Check for domain patterns in search queries
    match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
    if match:
        return match.group(1).lower()
    
    return None

def is_domain_allowed(domain):
    """Check if domain is allowed."""
    if not domain:
        return True
    
    for pattern in ALLOWED_DOMAINS:
        regex = pattern.replace('.', r'\.').replace('*', '.*')
        if re.match(f'^{regex}$', domain):
            return True
    return False

# Main logic
try:
    data = json.load(sys.stdin)
    tool_name = data.get('tool_name', '')
    tool_input = data.get('tool_input', {})
    
    if tool_name not in ['WebFetch', 'WebSearch']:
        sys.exit(0)  # Allow other tools
    
    target = tool_input.get('url') or tool_input.get('query', '')
    domain = extract_domain(target)
    
    # For WebSearch, apply domain restrictions consistently
    # Only allow if domain is in allowlist or if no domain detected AND allowlist is empty
    if tool_name == 'WebSearch' and not domain:
        # Block general searches when domain restrictions are in place
        if ALLOWED_DOMAINS:
            print(f"Network access blocked for WebSearch: no specific domain detected", file=sys.stderr)
            print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
            sys.exit(2)  # Block general searches when restrictions exist
        else:
            sys.exit(0)  # Allow general searches only when no restrictions
    
    if not is_domain_allowed(domain):
        print(f"Network access blocked for domain: {domain}", file=sys.stderr)
        print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
        sys.exit(2)  # Block with feedback to Claude
    
    sys.exit(0)  # Allow
    
except Exception as e:
    print(f"Network validation error: {e}", file=sys.stderr)
    sys.exit(2)  # Block on errors
`, string(domainsJSON))
}

// GenerateNetworkHookWorkflowStep generates a GitHub Actions workflow step that creates the network permissions hook
func (g *NetworkHookGenerator) GenerateNetworkHookWorkflowStep(allowedDomains []string) GitHubActionStep {
	hookScript := g.GenerateNetworkHookScript(allowedDomains)

	// No escaping needed for heredoc with 'EOF' - it's literal
	runContent := fmt.Sprintf(`mkdir -p .claude/hooks
cat > .claude/hooks/network_permissions.py << 'EOF'
%s
EOF
chmod +x .claude/hooks/network_permissions.py`, hookScript)

	var lines []string
	lines = append(lines, "      - name: Generate Network Permissions Hook")
	lines = append(lines, "        run: |")

	// Split the run content into lines and properly indent
	runLines := strings.Split(runContent, "\n")
	for _, line := range runLines {
		lines = append(lines, fmt.Sprintf("          %s", line))
	}

	return GitHubActionStep(lines)
}

// HasNetworkPermissions checks if the engine config has network permissions configured
// and if the engine is Claude (network permissions are only supported for Claude engine)
func HasNetworkPermissions(engineConfig *EngineConfig) bool {
	return engineConfig != nil &&
		engineConfig.ID == "claude" &&
		engineConfig.Permissions != nil &&
		engineConfig.Permissions.Network != nil &&
		len(engineConfig.Permissions.Network.Allowed) > 0
}

// GetAllowedDomains extracts the allowed domains from engine config, returns empty slice if none
func GetAllowedDomains(engineConfig *EngineConfig) []string {
	if !HasNetworkPermissions(engineConfig) {
		return []string{}
	}
	return engineConfig.Permissions.Network.Allowed
}
