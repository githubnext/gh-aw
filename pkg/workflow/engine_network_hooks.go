package workflow

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"strings"
)

//go:embed data/ecosystem_domains.json
var ecosystemDomainsJSON []byte

// ecosystemDomains holds the loaded domain data
var ecosystemDomains map[string][]string

// init loads the ecosystem domains from the embedded JSON
func init() {
	if err := json.Unmarshal(ecosystemDomainsJSON, &ecosystemDomains); err != nil {
		panic(fmt.Sprintf("failed to load ecosystem domains from JSON: %v", err))
	}
}

// getEcosystemDomains returns the domains for a given ecosystem category
func getEcosystemDomains(category string) []string {
	domains, exists := ecosystemDomains[category]
	if !exists {
		return []string{}
	}
	// Return a copy to avoid external modification
	result := make([]string, len(domains))
	copy(result, domains)
	return result
}

// NetworkHookGenerator generates network permission hooks for engine configurations
type NetworkHookGenerator struct{}

// GenerateNetworkHookScript generates a Python hook script for network permissions
func (g *NetworkHookGenerator) GenerateNetworkHookScript(allowedDomains []string) string {
	// Convert domain list to JSON for embedding in Python
	// Ensure empty slice becomes [] not null in JSON
	var domainsJSON []byte
	if allowedDomains == nil {
		domainsJSON = []byte("[]")
	} else {
		domainsJSON, _ = json.Marshal(allowedDomains)
	}

	return fmt.Sprintf(`#!/usr/bin/env python3
"""
Network permissions validator for Claude Code engine.
Generated by gh-aw from engine network permissions configuration.
"""

import json
import sys
import urllib.parse
import re

# Domain allow-list (populated during generation)
ALLOWED_DOMAINS = %s

def extract_domain(url_or_query):
    """Extract domain from URL or search query."""
    if not url_or_query:
        return None
    
    if url_or_query.startswith(('http://', 'https://')):
        return urllib.parse.urlparse(url_or_query).netloc.lower()
    
    # Check for domain patterns in search queries
    match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
    if match:
        return match.group(1).lower()
    
    return None

def is_domain_allowed(domain):
    """Check if domain is allowed."""
    if not domain:
        # If no domain detected, allow only if not under deny-all policy
        return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
    
    # Empty allowed domains means deny all
    if not ALLOWED_DOMAINS:
        return False
    
    for pattern in ALLOWED_DOMAINS:
        regex = pattern.replace('.', r'\.').replace('*', '.*')
        if re.match(f'^{regex}$', domain):
            return True
    return False

# Main logic
try:
    data = json.load(sys.stdin)
    tool_name = data.get('tool_name', '')
    tool_input = data.get('tool_input', {})
    
    if tool_name not in ['WebFetch', 'WebSearch']:
        sys.exit(0)  # Allow other tools
    
    target = tool_input.get('url') or tool_input.get('query', '')
    domain = extract_domain(target)
    
    # For WebSearch, apply domain restrictions consistently
    # If no domain detected in search query, check if restrictions are in place
    if tool_name == 'WebSearch' and not domain:
        # Since this hook is only generated when network permissions are configured,
        # empty ALLOWED_DOMAINS means deny-all policy
        if not ALLOWED_DOMAINS:  # Empty list means deny all
            print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
            print(f"No domains are allowed for WebSearch", file=sys.stderr)
            sys.exit(2)  # Block under deny-all policy
        else:
            print(f"Network access blocked for web-search: no specific domain detected", file=sys.stderr)
            print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
            sys.exit(2)  # Block general searches when domain allowlist is configured
    
    if not is_domain_allowed(domain):
        print(f"Network access blocked for domain: {domain}", file=sys.stderr)
        print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
        sys.exit(2)  # Block with feedback to Claude
    
    sys.exit(0)  # Allow
    
except Exception as e:
    print(f"Network validation error: {e}", file=sys.stderr)
    sys.exit(2)  # Block on errors
`, string(domainsJSON))
}

// GenerateNetworkHookWorkflowStep generates a GitHub Actions workflow step that creates the network permissions hook
func (g *NetworkHookGenerator) GenerateNetworkHookWorkflowStep(allowedDomains []string) GitHubActionStep {
	hookScript := g.GenerateNetworkHookScript(allowedDomains)

	// No escaping needed for heredoc with 'EOF' - it's literal
	runContent := fmt.Sprintf(`mkdir -p .claude/hooks
cat > .claude/hooks/network_permissions.py << 'EOF'
%s
EOF
chmod +x .claude/hooks/network_permissions.py`, hookScript)

	var lines []string
	lines = append(lines, "      - name: Generate Network Permissions Hook")
	lines = append(lines, "        run: |")

	// Split the run content into lines and properly indent
	runLines := strings.Split(runContent, "\n")
	for _, line := range runLines {
		lines = append(lines, fmt.Sprintf("          %s", line))
	}

	return GitHubActionStep(lines)
}

// GenerateNetworkHookWorkflowStepJS generates a GitHub Actions workflow step using JavaScript instead of Python
func (g *NetworkHookGenerator) GenerateNetworkHookWorkflowStepJS(allowedDomains []string) GitHubActionStep {
	var lines []string
	lines = append(lines, "      - name: Network Permissions Validation")
	lines = append(lines, "        uses: actions/github-script@v8")
	lines = append(lines, "        with:")
	lines = append(lines, "          script: |")

	// Get the JavaScript content and format it for YAML
	jsContent := GetNetworkPermissionsHookScript()
	jsLines := FormatJavaScriptForYAML(jsContent)
	lines = append(lines, jsLines...)

	return GitHubActionStep(lines)
}

// ShouldEnforceNetworkPermissions checks if network permissions should be enforced
// Returns true if network permissions are configured and not in "defaults" mode
func ShouldEnforceNetworkPermissions(network *NetworkPermissions) bool {
	if network == nil {
		return false // No network config, defaults to full access
	}
	if network.Mode == "defaults" {
		return true // "defaults" mode uses restricted allow-list (enforcement needed)
	}
	return true // Object format means some restriction is configured
}

// GetAllowedDomains returns the allowed domains from network permissions
// Returns default allow-list if no network permissions configured or in "defaults" mode
// Returns empty slice if network permissions configured but no domains allowed (deny all)
// Returns domain list if network permissions configured with allowed domains
// Supports ecosystem identifiers:
//   - "defaults": basic infrastructure (certs, JSON schema, Ubuntu, common package mirrors, Microsoft sources)
//   - "containers": container registries (Docker, GitHub Container Registry, etc.)
//   - "dotnet": .NET and NuGet ecosystem
//   - "dart": Dart/Flutter ecosystem
//   - "github": GitHub domains
//   - "go": Go ecosystem
//   - "terraform": HashiCorp/Terraform
//   - "haskell": Haskell ecosystem
//   - "java": Java/Maven/Gradle
//   - "linux-distros": Linux distribution package repositories
//   - "node": Node.js/NPM/Yarn
//   - "perl": Perl/CPAN
//   - "php": PHP/Composer
//   - "playwright": Playwright testing framework
//   - "python": Python/PyPI/Conda
//   - "ruby": Ruby/RubyGems
//   - "rust": Rust/Cargo/Crates
//   - "swift": Swift/CocoaPods
func GetAllowedDomains(network *NetworkPermissions) []string {
	if network == nil {
		return getEcosystemDomains("defaults") // Default allow-list for backwards compatibility
	}
	if network.Mode == "defaults" {
		return getEcosystemDomains("defaults") // Default allow-list for defaults mode
	}

	// Handle empty allowed list (deny-all case)
	if len(network.Allowed) == 0 {
		return []string{} // Return empty slice, not nil
	}

	// Process the allowed list, expanding ecosystem identifiers if present
	var expandedDomains []string
	for _, domain := range network.Allowed {
		// Try to get domains for this ecosystem category
		ecosystemDomains := getEcosystemDomains(domain)
		if len(ecosystemDomains) > 0 {
			// This was an ecosystem identifier, expand it
			expandedDomains = append(expandedDomains, ecosystemDomains...)
		} else {
			// Add the domain as-is (regular domain name)
			expandedDomains = append(expandedDomains, domain)
		}
	}

	return expandedDomains
}

// GetDomainEcosystem returns the ecosystem identifier for a given domain, or empty string if not found
func GetDomainEcosystem(domain string) string {
	// Check each ecosystem for domain match
	for ecosystem := range ecosystemDomains {
		domains := getEcosystemDomains(ecosystem)
		for _, ecosystemDomain := range domains {
			if matchesDomain(domain, ecosystemDomain) {
				return ecosystem
			}
		}
	}

	return "" // No ecosystem found
}

// matchesDomain checks if a domain matches a pattern (supports wildcards)
func matchesDomain(domain, pattern string) bool {
	// Exact match
	if domain == pattern {
		return true
	}

	// Wildcard match
	if strings.HasPrefix(pattern, "*.") {
		suffix := pattern[2:] // Remove "*."
		return strings.HasSuffix(domain, "."+suffix) || domain == suffix
	}

	return false
}

// HasNetworkPermissions is deprecated - use ShouldEnforceNetworkPermissions instead
// Kept for backwards compatibility but will be removed in future versions
func HasNetworkPermissions(engineConfig *EngineConfig) bool {
	// This function is now deprecated since network permissions are top-level
	// Return false for backwards compatibility
	return false
}
