package workflow

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/githubnext/gh-aw/pkg/testutil"
)

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func TestGitPatchGeneration(t *testing.T) {
	// Create a temporary directory for the test
	tmpDir := testutil.TempDir(t, "test-*")

	// Create a test markdown file with minimal agentic workflow
	testMarkdown := `---
on:
  workflow_dispatch:
safe-outputs:
  create-pull-request:
---

# Test Git Patch

This is a test workflow to validate git patch generation.

Please do the following tasks:
1. Check current status
2. Make some changes
3. Verify the git patch is generated
`

	// Write the test file
	mdFile := filepath.Join(tmpDir, "test-git-patch.md")
	if err := os.WriteFile(mdFile, []byte(testMarkdown), 0644); err != nil {
		t.Fatalf("Failed to write test markdown file: %v", err)
	}

	// Create compiler with verbose enabled for testing
	compiler := NewCompiler(false, "", "test-version")

	// Compile the workflow
	if err := compiler.CompileWorkflow(mdFile); err != nil {
		t.Fatalf("Failed to compile workflow: %v", err)
	}

	// Read the generated lock file
	lockFile := filepath.Join(tmpDir, "test-git-patch.lock.yml")
	content, err := os.ReadFile(lockFile)
	if err != nil {
		t.Fatalf("Failed to read generated lock file: %v", err)
	}

	lockContent := string(content)

	// NOTE: Git patch generation has been moved to the safe-outputs MCP server
	// The patch is now generated when create_pull_request or push_to_pull_request_branch
	// tools are called within the MCP server, not as a separate workflow step.

	// Verify git patch generation step does NOT exist in main job anymore
	if strings.Contains(lockContent, "- name: Generate git patch") {
		t.Error("Did not expect 'Generate git patch' step in main job (now handled by MCP server)")
	}

	// The patch generation script commands should NOT be in the main job
	// Note: git commands may still appear elsewhere in the workflow (e.g., checkout, git config)
	mainJobIndex := strings.Index(lockContent, "execute_agentic_workflow:")
	createPRJobIndex := strings.Index(lockContent, "create_pull_request:")
	
	var mainJobContent string
	if mainJobIndex != -1 && createPRJobIndex != -1 {
		mainJobContent = lockContent[mainJobIndex:createPRJobIndex]
	} else if mainJobIndex != -1 {
		mainJobContent = lockContent[mainJobIndex:]
	}

	// Check that the main job doesn't have patch generation commands
	if strings.Contains(mainJobContent, "git format-patch") {
		t.Error("Did not expect 'git format-patch' command in main job (now handled by MCP server)")
	}

	// Verify git patch upload step still exists (for backward compatibility with processing jobs)
	// This step uploads the patch artifact that was generated by the MCP server
	if !strings.Contains(lockContent, "- name: Upload git patch") {
		t.Error("Expected 'Upload git patch' step to be in generated workflow")
	}

	// Verify the upload step uses actions/upload-artifact
	if !strings.Contains(lockContent, "uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4") {
		t.Error("Expected upload-artifact action to be used for git patch upload step")
	}

	// Verify the artifact upload configuration
	if !strings.Contains(lockContent, "name: aw.patch") {
		t.Error("Expected artifact name 'aw.patch' in upload step")
	}

	if !strings.Contains(lockContent, "path: /tmp/gh-aw/aw.patch") {
		t.Error("Expected artifact path '/tmp/gh-aw/aw.patch' in upload step")
	}

	if !strings.Contains(lockContent, "if-no-files-found: ignore") {
		t.Error("Expected 'if-no-files-found: ignore' in upload step")
	}

	// Verify the upload step runs with conditional logic for file existence
	uploadPatchIndex := strings.Index(lockContent, "- name: Upload git patch")
	if uploadPatchIndex == -1 {
		t.Fatal("Upload git patch step not found")
	}

	// Find the next step after upload patch step
	nextUploadStart := uploadPatchIndex + len("- name: Upload git patch")
	uploadStepEnd := strings.Index(lockContent[nextUploadStart:], "- name:")
	if uploadStepEnd == -1 {
		uploadStepEnd = len(lockContent) - nextUploadStart
	}
	uploadPatchStep := lockContent[uploadPatchIndex : nextUploadStart+uploadStepEnd]

	if !strings.Contains(uploadPatchStep, "if: always()") {
		t.Error("Expected upload git patch step to have 'if: always()' condition")
	}

	t.Logf("Successfully verified git patch workflow (patch now generated in MCP server)")
}
