package workflow

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/githubnext/gh-aw/pkg/constants"
	"github.com/githubnext/gh-aw/pkg/logger"
	"github.com/goccy/go-yaml"
)

var resolveLog = logger.New("workflow:resolve")

// ResolveWorkflowName converts an agentic workflow ID to the GitHub Actions workflow name.
// It normalizes the input by removing .md and .lock.yml extensions, then finds the
// corresponding workflow files and extracts the actual workflow name from the lock.yml file.
//
// The agentic workflow ID is the basename of the markdown file without the .md extension.
// The GitHub Actions workflow name is extracted from the "name:" field in the corresponding .lock.yml file.
//
// Examples:
//   - "weekly-research" -> "Weekly Research" (from weekly-research.lock.yml name field)
//   - "weekly-research.md" -> "Weekly Research" (from weekly-research.lock.yml name field)
//   - "weekly-research.lock.yml" -> "Weekly Research" (from weekly-research.lock.yml name field)
func ResolveWorkflowName(workflowInput string) (string, error) {
	if workflowInput == "" {
		return "", nil
	}

	resolveLog.Printf("Resolving workflow name for input: %s", workflowInput)

	// Normalize the workflow name by removing extensions
	normalizedName := normalizeWorkflowName(workflowInput)
	resolveLog.Printf("Normalized workflow name: %s", normalizedName)

	// Get the workflows directory
	workflowsDir := constants.GetWorkflowDir()

	// Check if the agentic workflow markdown file exists
	mdFile := filepath.Join(workflowsDir, normalizedName+".md")
	if _, err := os.Stat(mdFile); err != nil {
		resolveLog.Printf("Markdown file not found: %s", mdFile)
		return "", fmt.Errorf("agentic workflow '%s' not found (expected file: %s)", normalizedName, mdFile)
	}

	// The corresponding lock file name is what GitHub Actions uses as the workflow name
	lockFileName := normalizedName + ".lock.yml"
	lockFile := filepath.Join(workflowsDir, lockFileName)

	// Check if the lock file exists (should be generated by compile)
	if _, err := os.Stat(lockFile); err != nil {
		return "", fmt.Errorf("compiled workflow '%s' not found (expected file: %s). Run 'gh aw compile' first", normalizedName, lockFile)
	}

	// Read and parse the lock file to extract the workflow name
	content, err := os.ReadFile(lockFile)
	if err != nil {
		return "", fmt.Errorf("failed to read lock file '%s': %w", lockFile, err)
	}

	// Parse YAML to extract the name field
	var workflow struct {
		Name string `yaml:"name"`
	}

	if err := yaml.Unmarshal(content, &workflow); err != nil {
		return "", fmt.Errorf("failed to parse YAML from lock file '%s': %w", lockFile, err)
	}

	if workflow.Name == "" {
		resolveLog.Printf("Workflow name field missing in lock file: %s", lockFile)
		return "", fmt.Errorf("workflow name not found in lock file '%s'", lockFile)
	}

	resolveLog.Printf("Successfully resolved workflow name: %s", workflow.Name)
	return workflow.Name, nil
}

// normalizeWorkflowName removes .md and .lock.yml extensions from workflow names
// to get the base workflow identifier.
//
// Examples:
//   - "weekly-research" -> "weekly-research"
//   - "weekly-research.md" -> "weekly-research"
//   - "weekly-research.lock.yml" -> "weekly-research"
func normalizeWorkflowName(name string) string {
	// Remove .lock.yml extension first (longer extension)
	if strings.HasSuffix(name, ".lock.yml") {
		return strings.TrimSuffix(name, ".lock.yml")
	}

	// Remove .md extension
	if strings.HasSuffix(name, ".md") {
		return strings.TrimSuffix(name, ".md")
	}

	return name
}
