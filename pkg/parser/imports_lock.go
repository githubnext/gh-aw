package parser

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// ImportLockFileVersion is the current version of the lock file format
const ImportLockFileVersion = "1"

// ReadImportLockFile reads and parses an import lock file
func ReadImportLockFile(lockFilePath string) (*ImportLockFile, error) {
	if _, err := os.Stat(lockFilePath); os.IsNotExist(err) {
		// Lock file doesn't exist, return empty lock
		return &ImportLockFile{
			Version: ImportLockFileVersion,
			Entries: []*ImportLockEntry{},
		}, nil
	}

	file, err := os.Open(lockFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open lock file: %w", err)
	}
	defer file.Close()

	lock := &ImportLockFile{
		Version: ImportLockFileVersion,
		Entries: []*ImportLockEntry{},
	}

	scanner := bufio.NewScanner(file)
	var currentEntry *ImportLockEntry
	var inFilesSection bool

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Check for version line
		if strings.HasPrefix(line, "version:") {
			parts := strings.SplitN(line, ":", 2)
			if len(parts) == 2 {
				lock.Version = strings.TrimSpace(parts[1])
			}
			continue
		}

		// Check for import line (starts with org/repo)
		if strings.Contains(line, " ") && !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "\t") {
			// Save previous entry if exists
			if currentEntry != nil {
				lock.Entries = append(lock.Entries, currentEntry)
			}

			// Parse new entry
			parts := strings.Fields(line)
			if len(parts) >= 4 {
				spec, err := ParseImportSpec(strings.Join(parts[:3], " "))
				if err != nil {
					return nil, fmt.Errorf("failed to parse import spec '%s': %w", line, err)
				}

				currentEntry = &ImportLockEntry{
					ImportSpec: spec,
					CommitSHA:  parts[3],
					ResolvedAt: "",
					Files:      []string{},
				}

				// Check for resolved timestamp (optional, after SHA)
				if len(parts) > 4 {
					currentEntry.ResolvedAt = strings.Join(parts[4:], " ")
				}

				inFilesSection = false
			}
			continue
		}

		// Check for files section
		if strings.HasPrefix(line, "  files:") || strings.HasPrefix(line, "\tfiles:") {
			inFilesSection = true
			continue
		}

		// Parse file entry
		if inFilesSection && currentEntry != nil {
			// Remove leading whitespace/dash
			file := strings.TrimSpace(line)
			file = strings.TrimPrefix(file, "- ")
			file = strings.TrimPrefix(file, "-")
			file = strings.TrimSpace(file)
			if file != "" {
				currentEntry.Files = append(currentEntry.Files, file)
			}
		}
	}

	// Add last entry
	if currentEntry != nil {
		lock.Entries = append(lock.Entries, currentEntry)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("failed to read lock file: %w", err)
	}

	return lock, nil
}

// WriteImportLockFile writes an import lock file
func WriteImportLockFile(lockFilePath string, lock *ImportLockFile) error {
	// Sort entries by repo slug for consistent output
	sort.Slice(lock.Entries, func(i, j int) bool {
		return lock.Entries[i].ImportSpec.RepoSlug() < lock.Entries[j].ImportSpec.RepoSlug()
	})

	file, err := os.Create(lockFilePath)
	if err != nil {
		return fmt.Errorf("failed to create lock file: %w", err)
	}
	defer file.Close()

	// Write header
	fmt.Fprintf(file, "# Import lock file generated by gh-aw\n")
	fmt.Fprintf(file, "# This file records resolved versions and commit SHAs for imports\n")
	fmt.Fprintf(file, "# Do not edit manually\n\n")
	fmt.Fprintf(file, "version: %s\n\n", lock.Version)

	// Write entries
	for _, entry := range lock.Entries {
		// Write import spec with commit SHA
		fmt.Fprintf(file, "%s %s", entry.ImportSpec.String(), entry.CommitSHA)

		// Write resolved timestamp if available
		if entry.ResolvedAt != "" {
			fmt.Fprintf(file, " %s", entry.ResolvedAt)
		}
		fmt.Fprintf(file, "\n")

		// Write files section if present
		if len(entry.Files) > 0 {
			fmt.Fprintf(file, "  files:\n")
			for _, f := range entry.Files {
				fmt.Fprintf(file, "    - %s\n", f)
			}
		}

		fmt.Fprintf(file, "\n")
	}

	return nil
}

// FindEntry finds a lock entry by import spec
func (l *ImportLockFile) FindEntry(spec *ImportSpec) *ImportLockEntry {
	for _, entry := range l.Entries {
		if entry.ImportSpec.RepoSlug() == spec.RepoSlug() &&
			entry.ImportSpec.Version == spec.Version &&
			entry.ImportSpec.Path == spec.Path {
			return entry
		}
	}
	return nil
}

// AddOrUpdateEntry adds or updates a lock entry
func (l *ImportLockFile) AddOrUpdateEntry(entry *ImportLockEntry) {
	// Check if entry exists
	for i, existing := range l.Entries {
		if existing.ImportSpec.RepoSlug() == entry.ImportSpec.RepoSlug() &&
			existing.ImportSpec.Version == entry.ImportSpec.Version &&
			existing.ImportSpec.Path == entry.ImportSpec.Path {
			// Update existing entry
			l.Entries[i] = entry
			return
		}
	}

	// Add new entry
	l.Entries = append(l.Entries, entry)
}

// GetImportsDir returns the directory where imports are cached
func GetImportsDir() (string, error) {
	// Use .aw/imports in the current project
	cwd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("failed to get current directory: %w", err)
	}

	// Find git root (go up until we find .git directory)
	gitRoot, err := findGitRoot(cwd)
	if err != nil {
		return "", fmt.Errorf("not in a git repository: %w", err)
	}

	importsDir := filepath.Join(gitRoot, ".aw", "imports")
	return importsDir, nil
}

// GetImportLockFilePath returns the path to the import lock file
func GetImportLockFilePath() (string, error) {
	cwd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("failed to get current directory: %w", err)
	}

	gitRoot, err := findGitRoot(cwd)
	if err != nil {
		return "", fmt.Errorf("not in a git repository: %w", err)
	}

	lockFile := filepath.Join(gitRoot, ".aw", "imports.lock")
	return lockFile, nil
}

// findGitRoot finds the git root directory by looking for .git
func findGitRoot(startDir string) (string, error) {
	dir := startDir
	for {
		gitDir := filepath.Join(dir, ".git")
		if _, err := os.Stat(gitDir); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached root without finding .git
			return "", fmt.Errorf(".git directory not found")
		}
		dir = parent
	}
}

// CreateImportLockEntry creates a new lock entry with current timestamp
func CreateImportLockEntry(spec *ImportSpec, commitSHA string, files []string) *ImportLockEntry {
	return &ImportLockEntry{
		ImportSpec: spec,
		CommitSHA:  commitSHA,
		ResolvedAt: time.Now().UTC().Format(time.RFC3339),
		Files:      files,
	}
}
