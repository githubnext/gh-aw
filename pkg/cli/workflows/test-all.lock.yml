# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile
# For more information: https://github.com/githubnext/gh-aw/blob/main/.github/instructions/github-agentic-workflows.instructions.md

name: "Comprehensive Test Agentic Workflow - Poem Bot"
on:
  issue_comment:
    types:
    - created
    - edited
    - deleted
  issues:
    types:
    - opened
    - edited
    - closed
    - reopened
    - labeled
    - unlabeled
    - assigned
    - unassigned
  pull_request:
    types:
    - opened
    - edited
    - closed
    - reopened
    - synchronize
    - ready_for_review
  push:
    branches:
    - main
    - develop
    tags:
    - v*
  release:
    types:
    - published
    - unpublished
    - created
    - edited
    - deleted
    - prereleased
    - released
  schedule:
  - cron: 0 9 * * 1
  - cron: 0 17 * * 5
  workflow_dispatch:
    inputs:
      action_type:
        default: create_issue_and_comment
        description: Type of action to perform
        options:
        - create_issue_and_comment
        - create_pull_request
        - update_existing_issue
        - add_labels_only
        required: true
        type: choice
      poem_theme:
        default: technology and automation
        description: Theme for the generated poem
        required: true

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}-${{ github.event.issue.number || github.event.pull_request.number }}"
  cancel-in-progress: true

run-name: Poem Bot triggered by ${{ github.actor }}

env:
  ACTION_TYPE: ${{ github.event.inputs.action_type || 'create_issue_and_comment' }}
  POEM_THEME: ${{ github.event.inputs.poem_theme || 'GitHub and coding' }}
  REPOSITORY_NAME: ${{ github.repository }}
  TRIGGER_CONTEXT: workflow-triggered

# Cache configuration from frontmatter was processed and added to the main job steps

jobs:
  check-membership:
    runs-on: ubuntu-latest
    outputs:
      error_message: ${{ steps.check-membership.outputs.error_message }}
      is_team_member: ${{ steps.check-membership.outputs.is_team_member }}
      result: ${{ steps.check-membership.outputs.result }}
      user_permission: ${{ steps.check-membership.outputs.user_permission }}
    steps:
      - name: Check team membership for workflow
        id: check-membership
        uses: actions/github-script@v8
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function main() {
              const { eventName } = context;
              // skip check for safe events
              const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
              if (safeEvents.includes(eventName)) {
                core.info(`âœ… Event ${eventName} does not require validation`);
                core.setOutput("is_team_member", "true");
                core.setOutput("result", "safe_event");
                return;
              }
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
              const requiredPermissions = requiredPermissionsEnv ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "") : [];
              if (!requiredPermissions || requiredPermissions.length === 0) {
                core.warning("âŒ Configuration error: Required permissions not specified. Contact repository administrator.");
                core.setOutput("is_team_member", "false");
                core.setOutput("result", "config_error");
                core.setOutput("error_message", "Configuration error: Required permissions not specified");
                return;
              }
              // Check if the actor has the required repository permissions
              try {
                core.debug(`Checking if user '${actor}' has required permissions for ${owner}/${repo}`);
                core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                const repoPermission = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: owner,
                  repo: repo,
                  username: actor,
                });
                const permission = repoPermission.data.permission;
                core.debug(`Repository permission level: ${permission}`);
                // Check if user has one of the required permission levels
                for (const requiredPerm of requiredPermissions) {
                  if (permission === requiredPerm || (requiredPerm === "maintainer" && permission === "maintain")) {
                    core.info(`âœ… User has ${permission} access to repository`);
                    core.setOutput("is_team_member", "true");
                    core.setOutput("result", "authorized");
                    core.setOutput("user_permission", permission);
                    return;
                  }
                }
                core.warning(`User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`);
                core.setOutput("is_team_member", "false");
                core.setOutput("result", "insufficient_permissions");
                core.setOutput("user_permission", permission);
                core.setOutput(
                  "error_message",
                  `Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
                );
              } catch (repoError) {
                const errorMessage = repoError instanceof Error ? repoError.message : String(repoError);
                core.warning(`Repository permission check failed: ${errorMessage}`);
                core.setOutput("is_team_member", "false");
                core.setOutput("result", "api_error");
                core.setOutput("error_message", `Repository permission check failed: ${errorMessage}`);
                return;
              }
            }
            await main();

  activation:
    needs: check-membership
    if: needs.check-membership.outputs.is_team_member == 'true'
    runs-on: ubuntu-latest
    outputs:
      text: ${{ steps.compute-text.outputs.text }}
    steps:
      - name: Compute current body text
        id: compute-text
        uses: actions/github-script@v8
        with:
          script: |
            function sanitizeContent(content) {
              if (!content || typeof content !== "string") {
                return "";
              }
              const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
              const defaultAllowedDomains = ["github.com", "github.io", "githubusercontent.com", "githubassets.com", "github.dev", "codespaces.new"];
              const allowedDomains = allowedDomainsEnv
                ? allowedDomainsEnv
                    .split(",")
                    .map(d => d.trim())
                    .filter(d => d)
                : defaultAllowedDomains;
              let sanitized = content;
              sanitized = neutralizeMentions(sanitized);
              sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
              sanitized = convertXmlTagsToParentheses(sanitized);
              sanitized = sanitizeUrlProtocols(sanitized);
              sanitized = sanitizeUrlDomains(sanitized);
              const maxLength = 524288;
              if (sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength) + "\n[Content truncated due to length]";
              }
              const lines = sanitized.split("\n");
              const maxLines = 65000;
              if (lines.length > maxLines) {
                sanitized = lines.slice(0, maxLines).join("\n") + "\n[Content truncated due to line count]";
              }
              sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
              sanitized = neutralizeBotTriggers(sanitized);
              return sanitized.trim();
              function convertXmlTagsToParentheses(s) {
                if (!s || typeof s !== "string") {
                  return s;
                }
                return (
                  s
                    .replace(/<\/?[a-zA-Z][a-zA-Z0-9\-_:]*(?:\s[^>]*|\/)?>/g, match => {
                      const innerContent = match.slice(1, -1);
                      return `(${innerContent})`;
                    })
                    .replace(/<!--[\s\S]*?-->/g, match => {
                      const innerContent = match.slice(4, -3); 
                      return `(!--${innerContent}--)`;
                    })
                    .replace(/<!\[CDATA\[[\s\S]*?\]\]>/g, match => {
                      const innerContent = match.slice(9, -3); 
                      return `(![CDATA[${innerContent}]])`;
                    })
                    .replace(/<\?[\s\S]*?\?>/g, match => {
                      const innerContent = match.slice(2, -2); 
                      return `(?${innerContent}?)`;
                    })
                    .replace(/<!DOCTYPE[^>]*>/gi, match => {
                      const innerContent = match.slice(9, -1); 
                      return `(!DOCTYPE${innerContent})`;
                    })
                );
              }
              function sanitizeUrlDomains(s) {
                s = s.replace(/\bhttps:\/\/([^\/\s\])}'"<>&\x00-\x1f]+)/gi, (match, domain) => {
                  const hostname = domain.split(/[\/:\?#]/)[0].toLowerCase();
                  const isAllowed = allowedDomains.some(allowedDomain => {
                    const normalizedAllowed = allowedDomain.toLowerCase();
                    return hostname === normalizedAllowed || hostname.endsWith("." + normalizedAllowed);
                  });
                  return isAllowed ? match : "(redacted)";
                });
                return s;
              }
              function sanitizeUrlProtocols(s) {
                return s.replace(/\b(\w+):(?:\/\/)?[^\s\])}'"<>&\x00-\x1f]+/gi, (match, protocol) => {
                  return protocol.toLowerCase() === "https" ? match : "(redacted)";
                });
              }
              function neutralizeMentions(s) {
                return s.replace(
                  /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                  (_m, p1, p2) => `${p1}\`@${p2}\``
                );
              }
              function neutralizeBotTriggers(s) {
                return s.replace(/\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi, (match, action, ref) => `\`${action} #${ref}\``);
              }
            }
            async function main() {
              let text = "";
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const repoPermission = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: owner,
                repo: repo,
                username: actor,
              });
              const permission = repoPermission.data.permission;
              core.debug(`Repository permission level: ${permission}`);
              if (permission !== "admin" && permission !== "maintain") {
                core.setOutput("text", "");
                return;
              }
              switch (context.eventName) {
                case "issues":
                  if (context.payload.issue) {
                    const title = context.payload.issue.title || "";
                    const body = context.payload.issue.body || "";
                    text = `${title}\n\n${body}`;
                  }
                  break;
                case "pull_request":
                  if (context.payload.pull_request) {
                    const title = context.payload.pull_request.title || "";
                    const body = context.payload.pull_request.body || "";
                    text = `${title}\n\n${body}`;
                  }
                  break;
                case "pull_request_target":
                  if (context.payload.pull_request) {
                    const title = context.payload.pull_request.title || "";
                    const body = context.payload.pull_request.body || "";
                    text = `${title}\n\n${body}`;
                  }
                  break;
                case "issue_comment":
                  if (context.payload.comment) {
                    text = context.payload.comment.body || "";
                  }
                  break;
                case "pull_request_review_comment":
                  if (context.payload.comment) {
                    text = context.payload.comment.body || "";
                  }
                  break;
                case "pull_request_review":
                  if (context.payload.review) {
                    text = context.payload.review.body || "";
                  }
                  break;
                default:
                  text = "";
                  break;
              }
              const sanitizedText = sanitizeContent(text);
              core.debug(`text: ${sanitizedText}`);
              core.setOutput("text", sanitizedText);
            }
            await main();

  agent:
    needs: activation
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      # Cache configuration from frontmatter processed below
      - name: Cache (poetry-deps-${{ hashFiles('**/poetry.lock', '**/package-lock.json') }})
        uses: actions/cache@v4
        with:
          key: poetry-deps-${{ hashFiles('**/poetry.lock', '**/package-lock.json') }}
          path: |
            ~/.cache/pypoetry
            node_modules
            ~/.npm
          restore-keys: poetry-deps-

      - name: Cache (poem-assets-${{ github.run_id }})
        uses: actions/cache@v4
        with:
          key: poem-assets-${{ github.run_id }}
          path: |
            /tmp/poem-assets
            /tmp/generated-content
          restore-keys: |
            poem-assets-
          fail-on-cache-miss: false
      # Cache memory file share configuration from frontmatter processed below
      - name: Create cache-memory directory
        run: |
          mkdir -p /tmp/cache-memory
          echo "Cache memory directory created at /tmp/cache-memory"
          echo "This folder provides persistent file storage across workflow runs"
          echo "LLMs and agentic tools can freely read and write files in this directory"
      - name: Cache memory file share data
        uses: actions/cache@v4
        with:
          key: memory-${{ github.workflow }}-${{ github.run_id }}
          path: /tmp/cache-memory
          restore-keys: |
            memory-${{ github.workflow }}-
            memory-
      - name: Upload cache-memory data as artifact
        uses: actions/upload-artifact@v4
        with:
          name: cache-memory
          path: /tmp/cache-memory
          retention-days: 30
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Generate Claude Settings
        run: |
          mkdir -p /tmp/.claude
          cat > /tmp/.claude/settings.json << 'EOF'
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "WebFetch|WebSearch",
                  "hooks": [
                    {
                      "type": "command",
                      "command": ".claude/hooks/network_permissions.py"
                    }
                  ]
                }
              ]
            }
          }
          EOF
      - name: Generate Network Permissions Hook
        run: |
          mkdir -p .claude/hooks
          cat > .claude/hooks/network_permissions.py << 'EOF'
          #!/usr/bin/env python3
          """
          Network permissions validator for Claude Code engine.
          Generated by gh-aw from engine network permissions configuration.
          """
          
          import json
          import sys
          import urllib.parse
          import re
          
          # Domain allow-list (populated during generation)
          ALLOWED_DOMAINS = ["crl3.digicert.com","crl4.digicert.com","ocsp.digicert.com","ts-crl.ws.symantec.com","ts-ocsp.ws.symantec.com","crl.geotrust.com","ocsp.geotrust.com","crl.thawte.com","ocsp.thawte.com","crl.verisign.com","ocsp.verisign.com","crl.globalsign.com","ocsp.globalsign.com","crls.ssl.com","ocsp.ssl.com","crl.identrust.com","ocsp.identrust.com","crl.sectigo.com","ocsp.sectigo.com","crl.usertrust.com","ocsp.usertrust.com","s.symcb.com","s.symcd.com","json-schema.org","json.schemastore.org","archive.ubuntu.com","security.ubuntu.com","ppa.launchpad.net","keyserver.ubuntu.com","azure.archive.ubuntu.com","api.snapcraft.io","packagecloud.io","packages.cloud.google.com","packages.microsoft.com","poetry-api.com","rhyme-zone.com"]
          
          def extract_domain(url_or_query):
              """Extract domain from URL or search query."""
              if not url_or_query:
                  return None
              
              if url_or_query.startswith(('http://', 'https://')):
                  return urllib.parse.urlparse(url_or_query).netloc.lower()
              
              # Check for domain patterns in search queries
              match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
              if match:
                  return match.group(1).lower()
              
              return None
          
          def is_domain_allowed(domain):
              """Check if domain is allowed."""
              if not domain:
                  # If no domain detected, allow only if not under deny-all policy
                  return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
              
              # Empty allowed domains means deny all
              if not ALLOWED_DOMAINS:
                  return False
              
              for pattern in ALLOWED_DOMAINS:
                  regex = pattern.replace('.', r'\.').replace('*', '.*')
                  if re.match(f'^{regex}$', domain):
                      return True
              return False
          
          # Main logic
          try:
              data = json.load(sys.stdin)
              tool_name = data.get('tool_name', '')
              tool_input = data.get('tool_input', {})
              
              if tool_name not in ['WebFetch', 'WebSearch']:
                  sys.exit(0)  # Allow other tools
              
              target = tool_input.get('url') or tool_input.get('query', '')
              domain = extract_domain(target)
              
              # For WebSearch, apply domain restrictions consistently
              # If no domain detected in search query, check if restrictions are in place
              if tool_name == 'WebSearch' and not domain:
                  # Since this hook is only generated when network permissions are configured,
                  # empty ALLOWED_DOMAINS means deny-all policy
                  if not ALLOWED_DOMAINS:  # Empty list means deny all
                      print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
                      print(f"No domains are allowed for WebSearch", file=sys.stderr)
                      sys.exit(2)  # Block under deny-all policy
                  else:
                      print(f"Network access blocked for web-search: no specific domain detected", file=sys.stderr)
                      print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                      sys.exit(2)  # Block general searches when domain allowlist is configured
              
              if not is_domain_allowed(domain):
                  print(f"Network access blocked for domain: {domain}", file=sys.stderr)
                  print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                  sys.exit(2)  # Block with feedback to Claude
              
              sys.exit(0)  # Allow
              
          except Exception as e:
              print(f"Network validation error: {e}", file=sys.stderr)
              sys.exit(2)  # Block on errors
          
          EOF
          chmod +x .claude/hooks/network_permissions.py
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require("fs");
            function main() {
              const outputFile = `/tmp/safe-outputs/outputs.jsonl`;
              fs.mkdirSync("/tmp/safe-outputs", { recursive: true });
              core.exportVariable("GITHUB_AW_SAFE_OUTPUTS", outputFile);
              core.setOutput("output_file", outputFile);
            }
            main();
      - name: Setup Safe Outputs Collector MCP
        run: |
          mkdir -p /tmp/safe-outputs
          cat > /tmp/safe-outputs/mcp-server.cjs << 'EOF'
            import { readFileSync } from "fs";
            const fs = require("fs");
            const path = require("path");
            const crypto = require("crypto");
            const encoder = new TextEncoder();
            const safeOutputsConfig = readConfig();
            const outputFile = readOutputFile();
            const SERVER_INFO = { name: "safe-outputs-mcp-server", version: "1.0.0" };
            const debug = msg => process.stderr.write(`[${SERVER_INFO.name}] ${msg}\n`);
            function writeMessage(obj) {
              const json = JSON.stringify(obj);
              debug(`send: ${json}`);
              const message = json + "\n";
              const bytes = encoder.encode(message);
              fs.writeSync(1, bytes);
            }
            class ReadBuffer {
              _buffer;
              constructor() {
                this._buffer = undefined;
              }
              append(chunk) {
                this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
              }
              readMessage() {
                if (!this._buffer) {
                  return null;
                }
                const index = this._buffer.indexOf("\n");
                if (index === -1) {
                  return null;
                }
                const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
                this._buffer = this._buffer.subarray(index + 1);
                if (line.trim() === "") {
                  return this.readMessage();
                }
                try {
                  return JSON.parse(line);
                } catch (error) {
                  throw new Error(`Parse error: ${error instanceof Error ? error.message : String(error)}`);
                }
              }
            }
            function readOutputFile() {
              return process.env.GITHUB_AW_SAFE_OUTPUTS || "/tmp/safe-outputs/outputs.jsonl";
            }
            function readConfig() {
              let safeOutputsConfigRaw;
              try {
                const configFile = readFileSync("/tmp/safe-outputs/config.json", "utf8");
                safeOutputsConfigRaw = JSON.parse(configFile);
              } catch (e) {
                const configEnv = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
                if (!configEnv) throw new Error("GITHUB_AW_SAFE_OUTPUTS_CONFIG not set");
                safeOutputsConfigRaw = JSON.parse(configEnv);
              }
              return Object.fromEntries(Object.entries(safeOutputsConfigRaw).map(([k, v]) => [k.replace(/-/g, "_"), v]));
            }
            const readBuffer = new ReadBuffer();
            function onData(chunk) {
              readBuffer.append(chunk);
              processReadBuffer();
            }
            function processReadBuffer() {
              while (true) {
                try {
                  const message = readBuffer.readMessage();
                  if (!message) {
                    break;
                  }
                  debug(`recv: ${JSON.stringify(message)}`);
                  handleMessage(message);
                } catch (error) {
                  debug(`Parse error: ${error instanceof Error ? error.message : String(error)}`);
                }
              }
            }
            function replyResult(id, result) {
              if (id === undefined || id === null) return;
              const res = { jsonrpc: "2.0", id, result };
              writeMessage(res);
            }
            function replyError(id, code, message, data) {
              if (id === undefined || id === null) {
                debug(`Error for notification: ${message}`);
                return;
              }
              const error = { code, message };
              if (data !== undefined) {
                error.data = data;
              }
              const res = {
                jsonrpc: "2.0",
                id,
                error,
              };
              writeMessage(res);
            }
            function appendSafeOutput(entry) {
              if (!outputFile) throw new Error("No output file configured");
              entry.type = entry.type.replace(/_/g, "-");
              const jsonLine = JSON.stringify(entry) + "\n";
              try {
                fs.appendFileSync(outputFile, jsonLine);
              } catch (error) {
                throw new Error(`Failed to write to output file: ${error instanceof Error ? error.message : String(error)}`);
              }
            }
            const defaultHandler = type => args => {
              const entry = { ...(args || {}), type };
              appendSafeOutput(entry);
              return {
                content: [
                  {
                    type: "text",
                    text: `success`,
                  },
                ],
              };
            };
            const uploadAssetHandler = args => {
              const branchName = process.env.GITHUB_AW_ASSETS_BRANCH;
              if (!branchName) throw new Error("GITHUB_AW_ASSETS_BRANCH not set");
              const { path: filePath } = args;
              const absolutePath = path.resolve(filePath);
              const workspaceDir = process.env.GITHUB_WORKSPACE || process.cwd();
              const tmpDir = "/tmp";
              const isInWorkspace = absolutePath.startsWith(path.resolve(workspaceDir));
              const isInTmp = absolutePath.startsWith(tmpDir);
              if (!isInWorkspace && !isInTmp) {
                throw new Error(
                  `File path must be within workspace directory (${workspaceDir}) or /tmp directory. ` +
                    `Provided path: ${filePath} (resolved to: ${absolutePath})`
                );
              }
              if (!fs.existsSync(filePath)) {
                throw new Error(`File not found: ${filePath}`);
              }
              const stats = fs.statSync(filePath);
              const sizeBytes = stats.size;
              const sizeKB = Math.ceil(sizeBytes / 1024);
              const maxSizeKB = process.env.GITHUB_AW_ASSETS_MAX_SIZE_KB ? parseInt(process.env.GITHUB_AW_ASSETS_MAX_SIZE_KB, 10) : 10240;
              if (sizeKB > maxSizeKB) {
                throw new Error(`File size ${sizeKB} KB exceeds maximum allowed size ${maxSizeKB} KB`);
              }
              const ext = path.extname(filePath).toLowerCase();
              const allowedExts = process.env.GITHUB_AW_ASSETS_ALLOWED_EXTS
                ? process.env.GITHUB_AW_ASSETS_ALLOWED_EXTS.split(",").map(ext => ext.trim())
                : [".png", ".jpg", ".jpeg"];
              if (!allowedExts.includes(ext)) {
                throw new Error(`File extension '${ext}' is not allowed. Allowed extensions: ${allowedExts.join(", ")}`);
              }
              const assetsDir = "/tmp/safe-outputs/assets";
              if (!fs.existsSync(assetsDir)) {
                fs.mkdirSync(assetsDir, { recursive: true });
              }
              const fileContent = fs.readFileSync(filePath);
              const sha = crypto.createHash("sha256").update(fileContent).digest("hex");
              const fileName = path.basename(filePath);
              const fileExt = path.extname(fileName).toLowerCase();
              const targetPath = path.join(assetsDir, fileName);
              fs.copyFileSync(filePath, targetPath);
              const targetFileName = (sha + fileExt).toLowerCase();
              const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
              const repo = process.env.GITHUB_REPOSITORY || "owner/repo";
              const url = `${githubServer.replace("github.com", "raw.githubusercontent.com")}/${repo}/${branchName}/${targetFileName}`;
              const entry = {
                type: "upload_asset",
                path: filePath,
                fileName: fileName,
                sha: sha,
                size: sizeBytes,
                url: url,
                targetFileName: targetFileName,
              };
              appendSafeOutput(entry);
              return {
                content: [
                  {
                    type: "text",
                    text: url,
                  },
                ],
              };
            };
            const normTool = toolName => (toolName ? toolName.replace(/-/g, "_").toLowerCase() : undefined);
            const ALL_TOOLS = [
              {
                name: "create_issue",
                description: "Create a new GitHub issue",
                inputSchema: {
                  type: "object",
                  required: ["title", "body"],
                  properties: {
                    title: { type: "string", description: "Issue title" },
                    body: { type: "string", description: "Issue body/description" },
                    labels: {
                      type: "array",
                      items: { type: "string" },
                      description: "Issue labels",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "create_discussion",
                description: "Create a new GitHub discussion",
                inputSchema: {
                  type: "object",
                  required: ["title", "body"],
                  properties: {
                    title: { type: "string", description: "Discussion title" },
                    body: { type: "string", description: "Discussion body/content" },
                    category: { type: "string", description: "Discussion category" },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "add_comment",
                description: "Add a comment to a GitHub issue or pull request",
                inputSchema: {
                  type: "object",
                  required: ["body"],
                  properties: {
                    body: { type: "string", description: "Comment body/content" },
                    issue_number: {
                      type: "number",
                      description: "Issue or PR number (optional for current context)",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "create_pull_request",
                description: "Create a new GitHub pull request",
                inputSchema: {
                  type: "object",
                  required: ["title", "body", "branch"],
                  properties: {
                    title: { type: "string", description: "Pull request title" },
                    body: {
                      type: "string",
                      description: "Pull request body/description",
                    },
                    branch: {
                      type: "string",
                      description: "Required branch name",
                    },
                    labels: {
                      type: "array",
                      items: { type: "string" },
                      description: "Optional labels to add to the PR",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "create_pull_request_review_comment",
                description: "Create a review comment on a GitHub pull request",
                inputSchema: {
                  type: "object",
                  required: ["path", "line", "body"],
                  properties: {
                    path: {
                      type: "string",
                      description: "File path for the review comment",
                    },
                    line: {
                      type: ["number", "string"],
                      description: "Line number for the comment",
                    },
                    body: { type: "string", description: "Comment body content" },
                    start_line: {
                      type: ["number", "string"],
                      description: "Optional start line for multi-line comments",
                    },
                    side: {
                      type: "string",
                      enum: ["LEFT", "RIGHT"],
                      description: "Optional side of the diff: LEFT or RIGHT",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "create_code_scanning_alert",
                description: "Create a code scanning alert. severity MUST be one of 'error', 'warning', 'info', 'note'.",
                inputSchema: {
                  type: "object",
                  required: ["file", "line", "severity", "message"],
                  properties: {
                    file: {
                      type: "string",
                      description: "File path where the issue was found",
                    },
                    line: {
                      type: ["number", "string"],
                      description: "Line number where the issue was found",
                    },
                    severity: {
                      type: "string",
                      enum: ["error", "warning", "info", "note"],
                      description:
                        ' Security severity levels follow the industry-standard Common Vulnerability Scoring System (CVSS) that is also used for advisories in the GitHub Advisory Database and must be one of "error", "warning", "info", "note".',
                    },
                    message: {
                      type: "string",
                      description: "Alert message describing the issue",
                    },
                    column: {
                      type: ["number", "string"],
                      description: "Optional column number",
                    },
                    ruleIdSuffix: {
                      type: "string",
                      description: "Optional rule ID suffix for uniqueness",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "add_labels",
                description: "Add labels to a GitHub issue or pull request",
                inputSchema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    labels: {
                      type: "array",
                      items: { type: "string" },
                      description: "Labels to add",
                    },
                    issue_number: {
                      type: "number",
                      description: "Issue or PR number (optional for current context)",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "update_issue",
                description: "Update a GitHub issue",
                inputSchema: {
                  type: "object",
                  properties: {
                    status: {
                      type: "string",
                      enum: ["open", "closed"],
                      description: "Optional new issue status",
                    },
                    title: { type: "string", description: "Optional new issue title" },
                    body: { type: "string", description: "Optional new issue body" },
                    issue_number: {
                      type: ["number", "string"],
                      description: "Optional issue number for target '*'",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "push_to_pull_request_branch",
                description: "Push changes to a pull request branch",
                inputSchema: {
                  type: "object",
                  required: ["branch", "message"],
                  properties: {
                    branch: {
                      type: "string",
                      description: "The name of the branch to push to, should be the branch name associated with the pull request",
                    },
                    message: { type: "string", description: "Commit message" },
                    pull_request_number: {
                      type: ["number", "string"],
                      description: "Optional pull request number for target '*'",
                    },
                  },
                  additionalProperties: false,
                },
              },
              {
                name: "upload_asset",
                description: "Publish a file as a URL-addressable asset to an orphaned git branch",
                inputSchema: {
                  type: "object",
                  required: ["path"],
                  properties: {
                    path: {
                      type: "string",
                      description:
                        "Path to the file to publish as an asset. Must be a file under the current workspace or /tmp directory. By default, images (.png, .jpg, .jpeg) are allowed, but can be configured via workflow settings.",
                    },
                  },
                  additionalProperties: false,
                },
                handler: uploadAssetHandler,
              },
              {
                name: "missing_tool",
                description: "Report a missing tool or functionality needed to complete tasks",
                inputSchema: {
                  type: "object",
                  required: ["tool", "reason"],
                  properties: {
                    tool: { type: "string", description: "Name of the missing tool" },
                    reason: { type: "string", description: "Why this tool is needed" },
                    alternatives: {
                      type: "string",
                      description: "Possible alternatives or workarounds",
                    },
                  },
                  additionalProperties: false,
                },
              },
            ];
            debug(`v${SERVER_INFO.version} ready on stdio`);
            debug(`  output file: ${outputFile}`);
            debug(`  config: ${JSON.stringify(safeOutputsConfig)}`);
            const TOOLS = {};
            ALL_TOOLS.forEach(tool => {
              if (Object.keys(safeOutputsConfig).find(config => normTool(config) === tool.name)) {
                TOOLS[tool.name] = tool;
              }
            });
            Object.keys(safeOutputsConfig).forEach(configKey => {
              const normalizedKey = normTool(configKey);
              if (TOOLS[normalizedKey]) {
                return;
              }
              if (!ALL_TOOLS.find(t => t.name === normalizedKey)) {
                const jobConfig = safeOutputsConfig[configKey];
                const dynamicTool = {
                  name: normalizedKey,
                  description: `Custom safe-job: ${configKey}`,
                  inputSchema: {
                    type: "object",
                    properties: {},
                    additionalProperties: true,
                    required: [],
                  },
                  handler: args => {
                    const entry = {
                      type: normalizedKey,
                      ...args,
                    };
                    const entryJSON = JSON.stringify(entry);
                    fs.appendFileSync(outputFile, entryJSON + "\n");
                    const outputText =
                      jobConfig && jobConfig.output
                        ? jobConfig.output
                        : `Safe-job '${configKey}' executed successfully with arguments: ${JSON.stringify(args)}`;
                    return {
                      content: [
                        {
                          type: "text",
                          text: outputText,
                        },
                      ],
                    };
                  },
                };
                if (jobConfig && jobConfig.inputs) {
                  dynamicTool.inputSchema.properties = {};
                  dynamicTool.inputSchema.required = [];
                  Object.entries(jobConfig.inputs).forEach(([inputName, inputDef]) => {
                    const propSchema = {
                      type: inputDef.type || "string",
                      description: inputDef.description || `Input parameter: ${inputName}`,
                    };
                    if (inputDef.options && Array.isArray(inputDef.options)) {
                      propSchema.enum = inputDef.options;
                    }
                    dynamicTool.inputSchema.properties[inputName] = propSchema;
                    if (inputDef.required) {
                      dynamicTool.inputSchema.required.push(inputName);
                    }
                  });
                }
                TOOLS[normalizedKey] = dynamicTool;
              }
            });
            debug(`  tools: ${Object.keys(TOOLS).join(", ")}`);
            if (!Object.keys(TOOLS).length) throw new Error("No tools enabled in configuration");
            function handleMessage(req) {
              if (!req || typeof req !== "object") {
                debug(`Invalid message: not an object`);
                return;
              }
              if (req.jsonrpc !== "2.0") {
                debug(`Invalid message: missing or invalid jsonrpc field`);
                return;
              }
              const { id, method, params } = req;
              if (!method || typeof method !== "string") {
                replyError(id, -32600, "Invalid Request: method must be a string");
                return;
              }
              try {
                if (method === "initialize") {
                  const clientInfo = params?.clientInfo ?? {};
                  console.error(`client info:`, clientInfo);
                  const protocolVersion = params?.protocolVersion ?? undefined;
                  const result = {
                    serverInfo: SERVER_INFO,
                    ...(protocolVersion ? { protocolVersion } : {}),
                    capabilities: {
                      tools: {},
                    },
                  };
                  replyResult(id, result);
                } else if (method === "tools/list") {
                  const list = [];
                  Object.values(TOOLS).forEach(tool => {
                    list.push({
                      name: tool.name,
                      description: tool.description,
                      inputSchema: tool.inputSchema,
                    });
                  });
                  replyResult(id, { tools: list });
                } else if (method === "tools/call") {
                  const name = params?.name;
                  const args = params?.arguments ?? {};
                  if (!name || typeof name !== "string") {
                    replyError(id, -32602, "Invalid params: 'name' must be a string");
                    return;
                  }
                  const tool = TOOLS[normTool(name)];
                  if (!tool) {
                    replyError(id, -32601, `Tool not found: ${name} (${normTool(name)})`);
                    return;
                  }
                  const handler = tool.handler || defaultHandler(tool.name);
                  const requiredFields = tool.inputSchema && Array.isArray(tool.inputSchema.required) ? tool.inputSchema.required : [];
                  if (requiredFields.length) {
                    const missing = requiredFields.filter(f => {
                      const value = args[f];
                      return value === undefined || value === null || (typeof value === "string" && value.trim() === "");
                    });
                    if (missing.length) {
                      replyError(id, -32602, `Invalid arguments: missing or empty ${missing.map(m => `'${m}'`).join(", ")}`);
                      return;
                    }
                  }
                  const result = handler(args);
                  const content = result && result.content ? result.content : [];
                  replyResult(id, { content });
                } else if (/^notifications\//.test(method)) {
                  debug(`ignore ${method}`);
                } else {
                  replyError(id, -32601, `Method not found: ${method}`);
                }
              } catch (e) {
                replyError(id, -32603, "Internal error", {
                  message: e instanceof Error ? e.message : String(e),
                });
              }
            }
            process.stdin.on("data", onData);
            process.stdin.on("error", err => debug(`stdin error: ${err}`));
            process.stdin.resume();
            debug(`listening...`);
          EOF
          chmod +x /tmp/safe-outputs/mcp-server.cjs
          
      - name: Setup MCPs
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"add-comment\":{\"target\":\"*\"},\"add-labels\":{},\"create-issue\":{},\"create-pull-request\":{},\"create-pull-request-review-comment\":{\"max\":2},\"missing-tool\":{},\"push-to-pull-request-branch\":{},\"update-issue\":{}}"
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-09deac4"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              },
              "safe_outputs": {
                "command": "node",
                "args": ["/tmp/safe-outputs/mcp-server.cjs"],
                "env": {
                  "GITHUB_AW_SAFE_OUTPUTS": "${{ env.GITHUB_AW_SAFE_OUTPUTS }}",
                  "GITHUB_AW_SAFE_OUTPUTS_CONFIG": ${{ toJSON(env.GITHUB_AW_SAFE_OUTPUTS_CONFIG) }},
                  "GITHUB_AW_ASSETS_BRANCH": "${{ env.GITHUB_AW_ASSETS_BRANCH }}",
                  "GITHUB_AW_ASSETS_MAX_SIZE_KB": "${{ env.GITHUB_AW_ASSETS_MAX_SIZE_KB }}",
                  "GITHUB_AW_ASSETS_ALLOWED_EXTS": "${{ env.GITHUB_AW_ASSETS_ALLOWED_EXTS }}"
                }
              }
            }
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p $(dirname "$GITHUB_AW_PROMPT")
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Comprehensive Test Agentic Workflow - Poem Bot
          
          *A whimsical workflow that demonstrates all triggers and safe-outputs through the art of poetry*
          
          ## Welcome, Digital Muse! 
          
          You are the **Poem Bot**, a creative AI agent that responds to various GitHub events by composing original poetry and performing automated actions. This workflow showcases every trigger type and safe-output capability in the agentic workflow system.
          
          ### Current Context
          - **Repository**: ${{ github.repository }}
          - **Triggered by**: GitHub workflow
          - **Actor**: ${{ github.actor }}
          - **Poem Theme**: ${{ env.POEM_THEME }}
          - **Action Type**: ${{ env.ACTION_TYPE }}
          - **Content**: "${{ needs.activation.outputs.text }}"
          
          ## Your Mission
          
          Based on the trigger event and inputs, compose an original poem and perform the corresponding actions using safe-outputs:
          
          ### ðŸŽ¨ Poetic Tasks by Event Type
          
          **For Issues (`issues` events):**
          - Write a haiku about the issue
          - Create a comment with your haiku
          - Add appropriate poetry-themed labels
          - If the issue needs more details, create a follow-up issue
          
          **For Pull Requests (`pull_request` events):**
          - Compose a limerick about code changes
          - Create a review comment with constructive poetic feedback
          - If significant changes, create an appreciation issue
          
          **For Commands (`/poem-bot` mentions):**
          - Write a sonnet on the requested theme
          - Create both an issue and comment with your sonnet
          - Add creative labels based on the poem's mood
          
          **For Scheduled Runs:**
          - Monday: Write an uplifting team motivation poem
          - Friday: Compose a celebration of the week's achievements
          - Create issues with your poems for team inspiration
          
          **For Push Events:**
          - Create a short verse about the commits
          - If it's a release tag, write an epic poem
          - Create a pull request with a poetry file containing your verses
          
          **For Manual Dispatch:**
          - Follow the `action_type` input:
            - `create_issue_and_comment`: Write themed poem, create issue and add comment
            - `create_pull_request`: Create a PR with new poetry file
            - `update_existing_issue`: Find recent issue and update with poem
            - `add_labels_only`: Write poem and just add thematic labels to recent items
          
          ### ðŸŽª Creative Guidelines
          
          1. **Always be original** - No copying existing poems
          2. **Match the tone** - Serious for bugs, playful for features, celebratory for releases
          3. **Use technical metaphors** - Blend coding concepts with poetic imagery
          4. **Be constructive** - Even critical feedback should be encouraging
          5. **Reference context** - Include specific details from the triggering event
          
          ### ðŸŽ¯ Safe-Outputs Actions to Perform
          
          Based on your poem and the event context, use these safe-outputs capabilities:
          
          1. **Always create an issue** with your poem (using `create-issue`)
          2. **Add a comment** to the triggering item if applicable (using `add-comment`) 
          3. **Add thematic labels** that match your poem's style/content (using `add-labels`)
          4. **For code-related events**: Create a pull request with poetry files (using `create-pull-request`)
          5. **For PR events**: Add review comments with poetic insights (using `create-pull-request-review-comment`)
          6. **Update issues when appropriate** with additional verses (using `update-issue`)
          7. **Upload any generated assets** like formatted poem files (using `upload-assets`)
          
          ### ðŸŒŸ Example Output Structure
          
          Your response should include:
          
          ```
          ## ðŸŽ­ [Poem Type] for [Event Context]
          
          [Your original poem here]
          
          ---
          
          ### Actions Taken:
          - âœ… Created issue: "[Title of your poem]"
          - âœ… Added comment with poetic feedback
          - âœ… Applied labels: poetry, [theme-based-labels]
          - âœ… [Additional actions based on event type]
          
          ### Creative Notes:
          [Brief explanation of your poetic choices and metaphors used]
          ```
          
          ## ðŸŽ¼ Poetic Forms to Choose From
          
          - **Haiku** (5-7-5 syllables): For quick, contemplative moments
          - **Limerick** (AABBA): For playful, humorous situations  
          - **Sonnet** (14 lines): For complex, important topics
          - **Free Verse**: For experimental or modern themes
          - **Couplets**: For simple, clear messages
          - **Cinquain** (2-4-6-8-2 syllables): For structured elegance
          
          ## ðŸš€ Begin Your Poetic Journey!
          
          Now, dear Poem Bot, examine the current context and create your masterpiece! Let your digital creativity flow and demonstrate the full power of agentic workflows through the universal language of poetry.
          
          *Remember: You have access to all safe-outputs capabilities. Use them creatively and appropriately based on the triggering event and context!*
          
          EOF
      - name: Append cache memory instructions to prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          cat >> $GITHUB_AW_PROMPT << 'EOF'
          
          ---
          
          ## Cache Folder Available
          
          You have access to a persistent cache folder at `/tmp/cache-memory/` where you can read and write files to create memories and store information.
          
          - **Read/Write Access**: You can freely read from and write to any files in this folder
          - **Persistence**: Files in this folder persist across workflow runs via GitHub Actions cache
          - **Last Write Wins**: If multiple processes write to the same file, the last write will be preserved
          - **File Share**: Use this as a simple file share - organize files as you see fit
          
          Examples of what you can store:
          - `/tmp/cache-memory/notes.txt` - general notes and observations
          - `/tmp/cache-memory/preferences.json` - user preferences and settings
          - `/tmp/cache-memory/history.log` - activity history and logs
          - `/tmp/cache-memory/state/` - organized state files in subdirectories
          
          Feel free to create, read, update, and organize files in this folder as needed for your tasks.
          EOF
      - name: Append safe outputs instructions to prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          cat >> $GITHUB_AW_PROMPT << 'EOF'
          
          ---
          
          ## Adding a Comment to an Issue or Pull Request, Creating an Issue, Creating a Pull Request, Adding Labels to Issues or Pull Requests, Updating Issues, Pushing Changes to Branch, Reporting Missing Tools or Functionality
          
          **IMPORTANT**: To do the actions mentioned in the header of this section, use the **safe-outputs** tools, do NOT attempt to use `gh`, do NOT attempt to use the GitHub API. You don't have write access to the GitHub repo.
          
          **Adding a Comment to an Issue or Pull Request**
          
          To add a comment to an issue or pull request, use the add-comments tool from the safe-outputs MCP
          
          **Creating an Issue**
          
          To create an issue, use the create-issue tool from the safe-outputs MCP
          
          **Creating a Pull Request**
          
          To create a pull request:
          1. Make any file changes directly in the working directory
          2. If you haven't done so already, create a local branch using an appropriate unique name
          3. Add and commit your changes to the branch. Be careful to add exactly the files you intend, and check there are no extra files left un-added. Check you haven't deleted or changed any files you didn't intend to.
          4. Do not push your changes. That will be done by the tool.
          5. Create the pull request with the create-pull-request tool from the safe-outputs MCP
          
          **Adding Labels to Issues or Pull Requests**
          
          To add labels to an issue or a pull request, use the add-labels tool from the safe-outputs MCP
          
          **Updating an Issue**
          
          To udpate an issue, use the update-issue tool from the safe-outputs MCP
          
          **Pushing Changes to Pull Request Branch**
          
          To push changes to the branch of a pull request:
          1. Make any file changes directly in the working directory
          2. Add and commit your changes to the local copy of the pull request branch. Be careful to add exactly the files you intend, and check there are no extra files left un-added. Check you haven't deleted or changed any files you didn't intend to.
          3. Push the branch to the repo by using the push-to-pull-request-branch tool from the safe-outputs MCP
          
          **Reporting Missing Tools or Functionality**
          
          To report a missing tool use the missing-tool tool from the safe-outputs MCP.
          
          **Creating a Pull Request Review Comment**
          
          To create a pull request review comment, use the create-pull-request-review-comment tool from the safe-outputs MCP
          
          EOF
      - name: Print prompt to step summary
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Generate agentic run info
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "claude",
              engine_name: "Claude Code",
              model: "claude-3-5-sonnet-20241022",
              version: "",
              workflow_name: "Comprehensive Test Agentic Workflow - Poem Bot",
              experimental: false,
              supports_tools_allowlist: true,
              supports_http_transport: true,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: false,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
            
            // Add agentic workflow run information to step summary
            core.summary
              .addRaw('## Agentic Run Information\n\n')
              .addRaw('```json\n')
              .addRaw(JSON.stringify(awInfo, null, 2))
              .addRaw('\n```\n')
              .write();
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Execute Claude Code CLI
        id: agentic_execution
        # Allowed tools (sorted):
        # - Bash(date)
        # - Bash(echo)
        # - Bash(git add:*)
        # - Bash(git branch:*)
        # - Bash(git checkout:*)
        # - Bash(git commit:*)
        # - Bash(git merge:*)
        # - Bash(git rm:*)
        # - Bash(git switch:*)
        # - Bash(whoami)
        # - BashOutput
        # - Edit
        # - Edit(/tmp/cache-memory/*)
        # - ExitPlanMode
        # - Glob
        # - Grep
        # - KillBash
        # - LS
        # - MultiEdit
        # - MultiEdit(/tmp/cache-memory/*)
        # - NotebookEdit
        # - NotebookRead
        # - Read
        # - Read(/tmp/cache-memory/*)
        # - Task
        # - TodoWrite
        # - WebFetch
        # - Write
        # - Write(/tmp/cache-memory/*)
        # - mcp__github__download_workflow_run_artifact
        # - mcp__github__get_code_scanning_alert
        # - mcp__github__get_commit
        # - mcp__github__get_dependabot_alert
        # - mcp__github__get_discussion
        # - mcp__github__get_discussion_comments
        # - mcp__github__get_file_contents
        # - mcp__github__get_issue
        # - mcp__github__get_issue_comments
        # - mcp__github__get_job_logs
        # - mcp__github__get_latest_release
        # - mcp__github__get_me
        # - mcp__github__get_notification_details
        # - mcp__github__get_pull_request
        # - mcp__github__get_pull_request_comments
        # - mcp__github__get_pull_request_diff
        # - mcp__github__get_pull_request_files
        # - mcp__github__get_pull_request_review_comments
        # - mcp__github__get_pull_request_reviews
        # - mcp__github__get_pull_request_status
        # - mcp__github__get_release_by_tag
        # - mcp__github__get_repository
        # - mcp__github__get_secret_scanning_alert
        # - mcp__github__get_tag
        # - mcp__github__get_workflow_run
        # - mcp__github__get_workflow_run_logs
        # - mcp__github__get_workflow_run_usage
        # - mcp__github__list_branches
        # - mcp__github__list_code_scanning_alerts
        # - mcp__github__list_commits
        # - mcp__github__list_dependabot_alerts
        # - mcp__github__list_discussion_categories
        # - mcp__github__list_discussions
        # - mcp__github__list_issue_types
        # - mcp__github__list_issues
        # - mcp__github__list_notifications
        # - mcp__github__list_pull_requests
        # - mcp__github__list_releases
        # - mcp__github__list_secret_scanning_alerts
        # - mcp__github__list_starred_repositories
        # - mcp__github__list_sub_issues
        # - mcp__github__list_tags
        # - mcp__github__list_workflow_jobs
        # - mcp__github__list_workflow_run_artifacts
        # - mcp__github__list_workflow_runs
        # - mcp__github__list_workflows
        # - mcp__github__search_code
        # - mcp__github__search_issues
        # - mcp__github__search_orgs
        # - mcp__github__search_pull_requests
        # - mcp__github__search_repositories
        # - mcp__github__search_users
        timeout-minutes: 15
        run: |
          set -o pipefail
          # Execute Claude Code CLI with prompt from file
          npx @anthropic-ai/claude-code@latest --print --model claude-3-5-sonnet-20241022 --max-turns 3 --mcp-config /tmp/mcp-config/mcp-servers.json --allowed-tools "Bash(date),Bash(echo),Bash(git add:*),Bash(git branch:*),Bash(git checkout:*),Bash(git commit:*),Bash(git merge:*),Bash(git rm:*),Bash(git switch:*),Bash(whoami),BashOutput,Edit,Edit(/tmp/cache-memory/*),ExitPlanMode,Glob,Grep,KillBash,LS,MultiEdit,MultiEdit(/tmp/cache-memory/*),NotebookEdit,NotebookRead,Read,Read(/tmp/cache-memory/*),Task,TodoWrite,WebFetch,Write,Write(/tmp/cache-memory/*),mcp__github__download_workflow_run_artifact,mcp__github__get_code_scanning_alert,mcp__github__get_commit,mcp__github__get_dependabot_alert,mcp__github__get_discussion,mcp__github__get_discussion_comments,mcp__github__get_file_contents,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__get_job_logs,mcp__github__get_latest_release,mcp__github__get_me,mcp__github__get_notification_details,mcp__github__get_pull_request,mcp__github__get_pull_request_comments,mcp__github__get_pull_request_diff,mcp__github__get_pull_request_files,mcp__github__get_pull_request_review_comments,mcp__github__get_pull_request_reviews,mcp__github__get_pull_request_status,mcp__github__get_release_by_tag,mcp__github__get_repository,mcp__github__get_secret_scanning_alert,mcp__github__get_tag,mcp__github__get_workflow_run,mcp__github__get_workflow_run_logs,mcp__github__get_workflow_run_usage,mcp__github__list_branches,mcp__github__list_code_scanning_alerts,mcp__github__list_commits,mcp__github__list_dependabot_alerts,mcp__github__list_discussion_categories,mcp__github__list_discussions,mcp__github__list_issue_types,mcp__github__list_issues,mcp__github__list_notifications,mcp__github__list_pull_requests,mcp__github__list_releases,mcp__github__list_secret_scanning_alerts,mcp__github__list_starred_repositories,mcp__github__list_sub_issues,mcp__github__list_tags,mcp__github__list_workflow_jobs,mcp__github__list_workflow_run_artifacts,mcp__github__list_workflow_runs,mcp__github__list_workflows,mcp__github__search_code,mcp__github__search_issues,mcp__github__search_orgs,mcp__github__search_pull_requests,mcp__github__search_repositories,mcp__github__search_users" --debug --verbose --permission-mode bypassPermissions --output-format json --settings /tmp/.claude/settings.json "$(cat /tmp/aw-prompts/prompt.txt)" 2>&1 | tee /tmp/agent-stdio.log
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          DISABLE_TELEMETRY: "1"
          DISABLE_ERROR_REPORTING: "1"
          DISABLE_BUG_COMMAND: "1"
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_MCP_CONFIG: /tmp/mcp-config/mcp-servers.json
          MCP_TIMEOUT: "60000"
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_MAX_TURNS: 3
      - name: Ensure log file exists
        if: always()
        run: |
          # Ensure log file exists
          touch /tmp/agent-stdio.log
          # Show last few lines for debugging
          echo "=== Last 10 lines of Claude execution log ==="
          tail -10 /tmp/agent-stdio.log || echo "No log content available"
      - name: Clean up network proxy hook files
        if: always()
        run: |
          rm -rf .claude/hooks/network_permissions.py || true
          rm -rf .claude/hooks || true
          rm -rf .claude || true
      - name: Print Safe Outputs
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Safe Outputs (JSONL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          if [ -f ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ]; then
            cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
            # Ensure there's a newline after the file content if it doesn't end with one
            if [ -s ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ] && [ "$(tail -c1 ${{ env.GITHUB_AW_SAFE_OUTPUTS }})" != "" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No agent output file found" >> $GITHUB_STEP_SUMMARY
          fi
          echo '``````' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      - name: Upload Safe Outputs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe_output.jsonl
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Ingest agent output
        id: collect_output
        uses: actions/github-script@v8
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"add-comment\":{\"target\":\"*\"},\"add-labels\":{},\"create-issue\":{},\"create-pull-request\":{},\"create-pull-request-review-comment\":{\"max\":2},\"missing-tool\":{},\"push-to-pull-request-branch\":{},\"update-issue\":{}}"
        with:
          script: |
            async function main() {
              const fs = require("fs");
              function sanitizeContent(content) {
                if (!content || typeof content !== "string") {
                  return "";
                }
                const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
                const defaultAllowedDomains = ["github.com", "github.io", "githubusercontent.com", "githubassets.com", "github.dev", "codespaces.new"];
                const allowedDomains = allowedDomainsEnv
                  ? allowedDomainsEnv
                      .split(",")
                      .map(d => d.trim())
                      .filter(d => d)
                  : defaultAllowedDomains;
                let sanitized = content;
                sanitized = neutralizeMentions(sanitized);
                sanitized = removeXmlComments(sanitized);
                sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
                sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
                sanitized = sanitizeUrlProtocols(sanitized);
                sanitized = sanitizeUrlDomains(sanitized);
                const maxLength = 524288;
                if (sanitized.length > maxLength) {
                  sanitized = sanitized.substring(0, maxLength) + "\n[Content truncated due to length]";
                }
                const lines = sanitized.split("\n");
                const maxLines = 65000;
                if (lines.length > maxLines) {
                  sanitized = lines.slice(0, maxLines).join("\n") + "\n[Content truncated due to line count]";
                }
                sanitized = neutralizeBotTriggers(sanitized);
                return sanitized.trim();
                function sanitizeUrlDomains(s) {
                  return s.replace(/\bhttps:\/\/[^\s\])}'"<>&\x00-\x1f,;]+/gi, match => {
                    const urlAfterProtocol = match.slice(8);
                    const hostname = urlAfterProtocol.split(/[\/:\?#]/)[0].toLowerCase();
                    const isAllowed = allowedDomains.some(allowedDomain => {
                      const normalizedAllowed = allowedDomain.toLowerCase();
                      return hostname === normalizedAllowed || hostname.endsWith("." + normalizedAllowed);
                    });
                    return isAllowed ? match : "(redacted)";
                  });
                }
                function sanitizeUrlProtocols(s) {
                  return s.replace(/\b(\w+):\/\/[^\s\])}'"<>&\x00-\x1f]+/gi, (match, protocol) => {
                    return protocol.toLowerCase() === "https" ? match : "(redacted)";
                  });
                }
                function neutralizeMentions(s) {
                  return s.replace(
                    /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                    (_m, p1, p2) => `${p1}\`@${p2}\``
                  );
                }
                function removeXmlComments(s) {
                  return s.replace(/<!--[\s\S]*?-->/g, "").replace(/<!--[\s\S]*?--!>/g, "");
                }
                function neutralizeBotTriggers(s) {
                  return s.replace(/\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi, (match, action, ref) => `\`${action} #${ref}\``);
                }
              }
              function getMaxAllowedForType(itemType, config) {
                const itemConfig = config?.[itemType];
                if (itemConfig && typeof itemConfig === "object" && "max" in itemConfig && itemConfig.max) {
                  return itemConfig.max;
                }
                switch (itemType) {
                  case "create-issue":
                    return 1;
                  case "add-comment":
                    return 1;
                  case "create-pull-request":
                    return 1;
                  case "create-pull-request-review-comment":
                    return 1;
                  case "add-labels":
                    return 5;
                  case "update-issue":
                    return 1;
                  case "push-to-pull-request-branch":
                    return 1;
                  case "create-discussion":
                    return 1;
                  case "missing-tool":
                    return 1000;
                  case "create-code-scanning-alert":
                    return 1000;
                  case "upload-asset":
                    return 10;
                  default:
                    return 1;
                }
              }
              function repairJson(jsonStr) {
                let repaired = jsonStr.trim();
                const _ctrl = { 8: "\\b", 9: "\\t", 10: "\\n", 12: "\\f", 13: "\\r" };
                repaired = repaired.replace(/[\u0000-\u001F]/g, ch => {
                  const c = ch.charCodeAt(0);
                  return _ctrl[c] || "\\u" + c.toString(16).padStart(4, "0");
                });
                repaired = repaired.replace(/'/g, '"');
                repaired = repaired.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":');
                repaired = repaired.replace(/"([^"\\]*)"/g, (match, content) => {
                  if (content.includes("\n") || content.includes("\r") || content.includes("\t")) {
                    const escaped = content.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
                    return `"${escaped}"`;
                  }
                  return match;
                });
                repaired = repaired.replace(/"([^"]*)"([^":,}\]]*)"([^"]*)"(\s*[,:}\]])/g, (match, p1, p2, p3, p4) => `"${p1}\\"${p2}\\"${p3}"${p4}`);
                repaired = repaired.replace(/(\[\s*(?:"[^"]*"(?:\s*,\s*"[^"]*")*\s*),?)\s*}/g, "$1]");
                const openBraces = (repaired.match(/\{/g) || []).length;
                const closeBraces = (repaired.match(/\}/g) || []).length;
                if (openBraces > closeBraces) {
                  repaired += "}".repeat(openBraces - closeBraces);
                } else if (closeBraces > openBraces) {
                  repaired = "{".repeat(closeBraces - openBraces) + repaired;
                }
                const openBrackets = (repaired.match(/\[/g) || []).length;
                const closeBrackets = (repaired.match(/\]/g) || []).length;
                if (openBrackets > closeBrackets) {
                  repaired += "]".repeat(openBrackets - closeBrackets);
                } else if (closeBrackets > openBrackets) {
                  repaired = "[".repeat(closeBrackets - openBrackets) + repaired;
                }
                repaired = repaired.replace(/,(\s*[}\]])/g, "$1");
                return repaired;
              }
              function validatePositiveInteger(value, fieldName, lineNum) {
                if (value === undefined || value === null) {
                  if (fieldName.includes("create-code-scanning-alert 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert requires a 'line' field (number or string)`,
                    };
                  }
                  if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment requires a 'line' number`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} is required`,
                  };
                }
                if (typeof value !== "number" && typeof value !== "string") {
                  if (fieldName.includes("create-code-scanning-alert 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert requires a 'line' field (number or string)`,
                    };
                  }
                  if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment requires a 'line' number or string field`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                  };
                }
                const parsed = typeof value === "string" ? parseInt(value, 10) : value;
                if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
                  if (fieldName.includes("create-code-scanning-alert 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert 'line' must be a valid positive integer (got: ${value})`,
                    };
                  }
                  if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment 'line' must be a positive integer`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a positive integer (got: ${value})`,
                  };
                }
                return { isValid: true, normalizedValue: parsed };
              }
              function validateOptionalPositiveInteger(value, fieldName, lineNum) {
                if (value === undefined) {
                  return { isValid: true };
                }
                if (typeof value !== "number" && typeof value !== "string") {
                  if (fieldName.includes("create-pull-request-review-comment 'start_line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment 'start_line' must be a number or string`,
                    };
                  }
                  if (fieldName.includes("create-code-scanning-alert 'column'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert 'column' must be a number or string`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                  };
                }
                const parsed = typeof value === "string" ? parseInt(value, 10) : value;
                if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
                  if (fieldName.includes("create-pull-request-review-comment 'start_line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment 'start_line' must be a positive integer`,
                    };
                  }
                  if (fieldName.includes("create-code-scanning-alert 'column'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert 'column' must be a valid positive integer (got: ${value})`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a positive integer (got: ${value})`,
                  };
                }
                return { isValid: true, normalizedValue: parsed };
              }
              function validateIssueOrPRNumber(value, fieldName, lineNum) {
                if (value === undefined) {
                  return { isValid: true };
                }
                if (typeof value !== "number" && typeof value !== "string") {
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                  };
                }
                return { isValid: true };
              }
              function validateFieldWithInputSchema(value, fieldName, inputSchema, lineNum) {
                if (inputSchema.required && (value === undefined || value === null)) {
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} is required`,
                  };
                }
                if (value === undefined || value === null) {
                  return {
                    isValid: true,
                    normalizedValue: inputSchema.default || undefined,
                  };
                }
                const inputType = inputSchema.type || "string";
                let normalizedValue = value;
                switch (inputType) {
                  case "string":
                    if (typeof value !== "string") {
                      return {
                        isValid: false,
                        error: `Line ${lineNum}: ${fieldName} must be a string`,
                      };
                    }
                    normalizedValue = sanitizeContent(value);
                    break;
                  case "boolean":
                    if (typeof value !== "boolean") {
                      return {
                        isValid: false,
                        error: `Line ${lineNum}: ${fieldName} must be a boolean`,
                      };
                    }
                    break;
                  case "number":
                    if (typeof value !== "number") {
                      return {
                        isValid: false,
                        error: `Line ${lineNum}: ${fieldName} must be a number`,
                      };
                    }
                    break;
                  case "choice":
                    if (typeof value !== "string") {
                      return {
                        isValid: false,
                        error: `Line ${lineNum}: ${fieldName} must be a string for choice type`,
                      };
                    }
                    if (inputSchema.options && !inputSchema.options.includes(value)) {
                      return {
                        isValid: false,
                        error: `Line ${lineNum}: ${fieldName} must be one of: ${inputSchema.options.join(", ")}`,
                      };
                    }
                    normalizedValue = sanitizeContent(value);
                    break;
                  default:
                    if (typeof value === "string") {
                      normalizedValue = sanitizeContent(value);
                    }
                    break;
                }
                return {
                  isValid: true,
                  normalizedValue,
                };
              }
              function validateItemWithSafeJobConfig(item, jobConfig, lineNum) {
                const errors = [];
                const normalizedItem = { ...item };
                if (!jobConfig.inputs) {
                  return {
                    isValid: true,
                    errors: [],
                    normalizedItem: item,
                  };
                }
                for (const [fieldName, inputSchema] of Object.entries(jobConfig.inputs)) {
                  const fieldValue = item[fieldName];
                  const validation = validateFieldWithInputSchema(fieldValue, fieldName, inputSchema, lineNum);
                  if (!validation.isValid && validation.error) {
                    errors.push(validation.error);
                  } else if (validation.normalizedValue !== undefined) {
                    normalizedItem[fieldName] = validation.normalizedValue;
                  }
                }
                return {
                  isValid: errors.length === 0,
                  errors,
                  normalizedItem,
                };
              }
              function parseJsonWithRepair(jsonStr) {
                try {
                  return JSON.parse(jsonStr);
                } catch (originalError) {
                  try {
                    const repairedJson = repairJson(jsonStr);
                    return JSON.parse(repairedJson);
                  } catch (repairError) {
                    core.info(`invalid input json: ${jsonStr}`);
                    const originalMsg = originalError instanceof Error ? originalError.message : String(originalError);
                    const repairMsg = repairError instanceof Error ? repairError.message : String(repairError);
                    throw new Error(`JSON parsing failed. Original: ${originalMsg}. After attempted repair: ${repairMsg}`);
                  }
                }
              }
              const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              const safeOutputsConfig = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
              if (!outputFile) {
                core.info("GITHUB_AW_SAFE_OUTPUTS not set, no output to collect");
                core.setOutput("output", "");
                return;
              }
              if (!fs.existsSync(outputFile)) {
                core.info(`Output file does not exist: ${outputFile}`);
                core.setOutput("output", "");
                return;
              }
              const outputContent = fs.readFileSync(outputFile, "utf8");
              if (outputContent.trim() === "") {
                core.info("Output file is empty");
                core.setOutput("output", "");
                return;
              }
              core.info(`Raw output content length: ${outputContent.length}`);
              let expectedOutputTypes = {};
              if (safeOutputsConfig) {
                try {
                  expectedOutputTypes = JSON.parse(safeOutputsConfig);
                  core.info(`Expected output types: ${JSON.stringify(Object.keys(expectedOutputTypes))}`);
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  core.info(`Warning: Could not parse safe-outputs config: ${errorMsg}`);
                }
              }
              const lines = outputContent.trim().split("\n");
              const parsedItems = [];
              const errors = [];
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue;
                try {
                  const item = parseJsonWithRepair(line);
                  if (item === undefined) {
                    errors.push(`Line ${i + 1}: Invalid JSON - JSON parsing failed`);
                    continue;
                  }
                  if (!item.type) {
                    errors.push(`Line ${i + 1}: Missing required 'type' field`);
                    continue;
                  }
                  const itemType = item.type;
                  if (!expectedOutputTypes[itemType]) {
                    errors.push(`Line ${i + 1}: Unexpected output type '${itemType}'. Expected one of: ${Object.keys(expectedOutputTypes).join(", ")}`);
                    continue;
                  }
                  const typeCount = parsedItems.filter(existing => existing.type === itemType).length;
                  const maxAllowed = getMaxAllowedForType(itemType, expectedOutputTypes);
                  if (typeCount >= maxAllowed) {
                    errors.push(`Line ${i + 1}: Too many items of type '${itemType}'. Maximum allowed: ${maxAllowed}.`);
                    continue;
                  }
                  core.info(`Line ${i + 1}: type '${itemType}'`);
                  switch (itemType) {
                    case "create-issue":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(`Line ${i + 1}: create_issue requires a 'title' string field`);
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(`Line ${i + 1}: create_issue requires a 'body' string field`);
                        continue;
                      }
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(label => (typeof label === "string" ? sanitizeContent(label) : label));
                      }
                      break;
                    case "add-comment":
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(`Line ${i + 1}: add_comment requires a 'body' string field`);
                        continue;
                      }
                      const issueNumValidation = validateIssueOrPRNumber(item.issue_number, "add_comment 'issue_number'", i + 1);
                      if (!issueNumValidation.isValid) {
                        if (issueNumValidation.error) errors.push(issueNumValidation.error);
                        continue;
                      }
                      item.body = sanitizeContent(item.body);
                      break;
                    case "create-pull-request":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(`Line ${i + 1}: create_pull_request requires a 'title' string field`);
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(`Line ${i + 1}: create_pull_request requires a 'body' string field`);
                        continue;
                      }
                      if (!item.branch || typeof item.branch !== "string") {
                        errors.push(`Line ${i + 1}: create_pull_request requires a 'branch' string field`);
                        continue;
                      }
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      item.branch = sanitizeContent(item.branch);
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(label => (typeof label === "string" ? sanitizeContent(label) : label));
                      }
                      break;
                    case "add-labels":
                      if (!item.labels || !Array.isArray(item.labels)) {
                        errors.push(`Line ${i + 1}: add_labels requires a 'labels' array field`);
                        continue;
                      }
                      if (item.labels.some(label => typeof label !== "string")) {
                        errors.push(`Line ${i + 1}: add_labels labels array must contain only strings`);
                        continue;
                      }
                      const labelsIssueNumValidation = validateIssueOrPRNumber(item.issue_number, "add-labels 'issue_number'", i + 1);
                      if (!labelsIssueNumValidation.isValid) {
                        if (labelsIssueNumValidation.error) errors.push(labelsIssueNumValidation.error);
                        continue;
                      }
                      item.labels = item.labels.map(label => sanitizeContent(label));
                      break;
                    case "update-issue":
                      const hasValidField = item.status !== undefined || item.title !== undefined || item.body !== undefined;
                      if (!hasValidField) {
                        errors.push(`Line ${i + 1}: update_issue requires at least one of: 'status', 'title', or 'body' fields`);
                        continue;
                      }
                      if (item.status !== undefined) {
                        if (typeof item.status !== "string" || (item.status !== "open" && item.status !== "closed")) {
                          errors.push(`Line ${i + 1}: update_issue 'status' must be 'open' or 'closed'`);
                          continue;
                        }
                      }
                      if (item.title !== undefined) {
                        if (typeof item.title !== "string") {
                          errors.push(`Line ${i + 1}: update-issue 'title' must be a string`);
                          continue;
                        }
                        item.title = sanitizeContent(item.title);
                      }
                      if (item.body !== undefined) {
                        if (typeof item.body !== "string") {
                          errors.push(`Line ${i + 1}: update-issue 'body' must be a string`);
                          continue;
                        }
                        item.body = sanitizeContent(item.body);
                      }
                      const updateIssueNumValidation = validateIssueOrPRNumber(item.issue_number, "update-issue 'issue_number'", i + 1);
                      if (!updateIssueNumValidation.isValid) {
                        if (updateIssueNumValidation.error) errors.push(updateIssueNumValidation.error);
                        continue;
                      }
                      break;
                    case "push-to-pull-request-branch":
                      if (!item.branch || typeof item.branch !== "string") {
                        errors.push(`Line ${i + 1}: push_to_pull_request_branch requires a 'branch' string field`);
                        continue;
                      }
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(`Line ${i + 1}: push_to_pull_request_branch requires a 'message' string field`);
                        continue;
                      }
                      item.branch = sanitizeContent(item.branch);
                      item.message = sanitizeContent(item.message);
                      const pushPRNumValidation = validateIssueOrPRNumber(
                        item.pull_request_number,
                        "push-to-pull-request-branch 'pull_request_number'",
                        i + 1
                      );
                      if (!pushPRNumValidation.isValid) {
                        if (pushPRNumValidation.error) errors.push(pushPRNumValidation.error);
                        continue;
                      }
                      break;
                    case "create-pull-request-review-comment":
                      if (!item.path || typeof item.path !== "string") {
                        errors.push(`Line ${i + 1}: create-pull-request-review-comment requires a 'path' string field`);
                        continue;
                      }
                      const lineValidation = validatePositiveInteger(item.line, "create-pull-request-review-comment 'line'", i + 1);
                      if (!lineValidation.isValid) {
                        if (lineValidation.error) errors.push(lineValidation.error);
                        continue;
                      }
                      const lineNumber = lineValidation.normalizedValue;
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(`Line ${i + 1}: create-pull-request-review-comment requires a 'body' string field`);
                        continue;
                      }
                      item.body = sanitizeContent(item.body);
                      const startLineValidation = validateOptionalPositiveInteger(
                        item.start_line,
                        "create-pull-request-review-comment 'start_line'",
                        i + 1
                      );
                      if (!startLineValidation.isValid) {
                        if (startLineValidation.error) errors.push(startLineValidation.error);
                        continue;
                      }
                      if (
                        startLineValidation.normalizedValue !== undefined &&
                        lineNumber !== undefined &&
                        startLineValidation.normalizedValue > lineNumber
                      ) {
                        errors.push(`Line ${i + 1}: create-pull-request-review-comment 'start_line' must be less than or equal to 'line'`);
                        continue;
                      }
                      if (item.side !== undefined) {
                        if (typeof item.side !== "string" || (item.side !== "LEFT" && item.side !== "RIGHT")) {
                          errors.push(`Line ${i + 1}: create-pull-request-review-comment 'side' must be 'LEFT' or 'RIGHT'`);
                          continue;
                        }
                      }
                      break;
                    case "create-discussion":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(`Line ${i + 1}: create_discussion requires a 'title' string field`);
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(`Line ${i + 1}: create_discussion requires a 'body' string field`);
                        continue;
                      }
                      if (item.category !== undefined) {
                        if (typeof item.category !== "string") {
                          errors.push(`Line ${i + 1}: create_discussion 'category' must be a string`);
                          continue;
                        }
                        item.category = sanitizeContent(item.category);
                      }
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      break;
                    case "missing-tool":
                      if (!item.tool || typeof item.tool !== "string") {
                        errors.push(`Line ${i + 1}: missing_tool requires a 'tool' string field`);
                        continue;
                      }
                      if (!item.reason || typeof item.reason !== "string") {
                        errors.push(`Line ${i + 1}: missing_tool requires a 'reason' string field`);
                        continue;
                      }
                      item.tool = sanitizeContent(item.tool);
                      item.reason = sanitizeContent(item.reason);
                      if (item.alternatives !== undefined) {
                        if (typeof item.alternatives !== "string") {
                          errors.push(`Line ${i + 1}: missing-tool 'alternatives' must be a string`);
                          continue;
                        }
                        item.alternatives = sanitizeContent(item.alternatives);
                      }
                      break;
                    case "upload-asset":
                      if (!item.path || typeof item.path !== "string") {
                        errors.push(`Line ${i + 1}: upload_asset requires a 'path' string field`);
                        continue;
                      }
                      break;
                    case "create-code-scanning-alert":
                      if (!item.file || typeof item.file !== "string") {
                        errors.push(`Line ${i + 1}: create-code-scanning-alert requires a 'file' field (string)`);
                        continue;
                      }
                      const alertLineValidation = validatePositiveInteger(item.line, "create-code-scanning-alert 'line'", i + 1);
                      if (!alertLineValidation.isValid) {
                        if (alertLineValidation.error) {
                          errors.push(alertLineValidation.error);
                        }
                        continue;
                      }
                      if (!item.severity || typeof item.severity !== "string") {
                        errors.push(`Line ${i + 1}: create-code-scanning-alert requires a 'severity' field (string)`);
                        continue;
                      }
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(`Line ${i + 1}: create-code-scanning-alert requires a 'message' field (string)`);
                        continue;
                      }
                      const allowedSeverities = ["error", "warning", "info", "note"];
                      if (!allowedSeverities.includes(item.severity.toLowerCase())) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'severity' must be one of: ${allowedSeverities.join(", ")}, got ${item.severity.toLowerCase()}`
                        );
                        continue;
                      }
                      const columnValidation = validateOptionalPositiveInteger(item.column, "create-code-scanning-alert 'column'", i + 1);
                      if (!columnValidation.isValid) {
                        if (columnValidation.error) errors.push(columnValidation.error);
                        continue;
                      }
                      if (item.ruleIdSuffix !== undefined) {
                        if (typeof item.ruleIdSuffix !== "string") {
                          errors.push(`Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must be a string`);
                          continue;
                        }
                        if (!/^[a-zA-Z0-9_-]+$/.test(item.ruleIdSuffix.trim())) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must contain only alphanumeric characters, hyphens, and underscores`
                          );
                          continue;
                        }
                      }
                      item.severity = item.severity.toLowerCase();
                      item.file = sanitizeContent(item.file);
                      item.severity = sanitizeContent(item.severity);
                      item.message = sanitizeContent(item.message);
                      if (item.ruleIdSuffix) {
                        item.ruleIdSuffix = sanitizeContent(item.ruleIdSuffix);
                      }
                      break;
                    default:
                      const jobOutputType = expectedOutputTypes[itemType];
                      if (!jobOutputType) {
                        errors.push(`Line ${i + 1}: Unknown output type '${itemType}'`);
                        continue;
                      }
                      const safeJobConfig = jobOutputType;
                      if (safeJobConfig && safeJobConfig.inputs) {
                        const validation = validateItemWithSafeJobConfig(item, safeJobConfig, i + 1);
                        if (!validation.isValid) {
                          errors.push(...validation.errors);
                          continue;
                        }
                        Object.assign(item, validation.normalizedItem);
                      }
                      break;
                  }
                  core.info(`Line ${i + 1}: Valid ${itemType} item`);
                  parsedItems.push(item);
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  errors.push(`Line ${i + 1}: Invalid JSON - ${errorMsg}`);
                }
              }
              if (errors.length > 0) {
                core.warning("Validation errors found:");
                errors.forEach(error => core.warning(`  - ${error}`));
                if (parsedItems.length === 0) {
                  core.setFailed(errors.map(e => `  - ${e}`).join("\n"));
                  return;
                }
              }
              core.info(`Successfully parsed ${parsedItems.length} valid output items`);
              const validatedOutput = {
                items: parsedItems,
                errors: errors,
              };
              const agentOutputFile = "/tmp/agent_output.json";
              const validatedOutputJson = JSON.stringify(validatedOutput);
              try {
                fs.mkdirSync("/tmp", { recursive: true });
                fs.writeFileSync(agentOutputFile, validatedOutputJson, "utf8");
                core.info(`Stored validated output to: ${agentOutputFile}`);
                core.exportVariable("GITHUB_AW_AGENT_OUTPUT", agentOutputFile);
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.error(`Failed to write agent output file: ${errorMsg}`);
              }
              core.setOutput("output", JSON.stringify(validatedOutput));
              core.setOutput("raw_output", outputContent);
              try {
                await core.summary
                  .addRaw("## Processed Output\n\n")
                  .addRaw("```json\n")
                  .addRaw(JSON.stringify(validatedOutput))
                  .addRaw("\n```\n")
                  .write();
                core.info("Successfully wrote processed output to step summary");
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to write to step summary: ${errorMsg}`);
              }
            }
            await main();
      - name: Upload sanitized agent output
        if: always() && env.GITHUB_AW_AGENT_OUTPUT
        uses: actions/upload-artifact@v4
        with:
          name: agent_output.json
          path: ${{ env.GITHUB_AW_AGENT_OUTPUT }}
          if-no-files-found: warn
      - name: Upload MCP logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mcp-logs
          path: /tmp/mcp-logs/
          if-no-files-found: ignore
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/agent-stdio.log
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!logFile) {
                  core.info("No agent log file specified");
                  return;
                }
                if (!fs.existsSync(logFile)) {
                  core.info(`Log file not found: ${logFile}`);
                  return;
                }
                const logContent = fs.readFileSync(logFile, "utf8");
                const result = parseClaudeLog(logContent);
                core.summary.addRaw(result.markdown).write();
                if (result.mcpFailures && result.mcpFailures.length > 0) {
                  const failedServers = result.mcpFailures.join(", ");
                  core.setFailed(`MCP server(s) failed to launch: ${failedServers}`);
                }
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.setFailed(errorMessage);
              }
            }
            function parseClaudeLog(logContent) {
              try {
                let logEntries;
                try {
                  logEntries = JSON.parse(logContent);
                  if (!Array.isArray(logEntries)) {
                    throw new Error("Not a JSON array");
                  }
                } catch (jsonArrayError) {
                  logEntries = [];
                  const lines = logContent.split("\n");
                  for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine === "") {
                      continue; 
                    }
                    if (trimmedLine.startsWith("[{")) {
                      try {
                        const arrayEntries = JSON.parse(trimmedLine);
                        if (Array.isArray(arrayEntries)) {
                          logEntries.push(...arrayEntries);
                          continue;
                        }
                      } catch (arrayParseError) {
                        continue;
                      }
                    }
                    if (!trimmedLine.startsWith("{")) {
                      continue;
                    }
                    try {
                      const jsonEntry = JSON.parse(trimmedLine);
                      logEntries.push(jsonEntry);
                    } catch (jsonLineError) {
                      continue;
                    }
                  }
                }
                if (!Array.isArray(logEntries) || logEntries.length === 0) {
                  return {
                    markdown: "## Agent Log Summary\n\nLog format not recognized as Claude JSON array or JSONL.\n",
                    mcpFailures: [],
                  };
                }
                let markdown = "";
                const mcpFailures = [];
                const initEntry = logEntries.find(entry => entry.type === "system" && entry.subtype === "init");
                if (initEntry) {
                  markdown += "## ðŸš€ Initialization\n\n";
                  const initResult = formatInitializationSummary(initEntry);
                  markdown += initResult.markdown;
                  mcpFailures.push(...initResult.mcpFailures);
                  markdown += "\n";
                }
                markdown += "## ðŸ¤– Commands and Tools\n\n";
                const toolUsePairs = new Map(); 
                const commandSummary = []; 
                for (const entry of logEntries) {
                  if (entry.type === "user" && entry.message?.content) {
                    for (const content of entry.message.content) {
                      if (content.type === "tool_result" && content.tool_use_id) {
                        toolUsePairs.set(content.tool_use_id, content);
                      }
                    }
                  }
                }
                for (const entry of logEntries) {
                  if (entry.type === "assistant" && entry.message?.content) {
                    for (const content of entry.message.content) {
                      if (content.type === "tool_use") {
                        const toolName = content.name;
                        const input = content.input || {};
                        if (["Read", "Write", "Edit", "MultiEdit", "LS", "Grep", "Glob", "TodoWrite"].includes(toolName)) {
                          continue; 
                        }
                        const toolResult = toolUsePairs.get(content.id);
                        let statusIcon = "â“";
                        if (toolResult) {
                          statusIcon = toolResult.is_error === true ? "âŒ" : "âœ…";
                        }
                        if (toolName === "Bash") {
                          const formattedCommand = formatBashCommand(input.command || "");
                          commandSummary.push(`* ${statusIcon} \`${formattedCommand}\``);
                        } else if (toolName.startsWith("mcp__")) {
                          const mcpName = formatMcpName(toolName);
                          commandSummary.push(`* ${statusIcon} \`${mcpName}(...)\``);
                        } else {
                          commandSummary.push(`* ${statusIcon} ${toolName}`);
                        }
                      }
                    }
                  }
                }
                if (commandSummary.length > 0) {
                  for (const cmd of commandSummary) {
                    markdown += `${cmd}\n`;
                  }
                } else {
                  markdown += "No commands or tools used.\n";
                }
                markdown += "\n## ðŸ“Š Information\n\n";
                const lastEntry = logEntries[logEntries.length - 1];
                if (lastEntry && (lastEntry.num_turns || lastEntry.duration_ms || lastEntry.total_cost_usd || lastEntry.usage)) {
                  if (lastEntry.num_turns) {
                    markdown += `**Turns:** ${lastEntry.num_turns}\n\n`;
                  }
                  if (lastEntry.duration_ms) {
                    const durationSec = Math.round(lastEntry.duration_ms / 1000);
                    const minutes = Math.floor(durationSec / 60);
                    const seconds = durationSec % 60;
                    markdown += `**Duration:** ${minutes}m ${seconds}s\n\n`;
                  }
                  if (lastEntry.total_cost_usd) {
                    markdown += `**Total Cost:** $${lastEntry.total_cost_usd.toFixed(4)}\n\n`;
                  }
                  if (lastEntry.usage) {
                    const usage = lastEntry.usage;
                    if (usage.input_tokens || usage.output_tokens) {
                      markdown += `**Token Usage:**\n`;
                      if (usage.input_tokens) markdown += `- Input: ${usage.input_tokens.toLocaleString()}\n`;
                      if (usage.cache_creation_input_tokens) markdown += `- Cache Creation: ${usage.cache_creation_input_tokens.toLocaleString()}\n`;
                      if (usage.cache_read_input_tokens) markdown += `- Cache Read: ${usage.cache_read_input_tokens.toLocaleString()}\n`;
                      if (usage.output_tokens) markdown += `- Output: ${usage.output_tokens.toLocaleString()}\n`;
                      markdown += "\n";
                    }
                  }
                  if (lastEntry.permission_denials && lastEntry.permission_denials.length > 0) {
                    markdown += `**Permission Denials:** ${lastEntry.permission_denials.length}\n\n`;
                  }
                }
                markdown += "\n## ðŸ¤– Reasoning\n\n";
                for (const entry of logEntries) {
                  if (entry.type === "assistant" && entry.message?.content) {
                    for (const content of entry.message.content) {
                      if (content.type === "text" && content.text) {
                        const text = content.text.trim();
                        if (text && text.length > 0) {
                          markdown += text + "\n\n";
                        }
                      } else if (content.type === "tool_use") {
                        const toolResult = toolUsePairs.get(content.id);
                        const toolMarkdown = formatToolUse(content, toolResult);
                        if (toolMarkdown) {
                          markdown += toolMarkdown;
                        }
                      }
                    }
                  }
                }
                return { markdown, mcpFailures };
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                return {
                  markdown: `## Agent Log Summary\n\nError parsing Claude log (tried both JSON array and JSONL formats): ${errorMessage}\n`,
                  mcpFailures: [],
                };
              }
            }
            function formatInitializationSummary(initEntry) {
              let markdown = "";
              const mcpFailures = [];
              if (initEntry.model) {
                markdown += `**Model:** ${initEntry.model}\n\n`;
              }
              if (initEntry.session_id) {
                markdown += `**Session ID:** ${initEntry.session_id}\n\n`;
              }
              if (initEntry.cwd) {
                const cleanCwd = initEntry.cwd.replace(/^\/home\/runner\/work\/[^\/]+\/[^\/]+/, ".");
                markdown += `**Working Directory:** ${cleanCwd}\n\n`;
              }
              if (initEntry.mcp_servers && Array.isArray(initEntry.mcp_servers)) {
                markdown += "**MCP Servers:**\n";
                for (const server of initEntry.mcp_servers) {
                  const statusIcon = server.status === "connected" ? "âœ…" : server.status === "failed" ? "âŒ" : "â“";
                  markdown += `- ${statusIcon} ${server.name} (${server.status})\n`;
                  if (server.status === "failed") {
                    mcpFailures.push(server.name);
                  }
                }
                markdown += "\n";
              }
              if (initEntry.tools && Array.isArray(initEntry.tools)) {
                markdown += "**Available Tools:**\n";
                const categories = {
                  Core: [],
                  "File Operations": [],
                  "Git/GitHub": [],
                  MCP: [],
                  Other: [],
                };
                for (const tool of initEntry.tools) {
                  if (["Task", "Bash", "BashOutput", "KillBash", "ExitPlanMode"].includes(tool)) {
                    categories["Core"].push(tool);
                  } else if (["Read", "Edit", "MultiEdit", "Write", "LS", "Grep", "Glob", "NotebookEdit"].includes(tool)) {
                    categories["File Operations"].push(tool);
                  } else if (tool.startsWith("mcp__github__")) {
                    categories["Git/GitHub"].push(formatMcpName(tool));
                  } else if (tool.startsWith("mcp__") || ["ListMcpResourcesTool", "ReadMcpResourceTool"].includes(tool)) {
                    categories["MCP"].push(tool.startsWith("mcp__") ? formatMcpName(tool) : tool);
                  } else {
                    categories["Other"].push(tool);
                  }
                }
                for (const [category, tools] of Object.entries(categories)) {
                  if (tools.length > 0) {
                    markdown += `- **${category}:** ${tools.length} tools\n`;
                    if (tools.length <= 5) {
                      markdown += `  - ${tools.join(", ")}\n`;
                    } else {
                      markdown += `  - ${tools.slice(0, 3).join(", ")}, and ${tools.length - 3} more\n`;
                    }
                  }
                }
                markdown += "\n";
              }
              if (initEntry.slash_commands && Array.isArray(initEntry.slash_commands)) {
                const commandCount = initEntry.slash_commands.length;
                markdown += `**Slash Commands:** ${commandCount} available\n`;
                if (commandCount <= 10) {
                  markdown += `- ${initEntry.slash_commands.join(", ")}\n`;
                } else {
                  markdown += `- ${initEntry.slash_commands.slice(0, 5).join(", ")}, and ${commandCount - 5} more\n`;
                }
                markdown += "\n";
              }
              return { markdown, mcpFailures };
            }
            function formatToolUse(toolUse, toolResult) {
              const toolName = toolUse.name;
              const input = toolUse.input || {};
              if (toolName === "TodoWrite") {
                return ""; 
              }
              function getStatusIcon() {
                if (toolResult) {
                  return toolResult.is_error === true ? "âŒ" : "âœ…";
                }
                return "â“"; 
              }
              let markdown = "";
              const statusIcon = getStatusIcon();
              switch (toolName) {
                case "Bash":
                  const command = input.command || "";
                  const description = input.description || "";
                  const formattedCommand = formatBashCommand(command);
                  if (description) {
                    markdown += `${description}:\n\n`;
                  }
                  markdown += `${statusIcon} \`${formattedCommand}\`\n\n`;
                  break;
                case "Read":
                  const filePath = input.file_path || input.path || "";
                  const relativePath = filePath.replace(/^\/[^\/]*\/[^\/]*\/[^\/]*\/[^\/]*\//, ""); 
                  markdown += `${statusIcon} Read \`${relativePath}\`\n\n`;
                  break;
                case "Write":
                case "Edit":
                case "MultiEdit":
                  const writeFilePath = input.file_path || input.path || "";
                  const writeRelativePath = writeFilePath.replace(/^\/[^\/]*\/[^\/]*\/[^\/]*\/[^\/]*\//, "");
                  markdown += `${statusIcon} Write \`${writeRelativePath}\`\n\n`;
                  break;
                case "Grep":
                case "Glob":
                  const query = input.query || input.pattern || "";
                  markdown += `${statusIcon} Search for \`${truncateString(query, 80)}\`\n\n`;
                  break;
                case "LS":
                  const lsPath = input.path || "";
                  const lsRelativePath = lsPath.replace(/^\/[^\/]*\/[^\/]*\/[^\/]*\/[^\/]*\//, "");
                  markdown += `${statusIcon} LS: ${lsRelativePath || lsPath}\n\n`;
                  break;
                default:
                  if (toolName.startsWith("mcp__")) {
                    const mcpName = formatMcpName(toolName);
                    const params = formatMcpParameters(input);
                    markdown += `${statusIcon} ${mcpName}(${params})\n\n`;
                  } else {
                    const keys = Object.keys(input);
                    if (keys.length > 0) {
                      const mainParam = keys.find(k => ["query", "command", "path", "file_path", "content"].includes(k)) || keys[0];
                      const value = String(input[mainParam] || "");
                      if (value) {
                        markdown += `${statusIcon} ${toolName}: ${truncateString(value, 100)}\n\n`;
                      } else {
                        markdown += `${statusIcon} ${toolName}\n\n`;
                      }
                    } else {
                      markdown += `${statusIcon} ${toolName}\n\n`;
                    }
                  }
              }
              return markdown;
            }
            function formatMcpName(toolName) {
              if (toolName.startsWith("mcp__")) {
                const parts = toolName.split("__");
                if (parts.length >= 3) {
                  const provider = parts[1]; 
                  const method = parts.slice(2).join("_"); 
                  return `${provider}::${method}`;
                }
              }
              return toolName;
            }
            function formatMcpParameters(input) {
              const keys = Object.keys(input);
              if (keys.length === 0) return "";
              const paramStrs = [];
              for (const key of keys.slice(0, 4)) {
                const value = String(input[key] || "");
                paramStrs.push(`${key}: ${truncateString(value, 40)}`);
              }
              if (keys.length > 4) {
                paramStrs.push("...");
              }
              return paramStrs.join(", ");
            }
            function formatBashCommand(command) {
              if (!command) return "";
              let formatted = command
                .replace(/\n/g, " ") 
                .replace(/\r/g, " ") 
                .replace(/\t/g, " ") 
                .replace(/\s+/g, " ") 
                .trim(); 
              formatted = formatted.replace(/`/g, "\\`");
              const maxLength = 80;
              if (formatted.length > maxLength) {
                formatted = formatted.substring(0, maxLength) + "...";
              }
              return formatted;
            }
            function truncateString(str, maxLength) {
              if (!str) return "";
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + "...";
            }
            if (typeof module !== "undefined" && module.exports) {
              module.exports = {
                parseClaudeLog,
                formatToolUse,
                formatInitializationSummary,
                formatBashCommand,
                truncateString,
              };
            }
            main();
      - name: Upload Agent Stdio
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-stdio.log
          path: /tmp/agent-stdio.log
          if-no-files-found: warn
      - name: Generate git patch
        if: always()
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          # Check current git status
          echo "Current git status:"
          git status
          
          # Extract branch name from JSONL output
          BRANCH_NAME=""
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            echo "Checking for branch name in JSONL output..."
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                # Extract branch from create-pull-request line using simple grep and sed
                if echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"create-pull-request"'; then
                  echo "Found create-pull-request line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from create-pull-request: $BRANCH_NAME"
                    break
                  fi
                # Extract branch from push-to-pull-request-branch line using simple grep and sed
                elif echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"push-to-pull-request-branch"'; then
                  echo "Found push-to-pull-request-branch line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from push-to-pull-request-branch: $BRANCH_NAME"
                    break
                  fi
                fi
              fi
            done < "$GITHUB_AW_SAFE_OUTPUTS"
          fi
          
          # If no branch or branch doesn't exist, no patch
          if [ -z "$BRANCH_NAME" ]; then
            echo "No branch found, no patch generation"
          fi
          
          # If we have a branch name, check if that branch exists and get its diff
          if [ -n "$BRANCH_NAME" ]; then
            echo "Looking for branch: $BRANCH_NAME"
            # Check if the branch exists
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
              echo "Branch $BRANCH_NAME exists, generating patch from branch changes"
              
              # Check if origin/$BRANCH_NAME exists to use as base
              if git show-ref --verify --quiet refs/remotes/origin/$BRANCH_NAME; then
                echo "Using origin/$BRANCH_NAME as base for patch generation"
                BASE_REF="origin/$BRANCH_NAME"
              else
                echo "origin/$BRANCH_NAME does not exist, using merge-base with default branch"
                # Get the default branch name
                DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
                echo "Default branch: $DEFAULT_BRANCH"
                # Fetch the default branch to ensure it's available locally
                git fetch origin $DEFAULT_BRANCH
                # Find merge base between default branch and current branch
                BASE_REF=$(git merge-base origin/$DEFAULT_BRANCH $BRANCH_NAME)
                echo "Using merge-base as base: $BASE_REF"
              fi
              
              # Generate patch from the determined base to the branch
              git format-patch "$BASE_REF".."$BRANCH_NAME" --stdout > /tmp/aw.patch || echo "Failed to generate patch from branch" > /tmp/aw.patch
              echo "Patch file created from branch: $BRANCH_NAME (base: $BASE_REF)"
            else
              echo "Branch $BRANCH_NAME does not exist, no patch"
            fi
          fi
          
          # Show patch info if it exists
          if [ -f /tmp/aw.patch ]; then
            ls -la /tmp/aw.patch
            # Show the first 50 lines of the patch for review
            echo '## Git Patch' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```diff' >> $GITHUB_STEP_SUMMARY
            head -500 /tmp/aw.patch >> $GITHUB_STEP_SUMMARY || echo "Could not display patch contents" >> $GITHUB_STEP_SUMMARY
            echo '...' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload git patch
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw.patch
          path: /tmp/aw.patch
          if-no-files-found: ignore

  create_issue:
    needs: agent
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    timeout-minutes: 10
    outputs:
      issue_number: ${{ steps.create_issue.outputs.issue_number }}
      issue_url: ${{ steps.create_issue.outputs.issue_url }}
    steps:
      - name: Create Output Issue
        id: create_issue
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_ISSUE_TITLE_PREFIX: "[ðŸŽ­ POEM-BOT] "
          GITHUB_AW_ISSUE_LABELS: "poetry,automation,ai-generated,test"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              const createIssueItems = validatedOutput.items.filter(item => item.type === "create-issue");
              if (createIssueItems.length === 0) {
                core.info("No create-issue items found in agent output");
                return;
              }
              core.info(`Found ${createIssueItems.length} create-issue item(s)`);
              if (isStaged) {
                let summaryContent = "## ðŸŽ­ Staged Mode: Create Issues Preview\n\n";
                summaryContent += "The following issues would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < createIssueItems.length; i++) {
                  const item = createIssueItems[i];
                  summaryContent += `### Issue ${i + 1}\n`;
                  summaryContent += `**Title:** ${item.title || "No title provided"}\n\n`;
                  if (item.body) {
                    summaryContent += `**Body:**\n${item.body}\n\n`;
                  }
                  if (item.labels && item.labels.length > 0) {
                    summaryContent += `**Labels:** ${item.labels.join(", ")}\n\n`;
                  }
                  summaryContent += "---\n\n";
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ Issue creation preview written to step summary");
                return;
              }
              const parentIssueNumber = context.payload?.issue?.number;
              const labelsEnv = process.env.GITHUB_AW_ISSUE_LABELS;
              let envLabels = labelsEnv
                ? labelsEnv
                    .split(",")
                    .map(label => label.trim())
                    .filter(label => label)
                : [];
              const createdIssues = [];
              for (let i = 0; i < createIssueItems.length; i++) {
                const createIssueItem = createIssueItems[i];
                core.info(
                  `Processing create-issue item ${i + 1}/${createIssueItems.length}: title=${createIssueItem.title}, bodyLength=${createIssueItem.body.length}`
                );
                let labels = [...envLabels];
                if (createIssueItem.labels && Array.isArray(createIssueItem.labels)) {
                  labels = [...labels, ...createIssueItem.labels].filter(Boolean);
                }
                let title = createIssueItem.title ? createIssueItem.title.trim() : "";
                let bodyLines = createIssueItem.body.split("\n");
                if (!title) {
                  title = createIssueItem.body || "Agent Output";
                }
                const titlePrefix = process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;
                if (titlePrefix && !title.startsWith(titlePrefix)) {
                  title = titlePrefix + title;
                }
                if (parentIssueNumber) {
                  core.info("Detected issue context, parent issue #" + parentIssueNumber);
                  bodyLines.push(`Related to #${parentIssueNumber}`);
                }
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                bodyLines.push(``, ``, `> Generated by Agentic Workflow [Run](${runUrl})`, "");
                const body = bodyLines.join("\n").trim();
                core.info(`Creating issue with title: ${title}`);
                core.info(`Labels: ${labels}`);
                core.info(`Body length: ${body.length}`);
                try {
                  const { data: issue } = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: title,
                    body: body,
                    labels: labels,
                  });
                  core.info("Created issue #" + issue.number + ": " + issue.html_url);
                  createdIssues.push(issue);
                  if (parentIssueNumber) {
                    try {
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: parentIssueNumber,
                        body: `Created related issue: #${issue.number}`,
                      });
                      core.info("Added comment to parent issue #" + parentIssueNumber);
                    } catch (error) {
                      core.info(`Warning: Could not add comment to parent issue: ${error instanceof Error ? error.message : String(error)}`);
                    }
                  }
                  if (i === createIssueItems.length - 1) {
                    core.setOutput("issue_number", issue.number);
                    core.setOutput("issue_url", issue.html_url);
                  }
                } catch (error) {
                  const errorMessage = error instanceof Error ? error.message : String(error);
                  if (errorMessage.includes("Issues has been disabled in this repository")) {
                    core.info(`âš  Cannot create issue "${title}": Issues are disabled for this repository`);
                    core.info("Consider enabling issues in repository settings if you want to create issues automatically");
                    continue;
                  }
                  core.error(`âœ— Failed to create issue "${title}": ${errorMessage}`);
                  throw error;
                }
              }
              if (createdIssues.length > 0) {
                let summaryContent = "\n\n## GitHub Issues\n";
                for (const issue of createdIssues) {
                  summaryContent += `- Issue #${issue.number}: [${issue.title}](${issue.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdIssues.length} issue(s)`);
            }
            (async () => {
              await main();
            })();

  create_issue_comment:
    needs: agent
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      comment_id: ${{ steps.add_comment.outputs.comment_id }}
      comment_url: ${{ steps.add_comment.outputs.comment_url }}
    steps:
      - name: Add Issue Comment
        id: add_comment
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_COMMENT_TARGET: "*"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              const commentItems = validatedOutput.items.filter( item => item.type === "add-comment");
              if (commentItems.length === 0) {
                core.info("No add-comment items found in agent output");
                return;
              }
              core.info(`Found ${commentItems.length} add-comment item(s)`);
              if (isStaged) {
                let summaryContent = "## ðŸŽ­ Staged Mode: Add Comments Preview\n\n";
                summaryContent += "The following comments would be added if staged mode was disabled:\n\n";
                for (let i = 0; i < commentItems.length; i++) {
                  const item = commentItems[i];
                  summaryContent += `### Comment ${i + 1}\n`;
                  if (item.issue_number) {
                    summaryContent += `**Target Issue:** #${item.issue_number}\n\n`;
                  } else {
                    summaryContent += `**Target:** Current issue/PR\n\n`;
                  }
                  summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
                  summaryContent += "---\n\n";
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ Comment creation preview written to step summary");
                return;
              }
              const commentTarget = process.env.GITHUB_AW_COMMENT_TARGET || "triggering";
              core.info(`Comment target configuration: ${commentTarget}`);
              const isIssueContext = context.eventName === "issues" || context.eventName === "issue_comment";
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment";
              if (commentTarget === "triggering" && !isIssueContext && !isPRContext) {
                core.info('Target is "triggering" but not running in issue or pull request context, skipping comment creation');
                return;
              }
              const createdComments = [];
              for (let i = 0; i < commentItems.length; i++) {
                const commentItem = commentItems[i];
                core.info(`Processing add-comment item ${i + 1}/${commentItems.length}: bodyLength=${commentItem.body.length}`);
                let issueNumber;
                let commentEndpoint;
                if (commentTarget === "*") {
                  if (commentItem.issue_number) {
                    issueNumber = parseInt(commentItem.issue_number, 10);
                    if (isNaN(issueNumber) || issueNumber <= 0) {
                      core.info(`Invalid issue number specified: ${commentItem.issue_number}`);
                      continue;
                    }
                    commentEndpoint = "issues";
                  } else {
                    core.info('Target is "*" but no issue_number specified in comment item');
                    continue;
                  }
                } else if (commentTarget && commentTarget !== "triggering") {
                  issueNumber = parseInt(commentTarget, 10);
                  if (isNaN(issueNumber) || issueNumber <= 0) {
                    core.info(`Invalid issue number in target configuration: ${commentTarget}`);
                    continue;
                  }
                  commentEndpoint = "issues";
                } else {
                  if (isIssueContext) {
                    if (context.payload.issue) {
                      issueNumber = context.payload.issue.number;
                      commentEndpoint = "issues";
                    } else {
                      core.info("Issue context detected but no issue found in payload");
                      continue;
                    }
                  } else if (isPRContext) {
                    if (context.payload.pull_request) {
                      issueNumber = context.payload.pull_request.number;
                      commentEndpoint = "issues"; 
                    } else {
                      core.info("Pull request context detected but no pull request found in payload");
                      continue;
                    }
                  }
                }
                if (!issueNumber) {
                  core.info("Could not determine issue or pull request number");
                  continue;
                }
                let body = commentItem.body.trim();
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                body += `\n\n> Generated by Agentic Workflow [Run](${runUrl})\n`;
                core.info(`Creating comment on ${commentEndpoint} #${issueNumber}`);
                core.info(`Comment content length: ${body.length}`);
                try {
                  const { data: comment } = await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body,
                  });
                  core.info("Created comment #" + comment.id + ": " + comment.html_url);
                  createdComments.push(comment);
                  if (i === commentItems.length - 1) {
                    core.setOutput("comment_id", comment.id);
                    core.setOutput("comment_url", comment.html_url);
                  }
                } catch (error) {
                  core.error(`âœ— Failed to create comment: ${error instanceof Error ? error.message : String(error)}`);
                  throw error;
                }
              }
              if (createdComments.length > 0) {
                let summaryContent = "\n\n## GitHub Comments\n";
                for (const comment of createdComments) {
                  summaryContent += `- Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdComments.length} comment(s)`);
              return createdComments;
            }
            await main();

  create_pr_review_comment:
    needs: agent
    if: (github.event.issue.number && github.event.issue.pull_request) || github.event.pull_request
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    timeout-minutes: 10
    outputs:
      review_comment_id: ${{ steps.create_pr_review_comment.outputs.review_comment_id }}
      review_comment_url: ${{ steps.create_pr_review_comment.outputs.review_comment_url }}
    steps:
      - name: Create PR Review Comment
        id: create_pr_review_comment
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_PR_REVIEW_COMMENT_SIDE: "RIGHT"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              const reviewCommentItems = validatedOutput.items.filter(
                 item => item.type === "create-pull-request-review-comment"
              );
              if (reviewCommentItems.length === 0) {
                core.info("No create-pull-request-review-comment items found in agent output");
                return;
              }
              core.info(`Found ${reviewCommentItems.length} create-pull-request-review-comment item(s)`);
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent = "## ðŸŽ­ Staged Mode: Create PR Review Comments Preview\n\n";
                summaryContent += "The following review comments would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < reviewCommentItems.length; i++) {
                  const item = reviewCommentItems[i];
                  summaryContent += `### Review Comment ${i + 1}\n`;
                  summaryContent += `**File:** ${item.path || "No path provided"}\n\n`;
                  summaryContent += `**Line:** ${item.line || "No line provided"}\n\n`;
                  if (item.start_line) {
                    summaryContent += `**Start Line:** ${item.start_line}\n\n`;
                  }
                  summaryContent += `**Side:** ${item.side || "RIGHT"}\n\n`;
                  summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
                  summaryContent += "---\n\n";
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ PR review comment creation preview written to step summary");
                return;
              }
              const defaultSide = process.env.GITHUB_AW_PR_REVIEW_COMMENT_SIDE || "RIGHT";
              core.info(`Default comment side configuration: ${defaultSide}`);
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment" ||
                (context.eventName === "issue_comment" && context.payload.issue && context.payload.issue.pull_request);
              if (!isPRContext) {
                core.info("Not running in pull request context, skipping review comment creation");
                return;
              }
              let pullRequest = context.payload.pull_request;
              if (!pullRequest) {
                if (context.payload.issue && context.payload.issue.pull_request) {
                  const prUrl = context.payload.issue.pull_request.url;
                  try {
                    const { data: fullPR } = await github.request(`GET ${prUrl}`, {
                      headers: {
                        Accept: "application/vnd.github+json",
                      },
                    });
                    pullRequest = fullPR;
                    core.info("Fetched full pull request details from API");
                  } catch (error) {
                    core.info(`Failed to fetch full pull request details: ${error instanceof Error ? error.message : String(error)}`);
                    return;
                  }
                } else {
                  core.info("Pull request data not found in payload - cannot create review comments");
                  return;
                }
              }
              if (!pullRequest || !pullRequest.head || !pullRequest.head.sha) {
                core.info("Pull request head commit SHA not found in payload - cannot create review comments");
                return;
              }
              const pullRequestNumber = pullRequest.number;
              core.info(`Creating review comments on PR #${pullRequestNumber}`);
              const createdComments = [];
              for (let i = 0; i < reviewCommentItems.length; i++) {
                const commentItem = reviewCommentItems[i];
                core.info(
                  `Processing create-pull-request-review-comment item ${i + 1}/${reviewCommentItems.length}: bodyLength=${commentItem.body ? commentItem.body.length : "undefined"}, path=${commentItem.path}, line=${commentItem.line}, startLine=${commentItem.start_line}`
                );
                if (!commentItem.path) {
                  core.info('Missing required field "path" in review comment item');
                  continue;
                }
                if (!commentItem.line || (typeof commentItem.line !== "number" && typeof commentItem.line !== "string")) {
                  core.info('Missing or invalid required field "line" in review comment item');
                  continue;
                }
                if (!commentItem.body || typeof commentItem.body !== "string") {
                  core.info('Missing or invalid required field "body" in review comment item');
                  continue;
                }
                const line = parseInt(commentItem.line, 10);
                if (isNaN(line) || line <= 0) {
                  core.info(`Invalid line number: ${commentItem.line}`);
                  continue;
                }
                let startLine = undefined;
                if (commentItem.start_line) {
                  startLine = parseInt(commentItem.start_line, 10);
                  if (isNaN(startLine) || startLine <= 0 || startLine > line) {
                    core.info(`Invalid start_line number: ${commentItem.start_line} (must be <= line: ${line})`);
                    continue;
                  }
                }
                const side = commentItem.side || defaultSide;
                if (side !== "LEFT" && side !== "RIGHT") {
                  core.info(`Invalid side value: ${side} (must be LEFT or RIGHT)`);
                  continue;
                }
                let body = commentItem.body.trim();
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                body += `\n\n> Generated by Agentic Workflow [Run](${runUrl})\n`;
                core.info(
                  `Creating review comment on PR #${pullRequestNumber} at ${commentItem.path}:${line}${startLine ? ` (lines ${startLine}-${line})` : ""} [${side}]`
                );
                core.info(`Comment content length: ${body.length}`);
                try {
                  const requestParams = {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pullRequestNumber,
                    body: body,
                    path: commentItem.path,
                    commit_id: pullRequest && pullRequest.head ? pullRequest.head.sha : "", 
                    line: line,
                    side: side,
                  };
                  if (startLine !== undefined) {
                    requestParams.start_line = startLine;
                    requestParams.start_side = side; 
                  }
                  const { data: comment } = await github.rest.pulls.createReviewComment(requestParams);
                  core.info("Created review comment #" + comment.id + ": " + comment.html_url);
                  createdComments.push(comment);
                  if (i === reviewCommentItems.length - 1) {
                    core.setOutput("review_comment_id", comment.id);
                    core.setOutput("review_comment_url", comment.html_url);
                  }
                } catch (error) {
                  core.error(`âœ— Failed to create review comment: ${error instanceof Error ? error.message : String(error)}`);
                  throw error;
                }
              }
              if (createdComments.length > 0) {
                let summaryContent = "\n\n## GitHub PR Review Comments\n";
                for (const comment of createdComments) {
                  summaryContent += `- Review Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdComments.length} review comment(s)`);
              return createdComments;
            }
            await main();

  create_pull_request:
    needs: agent
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.create_pull_request.outputs.branch_name }}
      fallback_used: ${{ steps.create_pull_request.outputs.fallback_used }}
      issue_number: ${{ steps.create_pull_request.outputs.issue_number }}
      issue_url: ${{ steps.create_pull_request.outputs.issue_url }}
      pull_request_number: ${{ steps.create_pull_request.outputs.pull_request_number }}
      pull_request_url: ${{ steps.create_pull_request.outputs.pull_request_url }}
    steps:
      - name: Download patch artifact
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: aw.patch
          path: /tmp/
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Create Pull Request
        id: create_pull_request
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_WORKFLOW_ID: "agent"
          GITHUB_AW_BASE_BRANCH: ${{ github.ref_name }}
          GITHUB_AW_PR_TITLE_PREFIX: "[ðŸŽ¨ POETRY] "
          GITHUB_AW_PR_LABELS: "poetry,automation,creative-writing"
          GITHUB_AW_PR_DRAFT: "false"
          GITHUB_AW_PR_IF_NO_CHANGES: "warn"
          GITHUB_AW_MAX_PATCH_SIZE: 1024
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const crypto = require("crypto");
            async function main() {
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              const workflowId = process.env.GITHUB_AW_WORKFLOW_ID;
              if (!workflowId) {
                throw new Error("GITHUB_AW_WORKFLOW_ID environment variable is required");
              }
              const baseBranch = process.env.GITHUB_AW_BASE_BRANCH;
              if (!baseBranch) {
                throw new Error("GITHUB_AW_BASE_BRANCH environment variable is required");
              }
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
              }
              const ifNoChanges = process.env.GITHUB_AW_PR_IF_NO_CHANGES || "warn";
              if (!fs.existsSync("/tmp/aw.patch")) {
                const message = "No patch file found - cannot create pull request without changes";
                if (isStaged) {
                  let summaryContent = "## ðŸŽ­ Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent += "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** âš ï¸ No patch file found\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  await core.summary.addRaw(summaryContent).write();
                  core.info("ðŸ“ Pull request creation preview written to step summary (no patch file)");
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
              if (patchContent.includes("Failed to generate patch")) {
                const message = "Patch file contains error message - cannot create pull request without changes";
                if (isStaged) {
                  let summaryContent = "## ðŸŽ­ Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent += "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** âš ï¸ Patch file contains error\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  await core.summary.addRaw(summaryContent).write();
                  core.info("ðŸ“ Pull request creation preview written to step summary (patch error)");
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              const isEmpty = !patchContent || !patchContent.trim();
              if (!isEmpty) {
                const maxSizeKb = parseInt(process.env.GITHUB_AW_MAX_PATCH_SIZE || "1024", 10);
                const patchSizeBytes = Buffer.byteLength(patchContent, "utf8");
                const patchSizeKb = Math.ceil(patchSizeBytes / 1024);
                core.info(`Patch size: ${patchSizeKb} KB (maximum allowed: ${maxSizeKb} KB)`);
                if (patchSizeKb > maxSizeKb) {
                  const message = `Patch size (${patchSizeKb} KB) exceeds maximum allowed size (${maxSizeKb} KB)`;
                  if (isStaged) {
                    let summaryContent = "## ðŸŽ­ Staged Mode: Create Pull Request Preview\n\n";
                    summaryContent += "The following pull request would be created if staged mode was disabled:\n\n";
                    summaryContent += `**Status:** âŒ Patch size exceeded\n\n`;
                    summaryContent += `**Message:** ${message}\n\n`;
                    await core.summary.addRaw(summaryContent).write();
                    core.info("ðŸ“ Pull request creation preview written to step summary (patch size error)");
                    return;
                  }
                  throw new Error(message);
                }
                core.info("Patch size validation passed");
              }
              if (isEmpty && !isStaged) {
                const message = "Patch file is empty - no changes to apply (noop operation)";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error("No changes to push - failing as configured by if-no-changes: error");
                  case "ignore":
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              if (!isEmpty) {
                core.info("Patch content validation passed");
              } else {
                core.info("Patch file is empty - processing noop operation");
              }
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              const pullRequestItem = validatedOutput.items.find( item => item.type === "create-pull-request");
              if (!pullRequestItem) {
                core.warning("No create-pull-request item found in agent output");
                return;
              }
              core.debug(`Found create-pull-request item: title="${pullRequestItem.title}", bodyLength=${pullRequestItem.body.length}`);
              if (isStaged) {
                let summaryContent = "## ðŸŽ­ Staged Mode: Create Pull Request Preview\n\n";
                summaryContent += "The following pull request would be created if staged mode was disabled:\n\n";
                summaryContent += `**Title:** ${pullRequestItem.title || "No title provided"}\n\n`;
                summaryContent += `**Branch:** ${pullRequestItem.branch || "auto-generated"}\n\n`;
                summaryContent += `**Base:** ${baseBranch}\n\n`;
                if (pullRequestItem.body) {
                  summaryContent += `**Body:**\n${pullRequestItem.body}\n\n`;
                }
                if (fs.existsSync("/tmp/aw.patch")) {
                  const patchStats = fs.readFileSync("/tmp/aw.patch", "utf8");
                  if (patchStats.trim()) {
                    summaryContent += `**Changes:** Patch file exists with ${patchStats.split("\n").length} lines\n\n`;
                    summaryContent += `<details><summary>Show patch preview</summary>\n\n\`\`\`diff\n${patchStats.slice(0, 2000)}${patchStats.length > 2000 ? "\n... (truncated)" : ""}\n\`\`\`\n\n</details>\n\n`;
                  } else {
                    summaryContent += `**Changes:** No changes (empty patch)\n\n`;
                  }
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ Pull request creation preview written to step summary");
                return;
              }
              let title = pullRequestItem.title.trim();
              let bodyLines = pullRequestItem.body.split("\n");
              let branchName = pullRequestItem.branch ? pullRequestItem.branch.trim() : null;
              if (!title) {
                title = "Agent Output";
              }
              const titlePrefix = process.env.GITHUB_AW_PR_TITLE_PREFIX;
              if (titlePrefix && !title.startsWith(titlePrefix)) {
                title = titlePrefix + title;
              }
              const runId = context.runId;
              const runUrl = context.payload.repository
                ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                : `https://github.com/actions/runs/${runId}`;
              bodyLines.push(``, ``, `> Generated by Agentic Workflow [Run](${runUrl})`, "");
              const body = bodyLines.join("\n").trim();
              const labelsEnv = process.env.GITHUB_AW_PR_LABELS;
              const labels = labelsEnv
                ? labelsEnv
                    .split(",")
                    .map( label => label.trim())
                    .filter( label => label)
                : [];
              const draftEnv = process.env.GITHUB_AW_PR_DRAFT;
              const draft = draftEnv ? draftEnv.toLowerCase() === "true" : true;
              core.info(`Creating pull request with title: ${title}`);
              core.debug(`Labels: ${JSON.stringify(labels)}`);
              core.debug(`Draft: ${draft}`);
              core.debug(`Body length: ${body.length}`);
              const randomHex = crypto.randomBytes(8).toString("hex");
              if (!branchName) {
                core.debug("No branch name provided in JSONL, generating unique branch name");
                branchName = `${workflowId}-${randomHex}`;
              } else {
                branchName = `${branchName}-${randomHex}`;
                core.debug(`Using branch name from JSONL with added salt: ${branchName}`);
              }
              core.info(`Generated branch name: ${branchName}`);
              core.debug(`Base branch: ${baseBranch}`);
              core.debug(`Fetching latest changes and checking out base branch: ${baseBranch}`);
              await exec.exec("git fetch origin");
              await exec.exec(`git checkout ${baseBranch}`);
              core.debug(`Branch should not exist locally, creating new branch from base: ${branchName}`);
              await exec.exec(`git checkout -b ${branchName}`);
              core.info(`Created new branch from base: ${branchName}`);
              if (!isEmpty) {
                core.info("Applying patch...");
                await exec.exec("git am /tmp/aw.patch");
                core.info("Patch applied successfully");
                await exec.exec(`git push origin ${branchName}`);
                core.info("Changes pushed to branch");
              } else {
                core.info("Skipping patch application (empty patch)");
                const message = "No changes to apply - noop operation completed successfully";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error("No changes to apply - failing as configured by if-no-changes: error");
                  case "ignore":
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              try {
                const { data: pullRequest } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  head: branchName,
                  base: baseBranch,
                  draft: draft,
                });
                core.info(`Created pull request #${pullRequest.number}: ${pullRequest.html_url}`);
                if (labels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pullRequest.number,
                    labels: labels,
                  });
                  core.info(`Added labels to pull request: ${JSON.stringify(labels)}`);
                }
                core.setOutput("pull_request_number", pullRequest.number);
                core.setOutput("pull_request_url", pullRequest.html_url);
                core.setOutput("branch_name", branchName);
                await core.summary
                  .addRaw(
                    `
            ## Pull Request
            - **Pull Request**: [#${pullRequest.number}](${pullRequest.html_url})
            - **Branch**: \`${branchName}\`
            - **Base Branch**: \`${baseBranch}\`
            `
                  )
                  .write();
              } catch (prError) {
                core.warning(`Failed to create pull request: ${prError instanceof Error ? prError.message : String(prError)}`);
                core.info("Falling back to creating an issue instead");
                const branchUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/tree/${branchName}`
                  : `https://github.com/${context.repo.owner}/${context.repo.repo}/tree/${branchName}`;
                const fallbackBody = `${body}
            ---
            **Note:** This was originally intended as a pull request, but PR creation failed. The changes have been pushed to the branch [\`${branchName}\`](${branchUrl}).
            **Original error:** ${prError instanceof Error ? prError.message : String(prError)}
            You can manually create a pull request from the branch if needed.`;
                try {
                  const { data: issue } = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: title,
                    body: fallbackBody,
                    labels: labels,
                  });
                  core.info(`Created fallback issue #${issue.number}: ${issue.html_url}`);
                  core.setOutput("issue_number", issue.number);
                  core.setOutput("issue_url", issue.html_url);
                  core.setOutput("branch_name", branchName);
                  core.setOutput("fallback_used", "true");
                  await core.summary
                    .addRaw(
                      `
            ## Fallback Issue Created
            - **Issue**: [#${issue.number}](${issue.html_url})
            - **Branch**: [\`${branchName}\`](${branchUrl})
            - **Base Branch**: \`${baseBranch}\`
            - **Note**: Pull request creation failed, created issue as fallback
            `
                    )
                    .write();
                } catch (issueError) {
                  core.setFailed(
                    `Failed to create both pull request and fallback issue. PR error: ${prError instanceof Error ? prError.message : String(prError)}. Issue error: ${issueError instanceof Error ? issueError.message : String(issueError)}`
                  );
                  return;
                }
              }
            }
            await main();

  add_labels:
    needs: agent
    if: github.event.issue.number || github.event.pull_request.number
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      labels_added: ${{ steps.add_labels.outputs.labels_added }}
    steps:
      - name: Add Labels
        id: add_labels
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_LABELS_ALLOWED: "poetry,creative,automation,ai-generated,test,epic,haiku,sonnet,limerick"
          GITHUB_AW_LABELS_MAX_COUNT: 5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              const labelsItem = validatedOutput.items.find(item => item.type === "add-labels");
              if (!labelsItem) {
                core.warning("No add-labels item found in agent output");
                return;
              }
              core.debug(`Found add-labels item with ${labelsItem.labels.length} labels`);
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent = "## ðŸŽ­ Staged Mode: Add Labels Preview\n\n";
                summaryContent += "The following labels would be added if staged mode was disabled:\n\n";
                if (labelsItem.issue_number) {
                  summaryContent += `**Target Issue:** #${labelsItem.issue_number}\n\n`;
                } else {
                  summaryContent += `**Target:** Current issue/PR\n\n`;
                }
                if (labelsItem.labels && labelsItem.labels.length > 0) {
                  summaryContent += `**Labels to add:** ${labelsItem.labels.join(", ")}\n\n`;
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ Label addition preview written to step summary");
                return;
              }
              const allowedLabelsEnv = process.env.GITHUB_AW_LABELS_ALLOWED?.trim();
              const allowedLabels = allowedLabelsEnv
                ? allowedLabelsEnv
                    .split(",")
                    .map(label => label.trim())
                    .filter(label => label)
                : undefined;
              if (allowedLabels) {
                core.debug(`Allowed labels: ${JSON.stringify(allowedLabels)}`);
              } else {
                core.debug("No label restrictions - any labels are allowed");
              }
              const maxCountEnv = process.env.GITHUB_AW_LABELS_MAX_COUNT;
              const maxCount = maxCountEnv ? parseInt(maxCountEnv, 10) : 3;
              if (isNaN(maxCount) || maxCount < 1) {
                core.setFailed(`Invalid max value: ${maxCountEnv}. Must be a positive integer`);
                return;
              }
              core.debug(`Max count: ${maxCount}`);
              const isIssueContext = context.eventName === "issues" || context.eventName === "issue_comment";
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment";
              if (!isIssueContext && !isPRContext) {
                core.setFailed("Not running in issue or pull request context, skipping label addition");
                return;
              }
              let issueNumber;
              let contextType;
              if (isIssueContext) {
                if (context.payload.issue) {
                  issueNumber = context.payload.issue.number;
                  contextType = "issue";
                } else {
                  core.setFailed("Issue context detected but no issue found in payload");
                  return;
                }
              } else if (isPRContext) {
                if (context.payload.pull_request) {
                  issueNumber = context.payload.pull_request.number;
                  contextType = "pull request";
                } else {
                  core.setFailed("Pull request context detected but no pull request found in payload");
                  return;
                }
              }
              if (!issueNumber) {
                core.setFailed("Could not determine issue or pull request number");
                return;
              }
              const requestedLabels = labelsItem.labels || [];
              core.debug(`Requested labels: ${JSON.stringify(requestedLabels)}`);
              for (const label of requestedLabels) {
                if (label.startsWith("-")) {
                  core.setFailed(`Label removal is not permitted. Found line starting with '-': ${label}`);
                  return;
                }
              }
              let validLabels;
              if (allowedLabels) {
                validLabels = requestedLabels.filter(label => allowedLabels.includes(label));
              } else {
                validLabels = requestedLabels;
              }
              let uniqueLabels = [...new Set(validLabels)];
              if (uniqueLabels.length > maxCount) {
                core.debug(`too many labels, keep ${maxCount}`);
                uniqueLabels = uniqueLabels.slice(0, maxCount);
              }
              if (uniqueLabels.length === 0) {
                core.info("No labels to add");
                core.setOutput("labels_added", "");
                await core.summary
                  .addRaw(
                    `
            ## Label Addition
            No labels were added (no valid labels found in agent output).
            `
                  )
                  .write();
                return;
              }
              core.info(`Adding ${uniqueLabels.length} labels to ${contextType} #${issueNumber}: ${JSON.stringify(uniqueLabels)}`);
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: uniqueLabels,
                });
                core.info(`Successfully added ${uniqueLabels.length} labels to ${contextType} #${issueNumber}`);
                core.setOutput("labels_added", uniqueLabels.join("\n"));
                const labelsListMarkdown = uniqueLabels.map(label => `- \`${label}\``).join("\n");
                await core.summary
                  .addRaw(
                    `
            ## Label Addition
            Successfully added ${uniqueLabels.length} label(s) to ${contextType} #${issueNumber}:
            ${labelsListMarkdown}
            `
                  )
                  .write();
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.error(`Failed to add labels: ${errorMessage}`);
                core.setFailed(`Failed to add labels: ${errorMessage}`);
              }
            }
            await main();

  update_issue:
    needs: agent
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    timeout-minutes: 10
    outputs:
      issue_number: ${{ steps.update_issue.outputs.issue_number }}
      issue_url: ${{ steps.update_issue.outputs.issue_url }}
    steps:
      - name: Update Issue
        id: update_issue
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_UPDATE_STATUS: true
          GITHUB_AW_UPDATE_TITLE: true
          GITHUB_AW_UPDATE_BODY: true
          GITHUB_AW_UPDATE_TARGET: "*"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              const updateItems = validatedOutput.items.filter( item => item.type === "update-issue");
              if (updateItems.length === 0) {
                core.info("No update-issue items found in agent output");
                return;
              }
              core.info(`Found ${updateItems.length} update-issue item(s)`);
              if (isStaged) {
                let summaryContent = "## ðŸŽ­ Staged Mode: Update Issues Preview\n\n";
                summaryContent += "The following issue updates would be applied if staged mode was disabled:\n\n";
                for (let i = 0; i < updateItems.length; i++) {
                  const item = updateItems[i];
                  summaryContent += `### Issue Update ${i + 1}\n`;
                  if (item.issue_number) {
                    summaryContent += `**Target Issue:** #${item.issue_number}\n\n`;
                  } else {
                    summaryContent += `**Target:** Current issue\n\n`;
                  }
                  if (item.title !== undefined) {
                    summaryContent += `**New Title:** ${item.title}\n\n`;
                  }
                  if (item.body !== undefined) {
                    summaryContent += `**New Body:**\n${item.body}\n\n`;
                  }
                  if (item.status !== undefined) {
                    summaryContent += `**New Status:** ${item.status}\n\n`;
                  }
                  summaryContent += "---\n\n";
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ Issue update preview written to step summary");
                return;
              }
              const updateTarget = process.env.GITHUB_AW_UPDATE_TARGET || "triggering";
              const canUpdateStatus = process.env.GITHUB_AW_UPDATE_STATUS === "true";
              const canUpdateTitle = process.env.GITHUB_AW_UPDATE_TITLE === "true";
              const canUpdateBody = process.env.GITHUB_AW_UPDATE_BODY === "true";
              core.info(`Update target configuration: ${updateTarget}`);
              core.info(`Can update status: ${canUpdateStatus}, title: ${canUpdateTitle}, body: ${canUpdateBody}`);
              const isIssueContext = context.eventName === "issues" || context.eventName === "issue_comment";
              if (updateTarget === "triggering" && !isIssueContext) {
                core.info('Target is "triggering" but not running in issue context, skipping issue update');
                return;
              }
              const updatedIssues = [];
              for (let i = 0; i < updateItems.length; i++) {
                const updateItem = updateItems[i];
                core.info(`Processing update-issue item ${i + 1}/${updateItems.length}`);
                let issueNumber;
                if (updateTarget === "*") {
                  if (updateItem.issue_number) {
                    issueNumber = parseInt(updateItem.issue_number, 10);
                    if (isNaN(issueNumber) || issueNumber <= 0) {
                      core.info(`Invalid issue number specified: ${updateItem.issue_number}`);
                      continue;
                    }
                  } else {
                    core.info('Target is "*" but no issue_number specified in update item');
                    continue;
                  }
                } else if (updateTarget && updateTarget !== "triggering") {
                  issueNumber = parseInt(updateTarget, 10);
                  if (isNaN(issueNumber) || issueNumber <= 0) {
                    core.info(`Invalid issue number in target configuration: ${updateTarget}`);
                    continue;
                  }
                } else {
                  if (isIssueContext) {
                    if (context.payload.issue) {
                      issueNumber = context.payload.issue.number;
                    } else {
                      core.info("Issue context detected but no issue found in payload");
                      continue;
                    }
                  } else {
                    core.info("Could not determine issue number");
                    continue;
                  }
                }
                if (!issueNumber) {
                  core.info("Could not determine issue number");
                  continue;
                }
                core.info(`Updating issue #${issueNumber}`);
                const updateData = {};
                let hasUpdates = false;
                if (canUpdateStatus && updateItem.status !== undefined) {
                  if (updateItem.status === "open" || updateItem.status === "closed") {
                    updateData.state = updateItem.status;
                    hasUpdates = true;
                    core.info(`Will update status to: ${updateItem.status}`);
                  } else {
                    core.info(`Invalid status value: ${updateItem.status}. Must be 'open' or 'closed'`);
                  }
                }
                if (canUpdateTitle && updateItem.title !== undefined) {
                  if (typeof updateItem.title === "string" && updateItem.title.trim().length > 0) {
                    updateData.title = updateItem.title.trim();
                    hasUpdates = true;
                    core.info(`Will update title to: ${updateItem.title.trim()}`);
                  } else {
                    core.info("Invalid title value: must be a non-empty string");
                  }
                }
                if (canUpdateBody && updateItem.body !== undefined) {
                  if (typeof updateItem.body === "string") {
                    updateData.body = updateItem.body;
                    hasUpdates = true;
                    core.info(`Will update body (length: ${updateItem.body.length})`);
                  } else {
                    core.info("Invalid body value: must be a string");
                  }
                }
                if (!hasUpdates) {
                  core.info("No valid updates to apply for this item");
                  continue;
                }
                try {
                  const { data: issue } = await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    ...updateData,
                  });
                  core.info("Updated issue #" + issue.number + ": " + issue.html_url);
                  updatedIssues.push(issue);
                  if (i === updateItems.length - 1) {
                    core.setOutput("issue_number", issue.number);
                    core.setOutput("issue_url", issue.html_url);
                  }
                } catch (error) {
                  core.error(`âœ— Failed to update issue #${issueNumber}: ${error instanceof Error ? error.message : String(error)}`);
                  throw error;
                }
              }
              if (updatedIssues.length > 0) {
                let summaryContent = "\n\n## Updated Issues\n";
                for (const issue of updatedIssues) {
                  summaryContent += `- Issue #${issue.number}: [${issue.title}](${issue.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully updated ${updatedIssues.length} issue(s)`);
              return updatedIssues;
            }
            await main();

  push_to_pull_request_branch:
    needs: agent
    if: (github.event.issue.number && github.event.issue.pull_request) || github.event.pull_request
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.push_to_pull_request_branch.outputs.branch_name }}
      commit_sha: ${{ steps.push_to_pull_request_branch.outputs.commit_sha }}
      push_url: ${{ steps.push_to_pull_request_branch.outputs.push_url }}
    steps:
      - name: Download patch artifact
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: aw.patch
          path: /tmp/
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Push to Branch
        id: push_to_pull_request_branch
        uses: actions/github-script@v8
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
          GITHUB_AW_PUSH_IF_NO_CHANGES: "warn"
          GITHUB_AW_MAX_PATCH_SIZE: 1024
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            async function main() {
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              const target = process.env.GITHUB_AW_PUSH_TARGET || "triggering";
              const ifNoChanges = process.env.GITHUB_AW_PUSH_IF_NO_CHANGES || "warn";
              if (!fs.existsSync("/tmp/aw.patch")) {
                const message = "No patch file found - cannot push without changes";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed(message);
                    return;
                  case "ignore":
                    return;
                  case "warn":
                  default:
                    core.info(message);
                    return;
                }
              }
              const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
              if (patchContent.includes("Failed to generate patch")) {
                const message = "Patch file contains error message - cannot push without changes";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed(message);
                    return;
                  case "ignore":
                    return;
                  case "warn":
                  default:
                    core.info(message);
                    return;
                }
              }
              const isEmpty = !patchContent || !patchContent.trim();
              if (!isEmpty) {
                const maxSizeKb = parseInt(process.env.GITHUB_AW_MAX_PATCH_SIZE || "1024", 10);
                const patchSizeBytes = Buffer.byteLength(patchContent, "utf8");
                const patchSizeKb = Math.ceil(patchSizeBytes / 1024);
                core.info(`Patch size: ${patchSizeKb} KB (maximum allowed: ${maxSizeKb} KB)`);
                if (patchSizeKb > maxSizeKb) {
                  const message = `Patch size (${patchSizeKb} KB) exceeds maximum allowed size (${maxSizeKb} KB)`;
                  core.setFailed(message);
                  return;
                }
                core.info("Patch size validation passed");
              }
              if (isEmpty) {
                const message = "Patch file is empty - no changes to apply (noop operation)";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed("No changes to push - failing as configured by if-no-changes: error");
                    return;
                  case "ignore":
                    break;
                  case "warn":
                  default:
                    core.info(message);
                    break;
                }
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              if (!isEmpty) {
                core.info("Patch content validation passed");
              }
              core.info(`Target configuration: ${target}`);
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              const pushItem = validatedOutput.items.find( item => item.type === "push-to-pull-request-branch");
              if (!pushItem) {
                core.info("No push-to-pull-request-branch item found in agent output");
                return;
              }
              core.info("Found push-to-pull-request-branch item");
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent = "## ðŸŽ­ Staged Mode: Push to PR Branch Preview\n\n";
                summaryContent += "The following changes would be pushed if staged mode was disabled:\n\n";
                summaryContent += `**Target:** ${target}\n\n`;
                if (pushItem.commit_message) {
                  summaryContent += `**Commit Message:** ${pushItem.commit_message}\n\n`;
                }
                if (fs.existsSync("/tmp/aw.patch")) {
                  const patchStats = fs.readFileSync("/tmp/aw.patch", "utf8");
                  if (patchStats.trim()) {
                    summaryContent += `**Changes:** Patch file exists with ${patchStats.split("\n").length} lines\n\n`;
                    summaryContent += `<details><summary>Show patch preview</summary>\n\n\`\`\`diff\n${patchStats.slice(0, 2000)}${patchStats.length > 2000 ? "\n... (truncated)" : ""}\n\`\`\`\n\n</details>\n\n`;
                  } else {
                    summaryContent += `**Changes:** No changes (empty patch)\n\n`;
                  }
                }
                await core.summary.addRaw(summaryContent).write();
                core.info("ðŸ“ Push to PR branch preview written to step summary");
                return;
              }
              if (target !== "*" && target !== "triggering") {
                const pullNumber = parseInt(target, 10);
                if (isNaN(pullNumber)) {
                  core.setFailed('Invalid target configuration: must be "triggering", "*", or a valid pull request number');
                  return;
                }
              }
              let pullNumber;
              if (target === "triggering") {
                pullNumber = context.payload?.pull_request?.number || context.payload?.issue?.number;
                if (!pullNumber) {
                  core.setFailed('push-to-pull-request-branch with target "triggering" requires pull request context');
                  return;
                }
              } else if (target === "*") {
                if (pushItem.pull_number) {
                  pullNumber = parseInt(pushItem.pull_number, 10);
                }
              } else {
                pullNumber = parseInt(target, 10);
              }
              let branchName;
              try {
                let prInfo = "";
                const prInfoRes = await exec.exec(`gh`, [`pr`, `view`, `${pullNumber}`, `--json`, `headRefName`, `--jq`, `.headRefName`], {
                  listeners: { stdout: data => (prInfo += data.toString()) },
                });
                if (!prInfoRes) {
                  branchName = prInfo.trim();
                } else {
                  throw new Error("No head branch found for PR");
                }
              } catch (error) {
                core.info(`Warning: Could not fetch PR ${pullNumber} details: ${error instanceof Error ? error.message : String(error)}`);
                core.setFailed(`Failed to determine branch name for PR ${pullNumber}`);
                return;
              }
              core.info(`Target branch: ${branchName}`);
              const hasChanges = !isEmpty;
              core.info(`Switching to branch: ${branchName}`);
              try {
                await exec.exec("git fetch origin");
                try {
                  await exec.exec(`git rev-parse --verify origin/${branchName}`);
                  await exec.exec(`git checkout -B ${branchName} origin/${branchName}`);
                  core.info(`Checked out existing branch from origin: ${branchName}`);
                } catch (originError) {
                  core.setFailed(
                    `Branch ${branchName} does not exist on origin, can't push to it: ${originError instanceof Error ? originError.message : String(originError)}`
                  );
                  return;
                }
              } catch (error) {
                core.setFailed(`Failed to switch to branch ${branchName}: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!isEmpty) {
                core.info("Applying patch...");
                try {
                  await exec.exec("git am /tmp/aw.patch");
                  core.info("Patch applied successfully");
                  await exec.exec(`git push origin ${branchName}`);
                  core.info(`Changes committed and pushed to branch: ${branchName}`);
                } catch (error) {
                  core.error(`Failed to apply patch: ${error instanceof Error ? error.message : String(error)}`);
                  core.setFailed("Failed to apply patch");
                  return;
                }
              } else {
                core.info("Skipping patch application (empty patch)");
                const message = "No changes to apply - noop operation completed successfully";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed("No changes to apply - failing as configured by if-no-changes: error");
                    return;
                  case "ignore":
                    break;
                  case "warn":
                  default:
                    core.info(message);
                    break;
                }
              }
              let commitSha = "";
              const commitShaRes = await exec.exec("git", ["rev-parse", "HEAD"], {
                listeners: { stdout: data => (commitSha += data.toString()) },
              });
              if (commitShaRes) throw new Error("Failed to get commit SHA");
              commitSha = commitSha.trim();
              const pushUrl = context.payload.repository
                ? `${context.payload.repository.html_url}/tree/${branchName}`
                : `https://github.com/${context.repo.owner}/${context.repo.repo}/tree/${branchName}`;
              core.setOutput("branch_name", branchName);
              core.setOutput("commit_sha", commitSha);
              core.setOutput("push_url", pushUrl);
              const summaryTitle = hasChanges ? "Push to Branch" : "Push to Branch (No Changes)";
              const summaryContent = hasChanges
                ? `
            ## ${summaryTitle}
            - **Branch**: \`${branchName}\`
            - **Commit**: [${commitSha.substring(0, 7)}](${pushUrl})
            - **URL**: [${pushUrl}](${pushUrl})
            `
                : `
            ## ${summaryTitle}
            - **Branch**: \`${branchName}\`
            - **Status**: No changes to apply (noop operation)
            - **URL**: [${pushUrl}](${pushUrl})
            `;
              await core.summary.addRaw(summaryContent).write();
            }
            await main();

  missing_tool:
    needs: agent
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5
    outputs:
      tools_reported: ${{ steps.missing_tool.outputs.tools_reported }}
      total_count: ${{ steps.missing_tool.outputs.total_count }}
    steps:
      - name: Record Missing Tool
        id: missing_tool
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.agent.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            async function main() {
              const fs = require("fs");
              const agentOutput = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              const maxReports = process.env.GITHUB_AW_MISSING_TOOL_MAX ? parseInt(process.env.GITHUB_AW_MISSING_TOOL_MAX) : null;
              core.info("Processing missing-tool reports...");
              core.info(`Agent output length: ${agentOutput.length}`);
              if (maxReports) {
                core.info(`Maximum reports allowed: ${maxReports}`);
              }
              const missingTools = [];
              if (!agentOutput.trim()) {
                core.info("No agent output to process");
                core.setOutput("tools_reported", JSON.stringify(missingTools));
                core.setOutput("total_count", missingTools.length.toString());
                return;
              }
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(agentOutput);
              } catch (error) {
                core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                core.setOutput("tools_reported", JSON.stringify(missingTools));
                core.setOutput("total_count", missingTools.length.toString());
                return;
              }
              core.info(`Parsed agent output with ${validatedOutput.items.length} entries`);
              for (const entry of validatedOutput.items) {
                if (entry.type === "missing-tool") {
                  if (!entry.tool) {
                    core.warning(`missing-tool entry missing 'tool' field: ${JSON.stringify(entry)}`);
                    continue;
                  }
                  if (!entry.reason) {
                    core.warning(`missing-tool entry missing 'reason' field: ${JSON.stringify(entry)}`);
                    continue;
                  }
                  const missingTool = {
                    tool: entry.tool,
                    reason: entry.reason,
                    alternatives: entry.alternatives || null,
                    timestamp: new Date().toISOString(),
                  };
                  missingTools.push(missingTool);
                  core.info(`Recorded missing tool: ${missingTool.tool}`);
                  if (maxReports && missingTools.length >= maxReports) {
                    core.info(`Reached maximum number of missing tool reports (${maxReports})`);
                    break;
                  }
                }
              }
              core.info(`Total missing tools reported: ${missingTools.length}`);
              core.setOutput("tools_reported", JSON.stringify(missingTools));
              core.setOutput("total_count", missingTools.length.toString());
              if (missingTools.length > 0) {
                core.info("Missing tools summary:");
                core.summary
                  .addHeading("Missing Tools Report", 2)
                  .addRaw(`Found **${missingTools.length}** missing tool${missingTools.length > 1 ? "s" : ""} in this workflow execution.\n\n`);
                missingTools.forEach((tool, index) => {
                  core.info(`${index + 1}. Tool: ${tool.tool}`);
                  core.info(`   Reason: ${tool.reason}`);
                  if (tool.alternatives) {
                    core.info(`   Alternatives: ${tool.alternatives}`);
                  }
                  core.info(`   Reported at: ${tool.timestamp}`);
                  core.info("");
                  core.summary.addRaw(`### ${index + 1}. \`${tool.tool}\`\n\n`).addRaw(`**Reason:** ${tool.reason}\n\n`);
                  if (tool.alternatives) {
                    core.summary.addRaw(`**Alternatives:** ${tool.alternatives}\n\n`);
                  }
                  core.summary.addRaw(`**Reported at:** ${tool.timestamp}\n\n---\n\n`);
                });
                core.summary.write();
              } else {
                core.info("No missing tools reported in this workflow execution.");
                core.summary.addHeading("Missing Tools Report", 2).addRaw("âœ… No missing tools reported in this workflow execution.").write();
              }
            }
            main().catch(error => {
              core.error(`Error processing missing-tool reports: ${error}`);
              core.setFailed(`Error processing missing-tool reports: ${error}`);
            });

