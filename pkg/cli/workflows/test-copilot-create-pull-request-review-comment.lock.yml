# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile
# For more information: https://github.com/githubnext/gh-aw/blob/main/.github/instructions/github-agentic-workflows.instructions.md

name: "Test Copilot Create Pull Request Review Comment"
on:
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}"

run-name: "Test Copilot Create Pull Request Review Comment"

jobs:
  agent:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Generate Claude Settings
        run: |
          mkdir -p /tmp/.claude
          cat > /tmp/.claude/settings.json << 'EOF'
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "WebFetch|WebSearch",
                  "hooks": [
                    {
                      "type": "command",
                      "command": ".claude/hooks/network_permissions.py"
                    }
                  ]
                }
              ]
            }
          }
          EOF
      - name: Generate Network Permissions Hook
        run: |
          mkdir -p .claude/hooks
          cat > .claude/hooks/network_permissions.py << 'EOF'
          #!/usr/bin/env python3
          """
          Network permissions validator for Claude Code engine.
          Generated by gh-aw from engine network permissions configuration.
          """
          
          import json
          import sys
          import urllib.parse
          import re
          
          # Domain allow-list (populated during generation)
          ALLOWED_DOMAINS = ["crl3.digicert.com","crl4.digicert.com","ocsp.digicert.com","ts-crl.ws.symantec.com","ts-ocsp.ws.symantec.com","crl.geotrust.com","ocsp.geotrust.com","crl.thawte.com","ocsp.thawte.com","crl.verisign.com","ocsp.verisign.com","crl.globalsign.com","ocsp.globalsign.com","crls.ssl.com","ocsp.ssl.com","crl.identrust.com","ocsp.identrust.com","crl.sectigo.com","ocsp.sectigo.com","crl.usertrust.com","ocsp.usertrust.com","s.symcb.com","s.symcd.com","json-schema.org","json.schemastore.org","archive.ubuntu.com","security.ubuntu.com","ppa.launchpad.net","keyserver.ubuntu.com","azure.archive.ubuntu.com","api.snapcraft.io","packagecloud.io","packages.cloud.google.com","packages.microsoft.com"]
          
          def extract_domain(url_or_query):
              """Extract domain from URL or search query."""
              if not url_or_query:
                  return None
              
              if url_or_query.startswith(('http://', 'https://')):
                  return urllib.parse.urlparse(url_or_query).netloc.lower()
              
              # Check for domain patterns in search queries
              match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
              if match:
                  return match.group(1).lower()
              
              return None
          
          def is_domain_allowed(domain):
              """Check if domain is allowed."""
              if not domain:
                  # If no domain detected, allow only if not under deny-all policy
                  return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
              
              # Empty allowed domains means deny all
              if not ALLOWED_DOMAINS:
                  return False
              
              for pattern in ALLOWED_DOMAINS:
                  regex = pattern.replace('.', r'\.').replace('*', '.*')
                  if re.match(f'^{regex}$', domain):
                      return True
              return False
          
          # Main logic
          try:
              data = json.load(sys.stdin)
              tool_name = data.get('tool_name', '')
              tool_input = data.get('tool_input', {})
              
              if tool_name not in ['WebFetch', 'WebSearch']:
                  sys.exit(0)  # Allow other tools
              
              target = tool_input.get('url') or tool_input.get('query', '')
              domain = extract_domain(target)
              
              # For WebSearch, apply domain restrictions consistently
              # If no domain detected in search query, check if restrictions are in place
              if tool_name == 'WebSearch' and not domain:
                  # Since this hook is only generated when network permissions are configured,
                  # empty ALLOWED_DOMAINS means deny-all policy
                  if not ALLOWED_DOMAINS:  # Empty list means deny all
                      print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
                      print(f"No domains are allowed for WebSearch", file=sys.stderr)
                      sys.exit(2)  # Block under deny-all policy
                  else:
                      print(f"Network access blocked for web-search: no specific domain detected", file=sys.stderr)
                      print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                      sys.exit(2)  # Block general searches when domain allowlist is configured
              
              if not is_domain_allowed(domain):
                  print(f"Network access blocked for domain: {domain}", file=sys.stderr)
                  print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                  sys.exit(2)  # Block with feedback to Claude
              
              sys.exit(0)  # Allow
              
          except Exception as e:
              print(f"Network validation error: {e}", file=sys.stderr)
              sys.exit(2)  # Block on errors
          
          EOF
          chmod +x .claude/hooks/network_permissions.py
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
      - name: Install GitHub Copilot CLI
        run: npm install -g @github/copilot
      - name: Setup Copilot CLI MCP Configuration
        run: |
          mkdir -p /tmp/.copilot
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/.copilot/mcp-config.json << 'EOF'
          {
            "mcpServers": {}
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          mkdir -p $(dirname "$GITHUB_AW_PROMPT")
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Test Copilot Create Pull Request Review Comment
          
          This is a test workflow to verify that Copilot can create review comments on pull requests.
          
          Please add a review comment to the latest pull request saying "This is a test review comment from Copilot."
          
          EOF
      - name: Print prompt to step summary
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Generate agentic run info
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "copilot",
              engine_name: "GitHub Copilot CLI",
              model: "",
              version: "",
              workflow_name: "Test Copilot Create Pull Request Review Comment",
              experimental: true,
              supports_tools_allowlist: true,
              supports_http_transport: true,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: false,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
            
            // Add agentic workflow run information to step summary
            core.summary
              .addRaw('## Agentic Run Information\n\n')
              .addRaw('```json\n')
              .addRaw(JSON.stringify(awInfo, null, 2))
              .addRaw('\n```\n')
              .write();
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Execute GitHub Copilot CLI
        id: agentic_execution
        timeout-minutes: 5
        run: |
          set -o pipefail
          
          INSTRUCTION=$(cat /tmp/aw-prompts/prompt.txt)
          
          # Run copilot CLI with log capture
          copilot --add-dir /tmp/ --log-level debug --log-dir /tmp/.copilot/logs/ --prompt "$INSTRUCTION" 2>&1 | tee /tmp/test-copilot-create-pull-request-review-comment.log
        env:
          GITHUB_STEP_SUMMARY: ${{ env.GITHUB_STEP_SUMMARY }}
          GITHUB_TOKEN: ${{ secrets.COPILOT_CLI_TOKEN  }}
          XDG_CONFIG_HOME: /tmp/.copilot/
          XDG_STATE_HOME: /tmp/.copilot/
      - name: Upload engine output files
        uses: actions/upload-artifact@v4
        with:
          name: agent_outputs
          path: |
            /tmp/.copilot/logs/
          if-no-files-found: ignore
      - name: Clean up engine output files
        run: |
          rm -fr /tmp/.copilot/logs/
      - name: Upload MCP logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mcp-logs
          path: /tmp/mcp-logs/
          if-no-files-found: ignore
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/test-copilot-create-pull-request-review-comment.log
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                const logFile = process.env.AGENT_LOG_FILE;
                if (!logFile) {
                  console.log("No agent log file specified");
                  return;
                }
                if (!fs.existsSync(logFile)) {
                  console.log(`Log file not found: ${logFile}`);
                  return;
                }
                const content = fs.readFileSync(logFile, "utf8");
                const parsedLog = parseCopilotLog(content);
                if (parsedLog) {
                  core.summary.addRaw(parsedLog).write();
                  console.log("Copilot log parsed successfully");
                } else {
                  console.log("Failed to parse Copilot log");
                }
              } catch (error) {
                core.setFailed(error.message);
              }
            }
            function parseCopilotLog(logContent) {
              try {
                const lines = logContent.split("\n");
                let markdown = "## 🤖 GitHub Copilot CLI Execution\n\n";
                let hasOutput = false;
                let inCodeBlock = false;
                let currentCodeBlock = "";
                let currentLanguage = "";
                for (const line of lines) {
                  if (line.trim().startsWith("```")) {
                    if (!inCodeBlock) {
                      inCodeBlock = true;
                      currentLanguage = line.trim().substring(3);
                      currentCodeBlock = "";
                    } else {
                      inCodeBlock = false;
                      if (currentCodeBlock.trim()) {
                        markdown += `\`\`\`${currentLanguage}\n${currentCodeBlock}\`\`\`\n\n`;
                        hasOutput = true;
                      }
                      currentCodeBlock = "";
                      currentLanguage = "";
                    }
                    continue;
                  }
                  if (inCodeBlock) {
                    currentCodeBlock += line + "\n";
                    continue;
                  }
                  if (line.includes("copilot -p") || line.includes("github copilot")) {
                    markdown += `**Command:** \`${line.trim()}\`\n\n`;
                    hasOutput = true;
                  }
                  if (line.includes("Suggestion:") || line.includes("Response:")) {
                    markdown += `**${line.trim()}**\n\n`;
                    hasOutput = true;
                  }
                  if (line.toLowerCase().includes("error:")) {
                    markdown += `❌ **Error:** ${line.trim()}\n\n`;
                    hasOutput = true;
                  } else if (line.toLowerCase().includes("warning:")) {
                    markdown += `⚠️ **Warning:** ${line.trim()}\n\n`;
                    hasOutput = true;
                  }
                  const trimmedLine = line.trim();
                  if (
                    trimmedLine &&
                    !trimmedLine.startsWith("$") &&
                    !trimmedLine.startsWith("#") &&
                    !trimmedLine.match(/^\d{4}-\d{2}-\d{2}/) && 
                    trimmedLine.length > 10
                  ) {
                    if (
                      trimmedLine.includes("copilot") ||
                      trimmedLine.includes("suggestion") ||
                      trimmedLine.includes("generate") ||
                      trimmedLine.includes("explain")
                    ) {
                      markdown += `${trimmedLine}\n\n`;
                      hasOutput = true;
                    }
                  }
                }
                if (inCodeBlock && currentCodeBlock.trim()) {
                  markdown += `\`\`\`${currentLanguage}\n${currentCodeBlock}\`\`\`\n\n`;
                  hasOutput = true;
                }
                if (!hasOutput) {
                  markdown += "*No significant output captured from Copilot CLI execution.*\n";
                }
                return markdown;
              } catch (error) {
                console.error("Error parsing Copilot log:", error);
                return `## 🤖 GitHub Copilot CLI Execution\n\n*Error parsing log: ${error.message}*\n`;
              }
            }
            main();
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-copilot-create-pull-request-review-comment.log
          path: /tmp/test-copilot-create-pull-request-review-comment.log
          if-no-files-found: warn

