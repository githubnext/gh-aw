package cli

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestAnalyzeSanitizationChanges(t *testing.T) {
	// Create a temporary directory for test artifacts
	tmpDir := t.TempDir()

	// Test case 1: No output files available
	t.Run("NoOutputFiles", func(t *testing.T) {
		run := WorkflowRun{DatabaseID: 12345}
		analysis, err := analyzeSanitizationChanges(tmpDir, run, false)

		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if analysis.HasRawOutput || analysis.HasSanitizedOutput {
			t.Error("Expected no output files detected")
		}
		if analysis.TotalChanges != 0 {
			t.Error("Expected no changes when no output files exist")
		}
	})

	// Test case 2: Only sanitized output available
	t.Run("OnlySanitizedOutput", func(t *testing.T) {
		// Create only sanitized output
		sanitizedPath := filepath.Join(tmpDir, "safe_output.jsonl")
		sanitizedContent := `{"type":"text","text":"Hello world"}`
		if err := os.WriteFile(sanitizedPath, []byte(sanitizedContent), 0644); err != nil {
			t.Fatal(err)
		}

		run := WorkflowRun{DatabaseID: 12346}
		analysis, err := analyzeSanitizationChanges(tmpDir, run, false)

		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if !analysis.HasSanitizedOutput {
			t.Error("Expected sanitized output to be detected")
		}
		if analysis.HasRawOutput {
			t.Error("Expected no raw output")
		}
		if analysis.TotalChanges != 0 {
			t.Error("Expected no changes when only sanitized output exists")
		}

		// Clean up
		os.Remove(sanitizedPath)
	})

	// Test case 3: Both outputs available with changes
	t.Run("BothOutputsWithChanges", func(t *testing.T) {
		// Create sanitized output
		sanitizedPath := filepath.Join(tmpDir, "safe_output.jsonl")
		sanitizedContent := `{"type":"text","text":"Hello ` + "`@user`" + `! This ` + "`fixes #123`" + ` and check (redacted) and https://github.com/repo"}`
		if err := os.WriteFile(sanitizedPath, []byte(sanitizedContent), 0644); err != nil {
			t.Fatal(err)
		}

		// Create audit log that would be generated by the JavaScript sanitizer
		auditLogPath := filepath.Join(tmpDir, "sanitization_audit.json")
		auditLogContent := `{
			"timestamp": "2023-01-01T00:00:00Z",
			"total_changes": 3,
			"changes_by_type": {
				"mention": 1,
				"bot_trigger": 1,
				"url": 1
			},
			"changes": [
				{
					"type": "mention",
					"original": "@user",
					"sanitized": "` + "`@user`" + `",
					"line_number": 1,
					"description": "@mention neutralized to prevent unintended notifications",
					"context": "Hello @user! This fixes"
				},
				{
					"type": "bot_trigger",
					"original": "fixes #123",
					"sanitized": "` + "`fixes #123`" + `",
					"line_number": 1,
					"description": "Bot trigger phrase neutralized to prevent unintended actions",
					"context": "! This fixes #123 and check"
				},
				{
					"type": "url",
					"original": "http://evil.com",
					"sanitized": "(redacted)",
					"line_number": 1,
					"description": "URL redacted due to unsafe protocol: http",
					"context": "check http://evil.com and https://github.com"
				}
			]
		}`
		if err := os.WriteFile(auditLogPath, []byte(auditLogContent), 0644); err != nil {
			t.Fatal(err)
		}

		run := WorkflowRun{DatabaseID: 12347}
		analysis, err := analyzeSanitizationChanges(tmpDir, run, false)

		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if !analysis.HasRawOutput || !analysis.HasSanitizedOutput {
			t.Error("Expected both output files to be detected")
		}
		if analysis.TotalChanges == 0 {
			t.Error("Expected to detect sanitization changes")
		}

		// Check that we detected expected change types
		expectedTypes := []string{"mention", "bot_trigger", "url"}
		for _, expectedType := range expectedTypes {
			if count, exists := analysis.ChangesByType[expectedType]; !exists || count == 0 {
				t.Errorf("Expected to detect %s changes, got count: %d", expectedType, count)
			}
		}

		// Clean up
		os.Remove(sanitizedPath)
		os.Remove(auditLogPath)
	})

	// Test case 4: Content truncation detection
	t.Run("ContentTruncation", func(t *testing.T) {
		// Create sanitized output with truncation message
		sanitizedPath := filepath.Join(tmpDir, "safe_output.jsonl")
		sanitizedContent := `{"type":"text","text":"partial content\n[Content truncated due to length]"}`
		if err := os.WriteFile(sanitizedPath, []byte(sanitizedContent), 0644); err != nil {
			t.Fatal(err)
		}

		// Create audit log with truncation change
		auditLogPath := filepath.Join(tmpDir, "sanitization_audit.json")
		auditLogContent := `{
			"timestamp": "2023-01-01T00:00:00Z",
			"total_changes": 1,
			"changes_by_type": {
				"truncation": 1
			},
			"changes": [
				{
					"type": "truncation",
					"original": "very long content that exceeds limits",
					"sanitized": "partial content\n[Content truncated due to length]",
					"line_number": -1,
					"description": "Content truncated: 50000 chars â†’ 524288 chars max",
					"context": ""
				}
			]
		}`
		if err := os.WriteFile(auditLogPath, []byte(auditLogContent), 0644); err != nil {
			t.Fatal(err)
		}

		run := WorkflowRun{DatabaseID: 12348}
		analysis, err := analyzeSanitizationChanges(tmpDir, run, false)

		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
		if !analysis.WasContentTruncated {
			t.Error("Expected content truncation to be detected")
		}
		if analysis.TruncationReason != "length" {
			t.Errorf("Expected truncation reason 'length', got: %s", analysis.TruncationReason)
		}

		// Clean up
		os.Remove(sanitizedPath)
		os.Remove(auditLogPath)
	})
}
func TestGenerateSanitizationSummary(t *testing.T) {
	tests := []struct {
		name     string
		analysis *SanitizationAnalysis
		expected string
	}{
		{
			name: "NoChanges",
			analysis: &SanitizationAnalysis{
				TotalChanges:  0,
				ChangesByType: make(map[string]int),
			},
			expected: "No sanitization changes detected",
		},
		{
			name: "SingleType",
			analysis: &SanitizationAnalysis{
				TotalChanges: 2,
				ChangesByType: map[string]int{
					"mention": 2,
				},
			},
			expected: "2 @mention(s)",
		},
		{
			name: "MultipleTypes",
			analysis: &SanitizationAnalysis{
				TotalChanges: 5,
				ChangesByType: map[string]int{
					"mention":     2,
					"url":         2,
					"bot_trigger": 1,
				},
			},
			expected: "2 @mention(s), 1 bot trigger(s), 2 URL(s) redacted",
		},
		{
			name: "WithTruncation",
			analysis: &SanitizationAnalysis{
				TotalChanges: 1,
				ChangesByType: map[string]int{
					"truncation": 1,
				},
			},
			expected: "content truncated",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generateSanitizationSummary(tt.analysis)

			// Since the order of map iteration is not guaranteed in Go,
			// we need to check that all expected parts are present
			// rather than exact string matching for multiple types
			if tt.analysis.TotalChanges <= 1 {
				if result != tt.expected {
					t.Errorf("Expected '%s', got '%s'", tt.expected, result)
				}
			} else {
				// For multiple types, check that all expected components are present
				for changeType, count := range tt.analysis.ChangesByType {
					var expectedPart string
					switch changeType {
					case "mention":
						expectedPart = fmt.Sprintf("%d @mention(s)", count)
					case "bot_trigger":
						expectedPart = fmt.Sprintf("%d bot trigger(s)", count)
					case "url":
						expectedPart = fmt.Sprintf("%d URL(s) redacted", count)
					case "truncation":
						expectedPart = "content truncated"
					}

					if expectedPart != "" && !strings.Contains(result, expectedPart) {
						t.Errorf("Expected result to contain '%s', got '%s'", expectedPart, result)
					}
				}
			}
		})
	}
}
