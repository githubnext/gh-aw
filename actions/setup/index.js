// Setup Activation Action
// Copies activation job files to the agent environment

const core = require('@actions/core');
const fs = require('fs');
const path = require('path');

// Embedded activation files will be inserted here during build
const FILES = {
    "add_reaction_and_edit_comment.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\nconst { getRunStartedMessage } = require(\"./messages_run_status.cjs\");\n\nasync function main() {\n  // Read inputs from environment variables\n  const reaction = process.env.GH_AW_REACTION || \"eyes\";\n  const command = process.env.GH_AW_COMMAND; // Only present for command workflows\n  const runId = context.runId;\n  const githubServer = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n  const runUrl = context.payload.repository ? `${context.payload.repository.html_url}/actions/runs/` : `/${context.repo.owner}/${context.repo.repo}/actions/runs/`;\n\n  core.info(`Reaction type: `);\n  core.info(`Command name: ${command || \"none\"}`);\n  core.info(`Run ID: `);\n  core.info(`Run URL: `);\n\n  // Validate reaction type\n  const validReactions = [\"+1\", \"-1\", \"laugh\", \"confused\", \"heart\", \"hooray\", \"rocket\", \"eyes\"];\n  if (!validReactions.includes(reaction)) {\n    core.setFailed(`Invalid reaction type: . Valid reactions are: ${validReactions.join(\", \")}`);\n    return;\n  }\n\n  // Determine the API endpoint based on the event type\n  let reactionEndpoint;\n  let commentUpdateEndpoint;\n  let shouldCreateComment = false;\n  const eventName = context.eventName;\n  const owner = context.repo.owner;\n  const repo = context.repo.repo;\n\n  try {\n    switch (eventName) {\n      case \"issues\":\n        const issueNumber = context.payload?.issue?.number;\n        if (!issueNumber) {\n          core.setFailed(\"Issue number not found in event payload\");\n          return;\n        }\n        reactionEndpoint = `/repos///issues//reactions`;\n        commentUpdateEndpoint = `/repos///issues//comments`;\n        // Create comments for all workflows using reactions\n        shouldCreateComment = true;\n        break;\n\n      case \"issue_comment\":\n        const commentId = context.payload?.comment?.id;\n        const issueNumberForComment = context.payload?.issue?.number;\n        if (!commentId) {\n          core.setFailed(\"Comment ID not found in event payload\");\n          return;\n        }\n        if (!issueNumberForComment) {\n          core.setFailed(\"Issue number not found in event payload\");\n          return;\n        }\n        reactionEndpoint = `/repos///issues/comments//reactions`;\n        // Create new comment on the issue itself, not on the comment\n        commentUpdateEndpoint = `/repos///issues//comments`;\n        // Create comments for all workflows using reactions\n        shouldCreateComment = true;\n        break;\n\n      case \"pull_request\":\n        const prNumber = context.payload?.pull_request?.number;\n        if (!prNumber) {\n          core.setFailed(\"Pull request number not found in event payload\");\n          return;\n        }\n        // PRs are \"issues\" for the reactions endpoint\n        reactionEndpoint = `/repos///issues//reactions`;\n        commentUpdateEndpoint = `/repos///issues//comments`;\n        // Create comments for all workflows using reactions\n        shouldCreateComment = true;\n        break;\n\n      case \"pull_request_review_comment\":\n        const reviewCommentId = context.payload?.comment?.id;\n        const prNumberForReviewComment = context.payload?.pull_request?.number;\n        if (!reviewCommentId) {\n          core.setFailed(\"Review comment ID not found in event payload\");\n          return;\n        }\n        if (!prNumberForReviewComment) {\n          core.setFailed(\"Pull request number not found in event payload\");\n          return;\n        }\n        reactionEndpoint = `/repos///pulls/comments//reactions`;\n        // Create new comment on the PR itself (using issues endpoint since PRs are issues)\n        commentUpdateEndpoint = `/repos///issues//comments`;\n        // Create comments for all workflows using reactions\n        shouldCreateComment = true;\n        break;\n\n      case \"discussion\":\n        const discussionNumber = context.payload?.discussion?.number;\n        if (!discussionNumber) {\n          core.setFailed(\"Discussion number not found in event payload\");\n          return;\n        }\n        // Discussions use GraphQL API - get the node ID\n        const discussion = await getDiscussionId(owner, repo, discussionNumber);\n        reactionEndpoint = discussion.id; // Store node ID for GraphQL\n        commentUpdateEndpoint = `discussion:`; // Special format to indicate discussion\n        // Create comments for all workflows using reactions\n        shouldCreateComment = true;\n        break;\n\n      case \"discussion_comment\":\n        const discussionCommentNumber = context.payload?.discussion?.number;\n        const discussionCommentId = context.payload?.comment?.id;\n        if (!discussionCommentNumber || !discussionCommentId) {\n          core.setFailed(\"Discussion or comment information not found in event payload\");\n          return;\n        }\n        // Get the comment node ID from the payload\n        const commentNodeId = context.payload?.comment?.node_id;\n        if (!commentNodeId) {\n          core.setFailed(\"Discussion comment node ID not found in event payload\");\n          return;\n        }\n        reactionEndpoint = commentNodeId; // Store node ID for GraphQL\n        commentUpdateEndpoint = `discussion_comment::`; // Special format\n        // Create comments for all workflows using reactions\n        shouldCreateComment = true;\n        break;\n\n      default:\n        core.setFailed(`Unsupported event type: `);\n        return;\n    }\n\n    core.info(`Reaction API endpoint: `);\n\n    // Add reaction first\n    // For discussions, reactionEndpoint is a node ID (GraphQL), otherwise it's a REST API path\n    const isDiscussionEvent = eventName === \"discussion\" || eventName === \"discussion_comment\";\n    if (isDiscussionEvent) {\n      await addDiscussionReaction(reactionEndpoint, reaction);\n    } else {\n      await addReaction(reactionEndpoint, reaction);\n    }\n\n    // Then add comment if applicable\n    if (shouldCreateComment \u0026\u0026 commentUpdateEndpoint) {\n      core.info(`Comment endpoint: `);\n      await addCommentWithWorkflowLink(commentUpdateEndpoint, runUrl, eventName);\n    } else {\n      core.info(`Skipping comment for event type: `);\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    core.error(`Failed to process reaction and comment creation: `);\n    core.setFailed(`Failed to process reaction and comment creation: `);\n  }\n}\n\n/**\n * Add a reaction to a GitHub issue, PR, or comment using REST API\n * @param {string} endpoint - The GitHub API endpoint to add the reaction to\n * @param {string} reaction - The reaction type to add\n */\nasync function addReaction(endpoint, reaction) {\n  const response = await github.request(\"POST \" + endpoint, {\n    content: reaction,\n    headers: {\n      Accept: \"application/vnd.github+json\",\n    },\n  });\n\n  const reactionId = response.data?.id;\n  if (reactionId) {\n    core.info(`Successfully added reaction:  (id: )`);\n    core.setOutput(\"reaction-id\", reactionId.toString());\n  } else {\n    core.info(`Successfully added reaction: `);\n    core.setOutput(\"reaction-id\", \"\");\n  }\n}\n\n/**\n * Add a reaction to a GitHub discussion or discussion comment using GraphQL\n * @param {string} subjectId - The node ID of the discussion or comment\n * @param {string} reaction - The reaction type to add (mapped to GitHub's ReactionContent enum)\n */\nasync function addDiscussionReaction(subjectId, reaction) {\n  // Map reaction names to GitHub's GraphQL ReactionContent enum\n  const reactionMap = {\n    \"+1\": \"THUMBS_UP\",\n    \"-1\": \"THUMBS_DOWN\",\n    laugh: \"LAUGH\",\n    confused: \"CONFUSED\",\n    heart: \"HEART\",\n    hooray: \"HOORAY\",\n    rocket: \"ROCKET\",\n    eyes: \"EYES\",\n  };\n\n  const reactionContent = reactionMap[reaction];\n  if (!reactionContent) {\n    throw new Error(`Invalid reaction type for GraphQL: `);\n  }\n\n  const result = await github.graphql(\n    `\n    mutation(: ID!, : ReactionContent!) {\n      addReaction(input: { subjectId: , content:  }) {\n        reaction {\n          id\n          content\n        }\n      }\n    }`,\n    { subjectId, content: reactionContent }\n  );\n\n  const reactionId = result.addReaction.reaction.id;\n  core.info(`Successfully added reaction:  (id: )`);\n  core.setOutput(\"reaction-id\", reactionId);\n}\n\n/**\n * Get the node ID for a discussion\n * @param {string} owner - Repository owner\n * @param {string} repo - Repository name\n * @param {number} discussionNumber - Discussion number\n * @returns {Promise\u003c{id: string, url: string}\u003e} Discussion details\n */\nasync function getDiscussionId(owner, repo, discussionNumber) {\n  const { repository } = await github.graphql(\n    `\n    query(: String!, : String!, : Int!) {\n      repository(owner: , name: ) {\n        discussion(number: ) { \n          id \n          url\n        }\n      }\n    }`,\n    { owner, repo, num: discussionNumber }\n  );\n\n  if (!repository || !repository.discussion) {\n    throw new Error(`Discussion # not found in /`);\n  }\n\n  return {\n    id: repository.discussion.id,\n    url: repository.discussion.url,\n  };\n}\n\n/**\n * Get the node ID for a discussion comment\n * @param {string} owner - Repository owner\n * @param {string} repo - Repository name\n * @param {number} discussionNumber - Discussion number\n * @param {number} commentId - Comment ID (database ID, not node ID)\n * @returns {Promise\u003c{id: string, url: string}\u003e} Comment details\n */\nasync function getDiscussionCommentId(owner, repo, discussionNumber, commentId) {\n  // First, get the discussion ID\n  const discussion = await getDiscussionId(owner, repo, discussionNumber);\n  if (!discussion) throw new Error(`Discussion # not found in /`);\n\n  // Then fetch the comment by traversing discussion comments\n  // Note: GitHub's GraphQL API doesn't provide a direct way to query comment by database ID\n  // We need to use the comment's node ID from the event payload if available\n  // For now, we'll use a simplified approach - the commentId from context.payload.comment.node_id\n\n  // If the event payload provides node_id, we can use it directly\n  // Otherwise, this would need to fetch all comments and find the matching one\n  const nodeId = context.payload?.comment?.node_id;\n  if (nodeId) {\n    return {\n      id: nodeId,\n      url: context.payload.comment?.html_url || discussion?.url,\n    };\n  }\n\n  throw new Error(`Discussion comment node ID not found in event payload for comment `);\n}\n\n/**\n * Add a comment with a workflow run link\n * @param {string} endpoint - The GitHub API endpoint to create the comment (or special format for discussions)\n * @param {string} runUrl - The URL of the workflow run\n * @param {string} eventName - The event type (to determine the comment text)\n */\nasync function addCommentWithWorkflowLink(endpoint, runUrl, eventName) {\n  try {\n    // Get workflow name from environment variable\n    const workflowName = process.env.GH_AW_WORKFLOW_NAME || \"Workflow\";\n\n    // Determine the event type description\n    let eventTypeDescription;\n    switch (eventName) {\n      case \"issues\":\n        eventTypeDescription = \"issue\";\n        break;\n      case \"pull_request\":\n        eventTypeDescription = \"pull request\";\n        break;\n      case \"issue_comment\":\n        eventTypeDescription = \"issue comment\";\n        break;\n      case \"pull_request_review_comment\":\n        eventTypeDescription = \"pull request review comment\";\n        break;\n      case \"discussion\":\n        eventTypeDescription = \"discussion\";\n        break;\n      case \"discussion_comment\":\n        eventTypeDescription = \"discussion comment\";\n        break;\n      default:\n        eventTypeDescription = \"event\";\n    }\n\n    // Use getRunStartedMessage for the workflow link text (supports custom messages)\n    const workflowLinkText = getRunStartedMessage({\n      workflowName: workflowName,\n      runUrl: runUrl,\n      eventType: eventTypeDescription,\n    });\n\n    // Add workflow-id and tracker-id markers for hide-older-comments feature\n    const workflowId = process.env.GITHUB_WORKFLOW || \"\";\n    const trackerId = process.env.GH_AW_TRACKER_ID || \"\";\n\n    let commentBody = workflowLinkText;\n\n    // Add lock notice if lock-for-agent is enabled for issues or issue_comment\n    const lockForAgent = process.env.GH_AW_LOCK_FOR_AGENT === \"true\";\n    if (lockForAgent \u0026\u0026 (eventName === \"issues\" || eventName === \"issue_comment\")) {\n      commentBody += \"\\n\\nüîí This issue has been locked while the workflow is running to prevent concurrent modifications.\";\n    }\n\n    // Add workflow-id marker if available\n    if (workflowId) {\n      commentBody += `\\n\\n\u003c!-- workflow-id:  --\u003e`;\n    }\n\n    // Add tracker-id marker if available (for backwards compatibility)\n    if (trackerId) {\n      commentBody += `\\n\\n\u003c!-- tracker-id:  --\u003e`;\n    }\n\n    // Add comment type marker to identify this as a reaction comment\n    // This prevents it from being hidden by hide-older-comments\n    commentBody += `\\n\\n\u003c!-- comment-type: reaction --\u003e`;\n\n    // Handle discussion events specially\n    if (eventName === \"discussion\") {\n      // Parse discussion number from special format: \"discussion:NUMBER\"\n      const discussionNumber = parseInt(endpoint.split(\":\")[1], 10);\n\n      // Create a new comment on the discussion using GraphQL\n      const { repository } = await github.graphql(\n        `\n        query(: String!, : String!, : Int!) {\n          repository(owner: , name: ) {\n            discussion(number: ) { \n              id \n            }\n          }\n        }`,\n        { owner: context.repo.owner, repo: context.repo.repo, num: discussionNumber }\n      );\n\n      const discussionId = repository.discussion.id;\n\n      const result = await github.graphql(\n        `\n        mutation(: ID!, : String!) {\n          addDiscussionComment(input: { discussionId: , body:  }) {\n            comment { \n              id \n              url\n            }\n          }\n        }`,\n        { dId: discussionId, body: commentBody }\n      );\n\n      const comment = result.addDiscussionComment.comment;\n      core.info(`Successfully created discussion comment with workflow link`);\n      core.info(`Comment ID: ${comment.id}`);\n      core.info(`Comment URL: ${comment.url}`);\n      core.info(`Comment Repo: ${context.repo.owner}/${context.repo.repo}`);\n      core.setOutput(\"comment-id\", comment.id);\n      core.setOutput(\"comment-url\", comment.url);\n      core.setOutput(\"comment-repo\", `${context.repo.owner}/${context.repo.repo}`);\n      return;\n    } else if (eventName === \"discussion_comment\") {\n      // Parse discussion number from special format: \"discussion_comment:NUMBER:COMMENT_ID\"\n      const discussionNumber = parseInt(endpoint.split(\":\")[1], 10);\n\n      // Create a new comment on the discussion using GraphQL\n      const { repository } = await github.graphql(\n        `\n        query(: String!, : String!, : Int!) {\n          repository(owner: , name: ) {\n            discussion(number: ) { \n              id \n            }\n          }\n        }`,\n        { owner: context.repo.owner, repo: context.repo.repo, num: discussionNumber }\n      );\n\n      const discussionId = repository.discussion.id;\n\n      // Get the comment node ID to use as the parent for threading\n      const commentNodeId = context.payload?.comment?.node_id;\n\n      const result = await github.graphql(\n        `\n        mutation(: ID!, : String!, : ID!) {\n          addDiscussionComment(input: { discussionId: , body: , replyToId:  }) {\n            comment { \n              id \n              url\n            }\n          }\n        }`,\n        { dId: discussionId, body: commentBody, replyToId: commentNodeId }\n      );\n\n      const comment = result.addDiscussionComment.comment;\n      core.info(`Successfully created discussion comment with workflow link`);\n      core.info(`Comment ID: ${comment.id}`);\n      core.info(`Comment URL: ${comment.url}`);\n      core.info(`Comment Repo: ${context.repo.owner}/${context.repo.repo}`);\n      core.setOutput(\"comment-id\", comment.id);\n      core.setOutput(\"comment-url\", comment.url);\n      core.setOutput(\"comment-repo\", `${context.repo.owner}/${context.repo.repo}`);\n      return;\n    }\n\n    // Create a new comment for non-discussion events\n    const createResponse = await github.request(\"POST \" + endpoint, {\n      body: commentBody,\n      headers: {\n        Accept: \"application/vnd.github+json\",\n      },\n    });\n\n    core.info(`Successfully created comment with workflow link`);\n    core.info(`Comment ID: ${createResponse.data.id}`);\n    core.info(`Comment URL: ${createResponse.data.html_url}`);\n    core.info(`Comment Repo: ${context.repo.owner}/${context.repo.repo}`);\n    core.setOutput(\"comment-id\", createResponse.data.id.toString());\n    core.setOutput(\"comment-url\", createResponse.data.html_url);\n    core.setOutput(\"comment-repo\", `${context.repo.owner}/${context.repo.repo}`);\n  } catch (error) {\n    // Don't fail the entire job if comment creation fails - just log it\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    core.warning(\"Failed to create comment with workflow link (This is not critical - the reaction was still added successfully): \" + errorMessage);\n  }\n}\n\nawait main();\n",
    "check_command_position.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Check if command is the first word in the triggering text\n * This prevents accidental command triggers from words appearing later in content\n */\nasync function main() {\n  const command = process.env.GH_AW_COMMAND;\n\n  if (!command) {\n    core.setFailed(\"Configuration error: GH_AW_COMMAND not specified.\");\n    return;\n  }\n\n  // Get the triggering text based on event type\n  let text = \"\";\n  const eventName = context.eventName;\n\n  try {\n    if (eventName === \"issues\") {\n      text = context.payload.issue?.body || \"\";\n    } else if (eventName === \"pull_request\") {\n      text = context.payload.pull_request?.body || \"\";\n    } else if (eventName === \"issue_comment\") {\n      text = context.payload.comment?.body || \"\";\n    } else if (eventName === \"pull_request_review_comment\") {\n      text = context.payload.comment?.body || \"\";\n    } else if (eventName === \"discussion\") {\n      text = context.payload.discussion?.body || \"\";\n    } else if (eventName === \"discussion_comment\") {\n      text = context.payload.comment?.body || \"\";\n    } else {\n      // For non-comment events, pass the check\n      core.info(`Event  does not require command position check`);\n      core.setOutput(\"command_position_ok\", \"true\");\n      return;\n    }\n\n    // Expected command format: /command\n    const expectedCommand = `/`;\n\n    // If text is empty or doesn't contain the command at all, pass the check\n    if (!text || !text.includes(expectedCommand)) {\n      core.info(`No command '' found in text, passing check`);\n      core.setOutput(\"command_position_ok\", \"true\");\n      return;\n    }\n\n    // Normalize whitespace and get the first word\n    const trimmedText = text.trim();\n    const firstWord = trimmedText.split(/\\s+/)[0];\n\n    core.info(`Checking command position for: `);\n    core.info(`First word in text: `);\n\n    if (firstWord === expectedCommand) {\n      core.info(`‚úì Command '' is at the start of the text`);\n      core.setOutput(\"command_position_ok\", \"true\");\n    } else {\n      core.warning(`‚ö†Ô∏è Command '' is not the first word (found: ''). Workflow will be skipped.`);\n      core.setOutput(\"command_position_ok\", \"false\");\n    }\n  } catch (error) {\n    core.setFailed(error instanceof Error ? error.message : String(error));\n  }\n}\n\nawait main();\n",
    "check_skip_if_match.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\nasync function main() {\n  const skipQuery = process.env.GH_AW_SKIP_QUERY;\n  const workflowName = process.env.GH_AW_WORKFLOW_NAME;\n  const maxMatchesStr = process.env.GH_AW_SKIP_MAX_MATCHES || \"1\";\n\n  if (!skipQuery) {\n    core.setFailed(\"Configuration error: GH_AW_SKIP_QUERY not specified.\");\n    return;\n  }\n\n  if (!workflowName) {\n    core.setFailed(\"Configuration error: GH_AW_WORKFLOW_NAME not specified.\");\n    return;\n  }\n\n  const maxMatches = parseInt(maxMatchesStr, 10);\n  if (isNaN(maxMatches) || maxMatches \u003c 1) {\n    core.setFailed(`Configuration error: GH_AW_SKIP_MAX_MATCHES must be a positive integer, got \"\".`);\n    return;\n  }\n\n  core.info(`Checking skip-if-match query: `);\n  core.info(`Maximum matches threshold: `);\n\n  // Get repository information from context\n  const { owner, repo } = context.repo;\n\n  // Scope the query to the current repository\n  const scopedQuery = ` repo:/`;\n\n  core.info(`Scoped query: `);\n\n  try {\n    // Search for issues and pull requests using the GitHub API\n    // We only need to know if the count reaches the threshold\n    const response = await github.rest.search.issuesAndPullRequests({\n      q: scopedQuery,\n      per_page: 1, // We only need the count, not the items\n    });\n\n    const totalCount = response.data.total_count;\n    core.info(`Search found  matching items`);\n\n    if (totalCount \u003e= maxMatches) {\n      core.warning(`üîç Skip condition matched ( items found, threshold: ). Workflow execution will be prevented by activation job.`);\n      core.setOutput(\"skip_check_ok\", \"false\");\n      return;\n    }\n\n    core.info(`‚úì Found  matches (below threshold of ), workflow can proceed`);\n    core.setOutput(\"skip_check_ok\", \"true\");\n  } catch (error) {\n    core.setFailed(`Failed to execute search query: ${error instanceof Error ? error.message : String(error)}`);\n    return;\n  }\n}\nawait main();\n",
    "check_stop_time.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\nasync function main() {\n  const stopTime = process.env.GH_AW_STOP_TIME;\n  const workflowName = process.env.GH_AW_WORKFLOW_NAME;\n\n  if (!stopTime) {\n    core.setFailed(\"Configuration error: GH_AW_STOP_TIME not specified.\");\n    return;\n  }\n\n  if (!workflowName) {\n    core.setFailed(\"Configuration error: GH_AW_WORKFLOW_NAME not specified.\");\n    return;\n  }\n\n  core.info(`Checking stop-time limit: `);\n\n  // Parse the stop time (format: \"YYYY-MM-DD HH:MM:SS\")\n  const stopTimeDate = new Date(stopTime);\n\n  if (isNaN(stopTimeDate.getTime())) {\n    core.setFailed(`Invalid stop-time format: . Expected format: YYYY-MM-DD HH:MM:SS`);\n    return;\n  }\n\n  const currentTime = new Date();\n  core.info(`Current time: ${currentTime.toISOString()}`);\n  core.info(`Stop time: ${stopTimeDate.toISOString()}`);\n\n  if (currentTime \u003e= stopTimeDate) {\n    core.warning(`‚è∞ Stop time reached. Workflow execution will be prevented by activation job.`);\n    core.setOutput(\"stop_time_ok\", \"false\");\n    return;\n  }\n\n  core.setOutput(\"stop_time_ok\", \"true\");\n}\nawait main();\n",
    "check_workflow_timestamp_api.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Check workflow file timestamps using GitHub API to detect outdated lock files\n * This script compares the last commit time of the source .md file\n * with the compiled .lock.yml file and warns if recompilation is needed\n */\n\nasync function main() {\n  const workflowFile = process.env.GH_AW_WORKFLOW_FILE;\n\n  if (!workflowFile) {\n    core.setFailed(\"Configuration error: GH_AW_WORKFLOW_FILE not available.\");\n    return;\n  }\n\n  // Construct file paths\n  const workflowBasename = workflowFile.replace(\".lock.yml\", \"\");\n  const workflowMdPath = `.github/workflows/.md`;\n  const lockFilePath = `.github/workflows/`;\n\n  core.info(`Checking workflow timestamps using GitHub API:`);\n  core.info(`  Source: `);\n  core.info(`  Lock file: `);\n\n  const { owner, repo } = context.repo;\n  const ref = context.sha;\n\n  // Helper function to get the last commit for a file\n  async function getLastCommitForFile(path) {\n    try {\n      const response = await github.rest.repos.listCommits({\n        owner,\n        repo,\n        path,\n        per_page: 1,\n        sha: ref,\n      });\n\n      if (response.data \u0026\u0026 response.data.length \u003e 0) {\n        const commit = response.data[0];\n        return {\n          sha: commit.sha,\n          date: commit.commit.committer.date,\n          message: commit.commit.message,\n        };\n      }\n      return null;\n    } catch (error) {\n      core.info(`Could not fetch commit for : ${error.message}`);\n      return null;\n    }\n  }\n\n  // Fetch last commits for both files\n  const workflowCommit = await getLastCommitForFile(workflowMdPath);\n  const lockCommit = await getLastCommitForFile(lockFilePath);\n\n  // Handle cases where files don't exist\n  if (!workflowCommit) {\n    core.info(`Source file does not exist: `);\n  }\n\n  if (!lockCommit) {\n    core.info(`Lock file does not exist: `);\n  }\n\n  if (!workflowCommit || !lockCommit) {\n    core.info(\"Skipping timestamp check - one or both files not found\");\n    return;\n  }\n\n  // Parse dates for comparison\n  const workflowDate = new Date(workflowCommit.date);\n  const lockDate = new Date(lockCommit.date);\n\n  core.info(`  Source last commit: ${workflowDate.toISOString()} (${workflowCommit.sha.substring(0, 7)})`);\n  core.info(`  Lock last commit: ${lockDate.toISOString()} (${lockCommit.sha.substring(0, 7)})`);\n\n  // Check if workflow file is newer than lock file\n  if (workflowDate \u003e lockDate) {\n    const warningMessage = `WARNING: Lock file '' is outdated! The workflow file '' has been modified more recently. Run 'gh aw compile' to regenerate the lock file.`;\n\n    core.error(warningMessage);\n\n    // Format timestamps and commits for display\n    const workflowTimestamp = workflowDate.toISOString();\n    const lockTimestamp = lockDate.toISOString();\n\n    // Add summary to GitHub Step Summary\n    let summary = core.summary\n      .addRaw(\"### ‚ö†Ô∏è Workflow Lock File Warning\\n\\n\")\n      .addRaw(\"**WARNING**: Lock file is outdated and needs to be regenerated.\\n\\n\")\n      .addRaw(\"**Files:**\\n\")\n      .addRaw(`- Source: \\`\\`\\n`)\n      .addRaw(`  - Last commit: \\n`)\n      .addRaw(`  - Commit SHA: [\\`${workflowCommit.sha.substring(0, 7)}\\`](https://github.com///commit/${workflowCommit.sha})\\n`)\n      .addRaw(`- Lock: \\`\\`\\n`)\n      .addRaw(`  - Last commit: \\n`)\n      .addRaw(`  - Commit SHA: [\\`${lockCommit.sha.substring(0, 7)}\\`](https://github.com///commit/${lockCommit.sha})\\n\\n`)\n      .addRaw(\"**Action Required:** Run `gh aw compile` to regenerate the lock file.\\n\\n\");\n\n    await summary.write();\n  } else if (workflowCommit.sha === lockCommit.sha) {\n    core.info(\"‚úÖ Lock file is up to date (same commit)\");\n  } else {\n    core.info(\"‚úÖ Lock file is up to date\");\n  }\n}\n\nmain().catch(error =\u003e {\n  core.setFailed(error instanceof Error ? error.message : String(error));\n});\n",
    "compute_text.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Sanitizes content for safe output in GitHub Actions\n * @param {string} content - The content to sanitize\n * @returns {string} The sanitized content\n */\nconst { sanitizeIncomingText, writeRedactedDomainsLog } = require(\"./sanitize_incoming_text.cjs\");\n\nasync function main() {\n  let text = \"\";\n\n  const actor = context.actor;\n  const { owner, repo } = context.repo;\n\n  // Check if the actor has repository access (admin, maintain permissions)\n  const repoPermission = await github.rest.repos.getCollaboratorPermissionLevel({\n    owner: owner,\n    repo: repo,\n    username: actor,\n  });\n\n  const permission = repoPermission.data.permission;\n  core.info(`Repository permission level: `);\n\n  if (permission !== \"admin\" \u0026\u0026 permission !== \"maintain\") {\n    core.setOutput(\"text\", \"\");\n    return;\n  }\n\n  // Determine current body text based on event context\n  switch (context.eventName) {\n    case \"issues\":\n      // For issues: title + body\n      if (context.payload.issue) {\n        const title = context.payload.issue.title || \"\";\n        const body = context.payload.issue.body || \"\";\n        text = `\\n\\n`;\n      }\n      break;\n\n    case \"pull_request\":\n      // For pull requests: title + body\n      if (context.payload.pull_request) {\n        const title = context.payload.pull_request.title || \"\";\n        const body = context.payload.pull_request.body || \"\";\n        text = `\\n\\n`;\n      }\n      break;\n\n    case \"pull_request_target\":\n      // For pull request target events: title + body\n      if (context.payload.pull_request) {\n        const title = context.payload.pull_request.title || \"\";\n        const body = context.payload.pull_request.body || \"\";\n        text = `\\n\\n`;\n      }\n      break;\n\n    case \"issue_comment\":\n      // For issue comments: comment body\n      if (context.payload.comment) {\n        text = context.payload.comment.body || \"\";\n      }\n      break;\n\n    case \"pull_request_review_comment\":\n      // For PR review comments: comment body\n      if (context.payload.comment) {\n        text = context.payload.comment.body || \"\";\n      }\n      break;\n\n    case \"pull_request_review\":\n      // For PR reviews: review body\n      if (context.payload.review) {\n        text = context.payload.review.body || \"\";\n      }\n      break;\n\n    case \"discussion\":\n      // For discussions: title + body\n      if (context.payload.discussion) {\n        const title = context.payload.discussion.title || \"\";\n        const body = context.payload.discussion.body || \"\";\n        text = `\\n\\n`;\n      }\n      break;\n\n    case \"discussion_comment\":\n      // For discussion comments: comment body\n      if (context.payload.comment) {\n        text = context.payload.comment.body || \"\";\n      }\n      break;\n\n    case \"release\":\n      // For releases: name + body\n      if (context.payload.release) {\n        const name = context.payload.release.name || context.payload.release.tag_name || \"\";\n        const body = context.payload.release.body || \"\";\n        text = `\\n\\n`;\n      }\n      break;\n\n    case \"workflow_dispatch\":\n      // For workflow dispatch: check for release_url or release_id in inputs\n      if (context.payload.inputs) {\n        const releaseUrl = context.payload.inputs.release_url;\n        const releaseId = context.payload.inputs.release_id;\n\n        // If release_url is provided, extract owner/repo/tag\n        if (releaseUrl) {\n          const urlMatch = releaseUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)\\/releases\\/tag\\/([^\\/]+)/);\n          if (urlMatch) {\n            const [, urlOwner, urlRepo, tag] = urlMatch;\n            try {\n              const { data: release } = await github.rest.repos.getReleaseByTag({\n                owner: urlOwner,\n                repo: urlRepo,\n                tag: tag,\n              });\n              const name = release.name || release.tag_name || \"\";\n              const body = release.body || \"\";\n              text = `\\n\\n`;\n            } catch (error) {\n              core.warning(`Failed to fetch release from URL: ${error instanceof Error ? error.message : String(error)}`);\n            }\n          }\n        } else if (releaseId) {\n          // If release_id is provided, fetch the release\n          try {\n            const { data: release } = await github.rest.repos.getRelease({\n              owner: owner,\n              repo: repo,\n              release_id: parseInt(releaseId, 10),\n            });\n            const name = release.name || release.tag_name || \"\";\n            const body = release.body || \"\";\n            text = `\\n\\n`;\n          } catch (error) {\n            core.warning(`Failed to fetch release by ID: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        }\n      }\n      break;\n\n    default:\n      // Default: empty text\n      text = \"\";\n      break;\n  }\n\n  // Sanitize the text before output\n  // All mentions are escaped (wrapped in backticks) to prevent unintended notifications\n  // Mention filtering will be applied by the agent output collector\n  const sanitizedText = sanitizeIncomingText(text);\n\n  // Display sanitized text in logs\n  core.info(`text: `);\n\n  // Set the sanitized text as output\n  core.setOutput(\"text\", sanitizedText);\n\n  // Write redacted URL domains to log file if any were collected\n  const logPath = writeRedactedDomainsLog();\n  if (logPath) {\n    core.info(`Redacted URL domains written to: `);\n  }\n}\n\nawait main();\n",
    "lock-issue.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Lock a GitHub issue without providing a reason\n * This script is used in the activation job when lock-for-agent is enabled\n * to prevent concurrent modifications during agent workflow execution\n */\n\nasync function main() {\n  // Log actor and event information for debugging\n  core.info(`Lock-issue debug: actor=${context.actor}, eventName=${context.eventName}`);\n\n  // Get issue number from context\n  const issueNumber = context.issue.number;\n\n  if (!issueNumber) {\n    core.setFailed(\"Issue number not found in context\");\n    return;\n  }\n\n  const owner = context.repo.owner;\n  const repo = context.repo.repo;\n\n  core.info(`Lock-issue debug: owner=, repo=, issueNumber=`);\n\n  try {\n    // Check if issue is already locked\n    core.info(`Checking if issue # is already locked`);\n    const { data: issue } = await github.rest.issues.get({\n      owner,\n      repo,\n      issue_number: issueNumber,\n    });\n\n    if (issue.locked) {\n      core.info(`‚ÑπÔ∏è Issue # is already locked, skipping lock operation`);\n      core.setOutput(\"locked\", \"false\");\n      return;\n    }\n\n    core.info(`Locking issue # for agent workflow execution`);\n\n    // Lock the issue without providing a lock_reason parameter\n    await github.rest.issues.lock({\n      owner,\n      repo,\n      issue_number: issueNumber,\n    });\n\n    core.info(`‚úÖ Successfully locked issue #`);\n    // Set output to indicate the issue was locked and needs to be unlocked\n    core.setOutput(\"locked\", \"true\");\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    core.error(`Failed to lock issue: `);\n    core.setFailed(`Failed to lock issue #: `);\n    core.setOutput(\"locked\", \"false\");\n  }\n}\n\nawait main();\n",
    "messages_core.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Core Message Utilities Module\n *\n * This module provides shared utilities for message template processing.\n * It includes configuration parsing and template rendering functions.\n *\n * Supported placeholders:\n * - {workflow_name} - Name of the workflow\n * - {run_url} - URL to the workflow run\n * - {workflow_source} - Source specification (owner/repo/path@ref)\n * - {workflow_source_url} - GitHub URL for the workflow source\n * - {triggering_number} - Issue/PR/Discussion number that triggered this workflow\n * - {operation} - Operation name (for staged mode titles/descriptions)\n * - {event_type} - Event type description (for run-started messages)\n * - {status} - Workflow status text (for run-failure messages)\n *\n * Both camelCase and snake_case placeholder formats are supported.\n */\n\n/**\n * @typedef {Object} SafeOutputMessages\n * @property {string} [footer] - Custom footer message template\n * @property {string} [footerInstall] - Custom installation instructions template\n * @property {string} [stagedTitle] - Custom staged mode title template\n * @property {string} [stagedDescription] - Custom staged mode description template\n * @property {string} [runStarted] - Custom workflow activation message template\n * @property {string} [runSuccess] - Custom workflow success message template\n * @property {string} [runFailure] - Custom workflow failure message template\n * @property {string} [detectionFailure] - Custom detection job failure message template\n * @property {string} [closeOlderDiscussion] - Custom message for closing older discussions as outdated\n */\n\n/**\n * Get the safe-output messages configuration from environment variable.\n * @returns {SafeOutputMessages|null} Parsed messages config or null if not set\n */\nfunction getMessages() {\n  const messagesEnv = process.env.GH_AW_SAFE_OUTPUT_MESSAGES;\n  if (!messagesEnv) {\n    return null;\n  }\n\n  try {\n    // Parse JSON with camelCase keys from Go struct (using json struct tags)\n    return JSON.parse(messagesEnv);\n  } catch (error) {\n    core.warning(`Failed to parse GH_AW_SAFE_OUTPUT_MESSAGES: ${error instanceof Error ? error.message : String(error)}`);\n    return null;\n  }\n}\n\n/**\n * Replace placeholders in a template string with values from context.\n * Supports {key} syntax for placeholder replacement.\n * @param {string} template - Template string with {key} placeholders\n * @param {Record\u003cstring, string|number|undefined\u003e} context - Key-value pairs for replacement\n * @returns {string} Template with placeholders replaced\n */\nfunction renderTemplate(template, context) {\n  return template.replace(/\\{(\\w+)\\}/g, (match, key) =\u003e {\n    const value = context[key];\n    return value !== undefined \u0026\u0026 value !== null ? String(value) : match;\n  });\n}\n\n/**\n * Convert context object keys to snake_case for template rendering\n * @param {Record\u003cstring, any\u003e} obj - Object with camelCase keys\n * @returns {Record\u003cstring, any\u003e} Object with snake_case keys\n */\nfunction toSnakeCase(obj) {\n  /** @type {Record\u003cstring, any\u003e} */\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    // Convert camelCase to snake_case\n    const snakeKey = key.replace(/([A-Z])/g, \"_\").toLowerCase();\n    result[snakeKey] = value;\n    // Also keep original key for backwards compatibility\n    result[key] = value;\n  }\n  return result;\n}\n\nmodule.exports = {\n  getMessages,\n  renderTemplate,\n  toSnakeCase,\n};\n",
    "messages_run_status.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Run Status Message Module\n *\n * This module provides run status messages (started, success, failure)\n * for workflow execution notifications.\n */\n\nconst { getMessages, renderTemplate, toSnakeCase } = require(\"./messages_core.cjs\");\n\n/**\n * @typedef {Object} RunStartedContext\n * @property {string} workflowName - Name of the workflow\n * @property {string} runUrl - URL of the workflow run\n * @property {string} eventType - Event type description (e.g., \"issue\", \"pull request\", \"discussion\")\n */\n\n/**\n * Get the run-started message, using custom template if configured.\n * @param {RunStartedContext} ctx - Context for run-started message generation\n * @returns {string} Run-started message\n */\nfunction getRunStartedMessage(ctx) {\n  const messages = getMessages();\n\n  // Create context with both camelCase and snake_case keys\n  const templateContext = toSnakeCase(ctx);\n\n  // Default run-started template - pirate themed! üè¥‚Äç‚ò†Ô∏è\n  const defaultMessage = \"‚öì Avast! [{workflow_name}]({run_url}) be settin' sail on this {event_type}! üè¥‚Äç‚ò†Ô∏è\";\n\n  // Use custom message if configured\n  return messages?.runStarted ? renderTemplate(messages.runStarted, templateContext) : renderTemplate(defaultMessage, templateContext);\n}\n\n/**\n * @typedef {Object} RunSuccessContext\n * @property {string} workflowName - Name of the workflow\n * @property {string} runUrl - URL of the workflow run\n */\n\n/**\n * Get the run-success message, using custom template if configured.\n * @param {RunSuccessContext} ctx - Context for run-success message generation\n * @returns {string} Run-success message\n */\nfunction getRunSuccessMessage(ctx) {\n  const messages = getMessages();\n\n  // Create context with both camelCase and snake_case keys\n  const templateContext = toSnakeCase(ctx);\n\n  // Default run-success template - pirate themed! üè¥‚Äç‚ò†Ô∏è\n  const defaultMessage = \"üéâ Yo ho ho! [{workflow_name}]({run_url}) found the treasure and completed successfully! ‚öìüí∞\";\n\n  // Use custom message if configured\n  return messages?.runSuccess ? renderTemplate(messages.runSuccess, templateContext) : renderTemplate(defaultMessage, templateContext);\n}\n\n/**\n * @typedef {Object} RunFailureContext\n * @property {string} workflowName - Name of the workflow\n * @property {string} runUrl - URL of the workflow run\n * @property {string} status - Status text (e.g., \"failed\", \"was cancelled\", \"timed out\")\n */\n\n/**\n * Get the run-failure message, using custom template if configured.\n * @param {RunFailureContext} ctx - Context for run-failure message generation\n * @returns {string} Run-failure message\n */\nfunction getRunFailureMessage(ctx) {\n  const messages = getMessages();\n\n  // Create context with both camelCase and snake_case keys\n  const templateContext = toSnakeCase(ctx);\n\n  // Default run-failure template - pirate themed! üè¥‚Äç‚ò†Ô∏è\n  const defaultMessage = \"üíÄ Blimey! [{workflow_name}]({run_url}) {status} and walked the plank! No treasure today, matey! ‚ò†Ô∏è\";\n\n  // Use custom message if configured\n  return messages?.runFailure ? renderTemplate(messages.runFailure, templateContext) : renderTemplate(defaultMessage, templateContext);\n}\n\n/**\n * @typedef {Object} DetectionFailureContext\n * @property {string} workflowName - Name of the workflow\n * @property {string} runUrl - URL of the workflow run\n */\n\n/**\n * Get the detection-failure message, using custom template if configured.\n * @param {DetectionFailureContext} ctx - Context for detection-failure message generation\n * @returns {string} Detection-failure message\n */\nfunction getDetectionFailureMessage(ctx) {\n  const messages = getMessages();\n\n  // Create context with both camelCase and snake_case keys\n  const templateContext = toSnakeCase(ctx);\n\n  // Default detection-failure template\n  const defaultMessage = \"‚ö†Ô∏è Security scanning failed for [{workflow_name}]({run_url}). Review the logs for details.\";\n\n  // Use custom message if configured\n  return messages?.detectionFailure ? renderTemplate(messages.detectionFailure, templateContext) : renderTemplate(defaultMessage, templateContext);\n}\n\nmodule.exports = {\n  getRunStartedMessage,\n  getRunSuccessMessage,\n  getRunFailureMessage,\n  getDetectionFailureMessage,\n};\n",
    "sanitize_content_core.cjs": "// @ts-check\n/**\n * Core sanitization utilities without mention filtering\n * This module provides the base sanitization functions that don't require\n * mention resolution or filtering. It's designed to be imported by both\n * sanitize_content.cjs (full version) and sanitize_incoming_text.cjs (minimal version).\n */\n\n/**\n * Module-level set to collect redacted URL domains across sanitization calls.\n * @type {string[]}\n */\nconst redactedDomains = [];\n\n/**\n * Gets the list of redacted URL domains collected during sanitization.\n * @returns {string[]} Array of redacted domain strings\n */\nfunction getRedactedDomains() {\n  return [...redactedDomains];\n}\n\n/**\n * Adds a domain to the redacted domains list\n * @param {string} domain - Domain to add\n */\nfunction addRedactedDomain(domain) {\n  redactedDomains.push(domain);\n}\n\n/**\n * Clears the list of redacted URL domains.\n * Useful for testing or resetting state between operations.\n */\nfunction clearRedactedDomains() {\n  redactedDomains.length = 0;\n}\n\n/**\n * Writes the collected redacted URL domains to a log file.\n * Only creates the file if there are redacted domains.\n * @param {string} [filePath] - Path to write the log file. Defaults to /tmp/gh-aw/redacted-urls.log\n * @returns {string|null} The file path if written, null if no domains to write\n */\nfunction writeRedactedDomainsLog(filePath) {\n  if (redactedDomains.length === 0) {\n    return null;\n  }\n\n  const fs = require(\"fs\");\n  const path = require(\"path\");\n  const targetPath = filePath || \"/tmp/gh-aw/redacted-urls.log\";\n\n  // Ensure directory exists\n  const dir = path.dirname(targetPath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  // Write domains to file, one per line\n  fs.writeFileSync(targetPath, redactedDomains.join(\"\\n\") + \"\\n\");\n\n  return targetPath;\n}\n\n/**\n * Extract domains from a URL and return an array of domain variations\n * @param {string} url - The URL to extract domains from\n * @returns {string[]} Array of domain variations\n */\nfunction extractDomainsFromUrl(url) {\n  if (!url || typeof url !== \"string\") {\n    return [];\n  }\n\n  try {\n    // Parse the URL\n    const urlObj = new URL(url);\n    const hostname = urlObj.hostname.toLowerCase();\n\n    // Return both the exact hostname and common variations\n    const domains = [hostname];\n\n    // For github.com, add api and raw content domain variations\n    if (hostname === \"github.com\") {\n      domains.push(\"api.github.com\");\n      domains.push(\"raw.githubusercontent.com\");\n      domains.push(\"*.githubusercontent.com\");\n    }\n    // For custom GitHub Enterprise domains, add api. prefix and raw content variations\n    else if (!hostname.startsWith(\"api.\")) {\n      domains.push(\"api.\" + hostname);\n      // For GitHub Enterprise, raw content is typically served from raw.hostname\n      domains.push(\"raw.\" + hostname);\n    }\n\n    return domains;\n  } catch (e) {\n    // Invalid URL, return empty array\n    return [];\n  }\n}\n\n/**\n * Build the list of allowed domains from environment variables and GitHub context\n * @returns {string[]} Array of allowed domains\n */\nfunction buildAllowedDomains() {\n  const allowedDomainsEnv = process.env.GH_AW_ALLOWED_DOMAINS;\n  const defaultAllowedDomains = [\"github.com\", \"github.io\", \"githubusercontent.com\", \"githubassets.com\", \"github.dev\", \"codespaces.new\"];\n\n  let allowedDomains = allowedDomainsEnv\n    ? allowedDomainsEnv\n        .split(\",\")\n        .map(d =\u003e d.trim())\n        .filter(d =\u003e d)\n    : defaultAllowedDomains;\n\n  // Extract and add GitHub domains from GitHub context URLs\n  const githubServerUrl = process.env.GITHUB_SERVER_URL;\n  const githubApiUrl = process.env.GITHUB_API_URL;\n\n  if (githubServerUrl) {\n    const serverDomains = extractDomainsFromUrl(githubServerUrl);\n    allowedDomains = allowedDomains.concat(serverDomains);\n  }\n\n  if (githubApiUrl) {\n    const apiDomains = extractDomainsFromUrl(githubApiUrl);\n    allowedDomains = allowedDomains.concat(apiDomains);\n  }\n\n  // Remove duplicates\n  return [...new Set(allowedDomains)];\n}\n\n/**\n * Sanitize URL protocols - replace non-https with (redacted)\n * @param {string} s - The string to process\n * @returns {string} The string with non-https protocols redacted\n */\nfunction sanitizeUrlProtocols(s) {\n  // Match common non-https protocols\n  // This regex matches: protocol://domain or protocol:path or incomplete protocol://\n  // Examples: http://, ftp://, file://, data:, javascript:, mailto:, tel:, ssh://, git://\n  // The regex also matches incomplete protocols like \"http://\" or \"ftp://\" without a domain\n  // Note: No word boundary check to catch protocols even when preceded by word characters\n  return s.replace(/((?:http|ftp|file|ssh|git):\\/\\/([\\w.-]*)(?:[^\\s]*)|(?:data|javascript|vbscript|about|mailto|tel):[^\\s]+)/gi, (match, _fullMatch, domain) =\u003e {\n    // Extract domain for http/ftp/file/ssh/git protocols\n    if (domain) {\n      const domainLower = domain.toLowerCase();\n      const truncated = domainLower.length \u003e 12 ? domainLower.substring(0, 12) + \"...\" : domainLower;\n      if (typeof core !== \"undefined\" \u0026\u0026 core.info) {\n        core.info(`Redacted URL: `);\n      }\n      if (typeof core !== \"undefined\" \u0026\u0026 core.debug) {\n        core.debug(`Redacted URL (full): `);\n      }\n      addRedactedDomain(domainLower);\n    } else {\n      // For other protocols (data:, javascript:, etc.), track the protocol itself\n      const protocolMatch = match.match(/^([^:]+):/);\n      if (protocolMatch) {\n        const protocol = protocolMatch[1] + \":\";\n        // Truncate the matched URL for logging (keep first 12 chars + \"...\")\n        const truncated = match.length \u003e 12 ? match.substring(0, 12) + \"...\" : match;\n        if (typeof core !== \"undefined\" \u0026\u0026 core.info) {\n          core.info(`Redacted URL: `);\n        }\n        if (typeof core !== \"undefined\" \u0026\u0026 core.debug) {\n          core.debug(`Redacted URL (full): `);\n        }\n        addRedactedDomain(protocol);\n      }\n    }\n    return \"(redacted)\";\n  });\n}\n\n/**\n * Remove unknown domains\n * @param {string} s - The string to process\n * @param {string[]} allowed - List of allowed domains\n * @returns {string} The string with unknown domains redacted\n */\nfunction sanitizeUrlDomains(s, allowed) {\n  // Match HTTPS URLs with optional port and path\n  // This regex is designed to:\n  // 1. Match https:// URIs with explicit protocol\n  // 2. Capture the hostname/domain\n  // 3. Allow optional port (:8080)\n  // 4. Allow optional path and query string (but not trailing commas/periods)\n  // 5. Stop before another https:// URL in query params (using negative lookahead)\n  const httpsUrlRegex = /https:\\/\\/([\\w.-]+(?::\\d+)?)(\\/(?:(?!https:\\/\\/)[^\\s,])*)?/gi;\n\n  return s.replace(httpsUrlRegex, (match, hostnameWithPort, pathPart) =\u003e {\n    // Extract just the hostname (remove port if present)\n    const hostname = hostnameWithPort.split(\":\")[0].toLowerCase();\n    pathPart = pathPart || \"\";\n\n    // Check if domain is in the allowed list or is a subdomain of an allowed domain\n    const isAllowed = allowed.some(allowedDomain =\u003e {\n      const normalizedAllowed = allowedDomain.toLowerCase();\n\n      // Exact match\n      if (hostname === normalizedAllowed) {\n        return true;\n      }\n\n      // Wildcard match (*.example.com matches subdomain.example.com)\n      if (normalizedAllowed.startsWith(\"*.\")) {\n        const baseDomain = normalizedAllowed.substring(2); // Remove *.\n        return hostname.endsWith(\".\" + baseDomain) || hostname === baseDomain;\n      }\n\n      // Subdomain match (example.com matches subdomain.example.com)\n      return hostname.endsWith(\".\" + normalizedAllowed);\n    });\n\n    if (isAllowed) {\n      return match; // Keep the full URL as-is\n    } else {\n      // Redact the domain but preserve the protocol and structure for debugging\n      const truncated = hostname.length \u003e 12 ? hostname.substring(0, 12) + \"...\" : hostname;\n      if (typeof core !== \"undefined\" \u0026\u0026 core.info) {\n        core.info(`Redacted URL: `);\n      }\n      if (typeof core !== \"undefined\" \u0026\u0026 core.debug) {\n        core.debug(`Redacted URL (full): `);\n      }\n      addRedactedDomain(hostname);\n      return \"(redacted)\";\n    }\n  });\n}\n\n/**\n * Neutralizes commands at the start of text by wrapping them in backticks\n * @param {string} s - The string to process\n * @returns {string} The string with neutralized commands\n */\nfunction neutralizeCommands(s) {\n  const commandName = process.env.GH_AW_COMMAND;\n  if (!commandName) {\n    return s;\n  }\n\n  // Escape special regex characters in command name\n  const escapedCommand = commandName.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$\u0026\");\n\n  // Neutralize /command at the start of text (with optional leading whitespace)\n  // Only match at the start of the string or after leading whitespace\n  return s.replace(new RegExp(`^(\\\\s*)/()\\\\b`, \"i\"), \"`/`\");\n}\n\n/**\n * Neutralizes ALL @mentions by wrapping them in backticks\n * This is the core version without any filtering\n * @param {string} s - The string to process\n * @returns {string} The string with neutralized mentions\n */\nfunction neutralizeAllMentions(s) {\n  // Replace @name or @org/team outside code with `@name`\n  // No filtering - all mentions are neutralized\n  return s.replace(/(^|[^\\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\\/[A-Za-z0-9._-]+)?)/g, (m, p1, p2) =\u003e {\n    // Log when a mention is escaped to help debug issues\n    if (typeof core !== \"undefined\" \u0026\u0026 core.info) {\n      core.info(`Escaped mention: @ (not in allowed list)`);\n    }\n    return `\\`@\\``;\n  });\n}\n\n/**\n * Removes XML comments from content\n * @param {string} s - The string to process\n * @returns {string} The string with XML comments removed\n */\nfunction removeXmlComments(s) {\n  // Remove \u003c!-- comment --\u003e and malformed \u003c!--! comment --!\u003e\n  return s.replace(/\u003c!--[\\s\\S]*?--\u003e/g, \"\").replace(/\u003c!--[\\s\\S]*?--!\u003e/g, \"\");\n}\n\n/**\n * Converts XML/HTML tags to parentheses format to prevent injection\n * @param {string} s - The string to process\n * @returns {string} The string with XML tags converted to parentheses\n */\nfunction convertXmlTags(s) {\n  // Allow safe HTML tags: b, blockquote, br, code, details, em, h1‚Äìh6, hr, i, li, ol, p, pre, strong, sub, summary, sup, table, tbody, td, th, thead, tr, ul\n  const allowedTags = [\"b\", \"blockquote\", \"br\", \"code\", \"details\", \"em\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"li\", \"ol\", \"p\", \"pre\", \"strong\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"th\", \"thead\", \"tr\", \"ul\"];\n\n  // First, process CDATA sections specially - convert tags inside them and the CDATA markers\n  s = s.replace(/\u003c!\\[CDATA\\[([\\s\\S]*?)\\]\\]\u003e/g, (match, content) =\u003e {\n    // Convert tags inside CDATA content\n    const convertedContent = content.replace(/\u003c(\\/?[A-Za-z][A-Za-z0-9]*(?:[^\u003e]*?))\u003e/g, \"()\");\n    // Return with CDATA markers also converted to parentheses\n    return `(![CDATA[]])`;\n  });\n\n  // Convert opening tags: \u003ctag\u003e or \u003ctag attr=\"value\"\u003e to (tag) or (tag attr=\"value\")\n  // Convert closing tags: \u003c/tag\u003e to (/tag)\n  // Convert self-closing tags: \u003ctag/\u003e or \u003ctag /\u003e to (tag/) or (tag /)\n  // But preserve allowed safe tags\n  return s.replace(/\u003c(\\/?[A-Za-z!][^\u003e]*?)\u003e/g, (match, tagContent) =\u003e {\n    // Extract tag name from the content (handle closing tags and attributes)\n    const tagNameMatch = tagContent.match(/^\\/?\\s*([A-Za-z][A-Za-z0-9]*)/);\n    if (tagNameMatch) {\n      const tagName = tagNameMatch[1].toLowerCase();\n      if (allowedTags.includes(tagName)) {\n        return match; // Preserve allowed tags\n      }\n    }\n    return `()`; // Convert other tags to parentheses\n  });\n}\n\n/**\n * Neutralizes bot trigger phrases by wrapping them in backticks\n * @param {string} s - The string to process\n * @returns {string} The string with neutralized bot triggers\n */\nfunction neutralizeBotTriggers(s) {\n  // Neutralize common bot trigger phrases like \"fixes #123\", \"closes #asdfs\", etc.\n  return s.replace(/\\b(fixes?|closes?|resolves?|fix|close|resolve)\\s+#(\\w+)/gi, (match, action, ref) =\u003e `\\` #\\``);\n}\n\n/**\n * Apply truncation limits to content\n * @param {string} content - The content to truncate\n * @param {number} [maxLength] - Maximum length of content (default: 524288)\n * @returns {string} The truncated content\n */\nfunction applyTruncation(content, maxLength) {\n  maxLength = maxLength || 524288;\n  const lines = content.split(\"\\n\");\n  const maxLines = 65000;\n\n  // If content has too many lines, truncate by lines (primary limit)\n  if (lines.length \u003e maxLines) {\n    const truncationMsg = \"\\n[Content truncated due to line count]\";\n    const truncatedLines = lines.slice(0, maxLines).join(\"\\n\") + truncationMsg;\n\n    // If still too long after line truncation, shorten but keep the line count message\n    if (truncatedLines.length \u003e maxLength) {\n      return truncatedLines.substring(0, maxLength - truncationMsg.length) + truncationMsg;\n    } else {\n      return truncatedLines;\n    }\n  } else if (content.length \u003e maxLength) {\n    return content.substring(0, maxLength) + \"\\n[Content truncated due to length]\";\n  }\n\n  return content;\n}\n\n/**\n * Core sanitization function without mention filtering\n * @param {string} content - The content to sanitize\n * @param {number} [maxLength] - Maximum length of content (default: 524288)\n * @returns {string} The sanitized content\n */\nfunction sanitizeContentCore(content, maxLength) {\n  if (!content || typeof content !== \"string\") {\n    return \"\";\n  }\n\n  // Build list of allowed domains from environment and GitHub context\n  const allowedDomains = buildAllowedDomains();\n\n  let sanitized = content;\n\n  // Remove ANSI escape sequences and control characters early\n  // This must happen before mention neutralization to avoid creating bare mentions\n  // when control characters are removed between @ and username\n  sanitized = sanitized.replace(/\\x1b\\[[0-9;]*[mGKH]/g, \"\");\n  // Remove control characters except newlines (\\n), tabs (\\t), and carriage returns (\\r)\n  sanitized = sanitized.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, \"\");\n\n  // Neutralize commands at the start of text (e.g., /bot-name)\n  sanitized = neutralizeCommands(sanitized);\n\n  // Neutralize ALL @mentions (no filtering in core version)\n  sanitized = neutralizeAllMentions(sanitized);\n\n  // Remove XML comments first\n  sanitized = removeXmlComments(sanitized);\n\n  // Convert XML tags to parentheses format to prevent injection\n  sanitized = convertXmlTags(sanitized);\n\n  // URI filtering - replace non-https protocols with \"(redacted)\"\n  sanitized = sanitizeUrlProtocols(sanitized);\n\n  // Domain filtering for HTTPS URIs\n  sanitized = sanitizeUrlDomains(sanitized, allowedDomains);\n\n  // Apply truncation limits\n  sanitized = applyTruncation(sanitized, maxLength);\n\n  // Neutralize common bot trigger phrases\n  sanitized = neutralizeBotTriggers(sanitized);\n\n  // Trim excessive whitespace\n  return sanitized.trim();\n}\n\nmodule.exports = {\n  sanitizeContentCore,\n  getRedactedDomains,\n  addRedactedDomain,\n  clearRedactedDomains,\n  writeRedactedDomainsLog,\n  extractDomainsFromUrl,\n  buildAllowedDomains,\n  sanitizeUrlProtocols,\n  sanitizeUrlDomains,\n  neutralizeCommands,\n  removeXmlComments,\n  convertXmlTags,\n  neutralizeBotTriggers,\n  applyTruncation,\n};\n",
    "sanitize_incoming_text.cjs": "// @ts-check\n/**\n * Slimmed-down sanitization for incoming text (compute_text)\n * This version does NOT include mention filtering - all @mentions are escaped\n */\n\nconst { sanitizeContentCore, writeRedactedDomainsLog } = require(\"./sanitize_content_core.cjs\");\n\n/**\n * Sanitizes incoming text content without selective mention filtering\n * All @mentions are escaped to prevent unintended notifications\n *\n * Uses the core sanitization functions directly to minimize bundle size.\n *\n * @param {string} content - The content to sanitize\n * @param {number} [maxLength] - Maximum length of content (default: 524288)\n * @returns {string} The sanitized content with all mentions escaped\n */\nfunction sanitizeIncomingText(content, maxLength) {\n  // Call core sanitization which neutralizes all mentions\n  return sanitizeContentCore(content, maxLength);\n}\n\nmodule.exports = {\n  sanitizeIncomingText,\n  writeRedactedDomainsLog,\n};\n"
  };

async function run() {
  try {
    const destination = core.getInput('destination') || '/tmp/gh-aw/actions/activation';
    
    core.info(`Copying activation files to ${destination}`);
    
    // Create destination directory if it doesn't exist
    if (!fs.existsSync(destination)) {
      fs.mkdirSync(destination, { recursive: true });
      core.info(`Created directory: ${destination}`);
    }
    
    let fileCount = 0;
    
    // Copy each embedded file
    for (const [filename, content] of Object.entries(FILES)) {
      const filePath = path.join(destination, filename);
      fs.writeFileSync(filePath, content, 'utf8');
      core.info(`Copied: ${filename}`);
      fileCount++;
    }
    
    core.setOutput('files-copied', fileCount.toString());
    core.info(`‚úì Successfully copied ${fileCount} files`);
    
  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

run();
