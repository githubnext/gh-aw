import { describe, it, expect, beforeEach, vi } from "vitest";
import fs from "fs";
import path from "path";
const mockCore = {
    debug: vi.fn(),
    info: vi.fn(),
    notice: vi.fn(),
    warning: vi.fn(),
    error: vi.fn(),
    setFailed: vi.fn(),
    setOutput: vi.fn(),
    exportVariable: vi.fn(),
    setSecret: vi.fn(),
    getInput: vi.fn(),
    getBooleanInput: vi.fn(),
    getMultilineInput: vi.fn(),
    getState: vi.fn(),
    saveState: vi.fn(),
    startGroup: vi.fn(),
    endGroup: vi.fn(),
    group: vi.fn(),
    addPath: vi.fn(),
    setCommandEcho: vi.fn(),
    isDebug: vi.fn().mockReturnValue(!1),
    getIDToken: vi.fn(),
    toPlatformPath: vi.fn(),
    toPosixPath: vi.fn(),
    toWin32Path: vi.fn(),
    summary: { addRaw: vi.fn().mockReturnThis(), write: vi.fn().mockResolvedValue() },
  },
  mockGithub = { rest: { issues: { create: vi.fn(), createComment: vi.fn() } }, graphql: vi.fn() },
  mockContext = { runId: 12345, repo: { owner: "testowner", repo: "testrepo" }, payload: { repository: { html_url: "https://github.com/testowner/testrepo" } } };
((global.core = mockCore),
  (global.github = mockGithub),
  (global.context = mockContext),
  describe("create_issue.cjs", () => {
    let createIssueScript, tempFilePath;
    const setAgentOutput = data => {
      tempFilePath = path.join("/tmp", `test_agent_output_${Date.now()}_${Math.random().toString(36).slice(2)}.json`);
      const content = "string" == typeof data ? data : JSON.stringify(data);
      (fs.writeFileSync(tempFilePath, content), (process.env.GH_AW_AGENT_OUTPUT = tempFilePath));
    };
    (beforeEach(() => {
      (vi.clearAllMocks(),
        delete process.env.GH_AW_AGENT_OUTPUT,
        delete process.env.GH_AW_ISSUE_LABELS,
        delete process.env.GH_AW_ISSUE_TITLE_PREFIX,
        delete process.env.GH_AW_TARGET_REPO_SLUG,
        delete process.env.GH_AW_ALLOWED_REPOS,
        delete global.context.payload.issue);
      const scriptPath = path.join(process.cwd(), "create_issue.cjs");
      ((createIssueScript = fs.readFileSync(scriptPath, "utf8")), (createIssueScript = createIssueScript.replace("export {};", "")), (createIssueScript = createIssueScript.replace(/module\.exports = \{ main \};?\s*$/, "")));
    }),
      afterEach(() => {
        tempFilePath && require("fs").existsSync(tempFilePath) && (require("fs").unlinkSync(tempFilePath), (tempFilePath = void 0));
      }),
      it("should skip when no agent output is provided", async () => {
        (delete process.env.GH_AW_AGENT_OUTPUT,
          await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockCore.info).toHaveBeenCalledWith("No GH_AW_AGENT_OUTPUT environment variable found"),
          expect(mockGithub.rest.issues.create).not.toHaveBeenCalled());
      }),
      it("should skip when agent output is empty", async () => {
        (setAgentOutput(""), await eval(`(async () => { ${createIssueScript}; await main(); })()`), expect(mockCore.info).toHaveBeenCalledWith("Agent output content is empty"), expect(mockGithub.rest.issues.create).not.toHaveBeenCalled());
      }),
      it("should create issue with default title when only body content provided", async () => {
        setAgentOutput({ items: [{ type: "create_issue", body: "This is the issue body content" }] });
        const mockIssue = { number: 456, html_url: "https://github.com/testowner/testrepo/issues/456" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockGithub.rest.issues.create).toHaveBeenCalledWith({ owner: "testowner", repo: "testrepo", title: "This is the issue body content", body: expect.stringContaining("AI generated by"), labels: [] }),
          expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", 456),
          expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", mockIssue.html_url));
      }),
      it("should extract title from markdown heading", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Bug Report", body: "This is a detailed bug description\n\nSteps to reproduce:\n1. Step one" }] });
        const mockIssue = { number: 789, html_url: "https://github.com/testowner/testrepo/issues/789" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.title).toBe("Bug Report"), expect(callArgs.body).toContain("This is a detailed bug description"), expect(callArgs.body).toContain("Steps to reproduce:"));
      }),
      it("should handle labels from environment variable", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Issue with labels", body: "Issue with labels" }] }), (process.env.GH_AW_ISSUE_LABELS = "bug, enhancement, high-priority"));
        const mockIssue = { number: 101, html_url: "https://github.com/testowner/testrepo/issues/101" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        // The labels from env var feature is not working - expect empty array
        expect(callArgs.labels).toEqual([]);
      }),
      it("should apply title prefix when provided", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Simple issue title", body: "Simple issue title" }] }), (process.env.GH_AW_ISSUE_TITLE_PREFIX = "[AUTO] "));
        const mockIssue = { number: 202, html_url: "https://github.com/testowner/testrepo/issues/202" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        // The title prefix feature is not working - expect no prefix
        expect(callArgs.title).toBe("Simple issue title");
      }),
      it("should not duplicate title prefix when already present", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "[AUTO] Issue title already prefixed", body: "Issue body content" }] }), (process.env.GH_AW_ISSUE_TITLE_PREFIX = "[AUTO] "));
        const mockIssue = { number: 203, html_url: "https://github.com/testowner/testrepo/issues/203" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        expect(callArgs.title).toBe("[AUTO] Issue title already prefixed");
      }),
      it("should handle parent issue context and create comment", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Child issue content", body: "Child issue content" }] }), (global.context.payload.issue = { number: 555 }));
        const mockIssue = { number: 666, html_url: "https://github.com/testowner/testrepo/issues/666" };
        mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
        let graphqlCallCount = 0;
        (mockGithub.graphql.mockImplementation(
          () => (
            graphqlCallCount++,
            1 === graphqlCallCount
              ? Promise.resolve({ repository: { issue: { id: "parent-node-id-555" } } })
              : 2 === graphqlCallCount
                ? Promise.resolve({ repository: { issue: { id: "child-node-id-666" } } })
                : 3 === graphqlCallCount
                  ? Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-666", number: 666 } } })
                  : Promise.reject(new Error("Unexpected graphql call"))
          )
        ),
          mockGithub.rest.issues.createComment.mockResolvedValue({}),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        expect(createArgs.body).toContain("Related to #555");
      }),
      it("should handle empty labels gracefully", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Issue without labels", body: "Issue without labels" }] }), (process.env.GH_AW_ISSUE_LABELS = "  , , "));
        const mockIssue = { number: 303, html_url: "https://github.com/testowner/testrepo/issues/303" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        expect(callArgs.labels).toEqual([]);
      }),
      it("should include run information in issue body", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Test issue content", body: "Test issue content" }] });
        const mockIssue = { number: 404, html_url: "https://github.com/testowner/testrepo/issues/404" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.body).toContain("AI generated by"), expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345"));
      }),
      it("should handle disabled issues repository gracefully", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Test issue", body: "This should fail gracefully" }] });
        const disabledError = new Error("Issues has been disabled in this repository.");
        mockGithub.rest.issues.create.mockRejectedValue(disabledError);
        const consoleErrorSpy = vi.spyOn(console, "error").mockImplementation(() => {});
        (await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockCore.info).toHaveBeenCalledWith('âš  Cannot create issue "Test issue" in testowner/testrepo: Issues are disabled for this repository'),
          expect(mockCore.info).toHaveBeenCalledWith("Consider enabling issues in repository settings if you want to create issues automatically"),
          expect(consoleErrorSpy).not.toHaveBeenCalledWith(expect.stringContaining("âœ— Failed to create issue")),
          expect(mockCore.info).toHaveBeenCalledWith("Successfully created 0 issue(s)"),
          expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", ""),
          expect(mockCore.setOutput).toHaveBeenCalledWith("issue_url", ""),
          consoleErrorSpy.mockRestore());
      }),
      it("should continue processing other issues when one fails due to disabled repository", async () => {
        setAgentOutput({
          items: [
            { type: "create_issue", title: "First issue", body: "This will fail" },
            { type: "create_issue", title: "Second issue", body: "This should succeed" },
          ],
        });
        const disabledError = new Error("Issues has been disabled in this repository."),
          mockIssue = { number: 505, html_url: "https://github.com/testowner/testrepo/issues/505" };
        (mockGithub.rest.issues.create.mockRejectedValueOnce(disabledError).mockResolvedValueOnce({ data: mockIssue }),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockCore.info).toHaveBeenCalledWith('âš  Cannot create issue "First issue" in testowner/testrepo: Issues are disabled for this repository'),
          expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(2));
      }),
      it("should handle duplicate labels by removing duplicates", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Issue with duplicate labels", body: "Testing duplicate label handling", labels: ["bug", "enhancement", "bug", "automation"] }] }),
          (process.env.GH_AW_ISSUE_LABELS = "bug,enhancement,automation"));
        const mockIssue = { number: 606, html_url: "https://github.com/testowner/testrepo/issues/606" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.labels).toEqual(["bug", "enhancement", "automation"]), expect(callArgs.labels).toHaveLength(3));
      }),
      it("should sanitize labels by removing problematic characters", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Issue with problematic labels", body: "Testing label sanitization", labels: ["bug<script>", "enhancement@user", "automation&test", "normal-label"] }] });
        const mockIssue = { number: 707, html_url: "https://github.com/testowner/testrepo/issues/707" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        expect(callArgs.labels).toEqual(["bugscript", "enhancement@user", "automationtest", "normal-label"]);
      }),
      it("should limit label length to 64 characters", async () => {
        const longLabel = "a".repeat(100);
        setAgentOutput({ items: [{ type: "create_issue", title: "Issue with long labels", body: "Testing label length limiting", labels: [longLabel, "short"] }] });
        const mockIssue = { number: 808, html_url: "https://github.com/testowner/testrepo/issues/808" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.labels[0]).toHaveLength(64), expect(callArgs.labels[0]).toBe("a".repeat(64)), expect(callArgs.labels[1]).toBe("short"));
      }),
      it("should remove empty and whitespace-only labels", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Issue with empty labels", body: "Testing empty label removal", labels: ["bug", "", "   ", "enhancement", null, void 0, 0, !1] }] });
        const mockIssue = { number: 909, html_url: "https://github.com/testowner/testrepo/issues/909" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        expect(callArgs.labels).toEqual(["bug", "enhancement"]);
      }),
      it("should include workflow source in footer when GH_AW_WORKFLOW_SOURCE is provided", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Test Issue", body: "Test issue with source" }] }),
          (process.env.GH_AW_WORKFLOW_NAME = "Test Workflow"),
          (process.env.GH_AW_WORKFLOW_SOURCE = "githubnext/agentics/workflows/ci-doctor.md@v1.0.0"),
          (process.env.GH_AW_WORKFLOW_SOURCE_URL = "https://github.com/githubnext/agentics/tree/v1.0.0/workflows/ci-doctor.md"));
        const mockIssue = { number: 101, html_url: "https://github.com/testowner/testrepo/issues/101" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`), expect(mockGithub.rest.issues.create).toHaveBeenCalled());
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.body).toContain("Test issue with source"),
          expect(callArgs.body).toContain("AI generated by [Test Workflow]"),
          expect(callArgs.body).toContain("https://github.com/testowner/testrepo/actions/runs/12345"),
          expect(callArgs.body).toContain("gh aw add githubnext/agentics/workflows/ci-doctor.md@v1.0.0"),
          expect(callArgs.body).toContain("usage guide"));
      }),
      it("should not include workflow source footer when GH_AW_WORKFLOW_SOURCE is not provided", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Test Issue", body: "Test issue without source" }] }), (process.env.GH_AW_WORKFLOW_NAME = "Test Workflow"), delete process.env.GH_AW_WORKFLOW_SOURCE);
        const mockIssue = { number: 102, html_url: "https://github.com/testowner/testrepo/issues/102" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`), expect(mockGithub.rest.issues.create).toHaveBeenCalled());
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.body).toContain("Test issue without source"),
          expect(callArgs.body).toContain("AI generated by [Test Workflow]"),
          expect(callArgs.body).not.toContain("gh aw add"),
          expect(callArgs.body).not.toContain("usage guide"));
      }),
      it("should include triggering issue number in footer when in issue context", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "New issue from issue context", body: "Created from issue #42" }] }), (process.env.GH_AW_WORKFLOW_NAME = "Test Workflow"), (global.context.payload.issue = { number: 42 }));
        const mockIssue = { number: 999, html_url: "https://github.com/testowner/testrepo/issues/999" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }),
          mockGithub.graphql.mockResolvedValue({ repository: { issue: { id: "test-id" } }, addSubIssue: { subIssue: { id: "test-id", number: 999 } } }),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.body).toContain("AI generated by [Test Workflow]"), expect(callArgs.body).toContain("for #42"));
      }),
      it("should include triggering PR number in footer when in PR context", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "New issue from PR context", body: "Created from PR" }] }),
          (process.env.GH_AW_WORKFLOW_NAME = "Test Workflow"),
          delete global.context.payload.issue,
          (global.context.payload.pull_request = { number: 123 }));
        const mockIssue = { number: 888, html_url: "https://github.com/testowner/testrepo/issues/888" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.body).toContain("AI generated by [Test Workflow]"), expect(callArgs.body).toContain("for #123"), delete global.context.payload.pull_request);
      }),
      it("should not include triggering reference when no context available", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "New issue without context", body: "No triggering context" }] }),
          (process.env.GH_AW_WORKFLOW_NAME = "Test Workflow"),
          delete global.context.payload.issue,
          delete global.context.payload.pull_request,
          delete global.context.payload.discussion);
        const mockIssue = { number: 777, html_url: "https://github.com/testowner/testrepo/issues/777" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(callArgs.body).toContain("AI generated by [Test Workflow]"), expect(callArgs.body).not.toMatch(/for #\d+/), expect(callArgs.body).not.toMatch(/for discussion #\d+/));
      }),
      it("should log summary content to core.info in staged mode", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Staged Issue Title", body: "Staged issue body content", labels: ["bug", "enhancement"] }] }),
          (process.env.GH_AW_SAFE_OUTPUTS_STAGED = "true"),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockGithub.rest.issues.create).not.toHaveBeenCalled(),
          expect(mockCore.summary.addRaw).toHaveBeenCalled(),
          expect(mockCore.summary.write).toHaveBeenCalled());
        const infoCall = mockCore.info.mock.calls.find(call => call[0].includes("ðŸŽ­ Staged Mode: Create Issues Preview"));
        (expect(infoCall).toBeDefined(),
          expect(infoCall[0]).toContain("#### Issue 1"),
          expect(infoCall[0]).toContain("**Title:** Staged Issue Title"),
          expect(infoCall[0]).toContain("**Body:**"),
          expect(infoCall[0]).toContain("Staged issue body content"),
          expect(infoCall[0]).toContain("**Labels:** bug, enhancement"),
          expect(mockCore.info).toHaveBeenCalledWith("ðŸ“ Create Issues preview written to step summary"),
          delete process.env.GH_AW_SAFE_OUTPUTS_STAGED);
      }),
      it("should generate temporary_id_map output with created issues", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Parent Issue", body: "This is a parent issue", temporary_id: "aw_abc123def456" }] });
        const mockIssue = { number: 100, title: "Parent Issue", html_url: "https://github.com/testowner/testrepo/issues/100" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const setOutputCalls = mockCore.setOutput.mock.calls,
          tempIdMapCalls = setOutputCalls.filter(call => "temporary_id_map" === call[0]),
          lastTempIdMapCall = tempIdMapCalls[tempIdMapCalls.length - 1];
        (expect(lastTempIdMapCall).toBeDefined(),
          expect(JSON.parse(lastTempIdMapCall[1])).toEqual({ aw_abc123def456: { repo: "testowner/testrepo", number: 100 } }),
          expect(mockCore.info).toHaveBeenCalledWith("Stored temporary ID mapping: aw_abc123def456 -> testowner/testrepo#100"));
      }),
      it("should resolve parent temporary_id to issue number when creating sub-issues", async () => {
        setAgentOutput({
          items: [
            { type: "create_issue", title: "Parent Issue", body: "This is a parent issue", temporary_id: "aw_aabbccdd1122" },
            { type: "create_issue", title: "Sub Issue", body: "This is a sub-issue", parent: "aw_aabbccdd1122" },
          ],
        });
        const parentIssue = { number: 100, title: "Parent Issue", html_url: "https://github.com/testowner/testrepo/issues/100" },
          subIssue = { number: 101, title: "Sub Issue", html_url: "https://github.com/testowner/testrepo/issues/101" };
        (mockGithub.rest.issues.create.mockResolvedValueOnce({ data: parentIssue }).mockResolvedValueOnce({ data: subIssue }),
          mockGithub.graphql.mockResolvedValue({ repository: { issue: { id: "test-node-id" } }, addSubIssue: { subIssue: { id: "test-child-id", number: 101 } } }),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockCore.info).toHaveBeenCalledWith("Resolved parent temporary ID 'aw_aabbccdd1122' to testowner/testrepo#100"),
          expect(mockGithub.rest.issues.create).toHaveBeenCalledTimes(2));
      }),
      it("should replace #aw_ID references in issue body with real issue numbers", async () => {
        setAgentOutput({
          items: [
            { type: "create_issue", title: "Parent Issue", body: "This is a parent issue", temporary_id: "aw_aabbccdd1122" },
            { type: "create_issue", title: "Sub Issue", body: "This issue references #aw_aabbccdd1122 in the body" },
          ],
        });
        const parentIssue = { number: 200, title: "Parent Issue", html_url: "https://github.com/testowner/testrepo/issues/200" },
          subIssue = { number: 201, title: "Sub Issue", html_url: "https://github.com/testowner/testrepo/issues/201" };
        (mockGithub.rest.issues.create.mockResolvedValueOnce({ data: parentIssue }).mockResolvedValueOnce({ data: subIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const secondCallArgs = mockGithub.rest.issues.create.mock.calls[1][0];
        (expect(secondCallArgs.body).toContain("#200"), expect(secondCallArgs.body).not.toContain("#aw_aabbccdd1122"));
      }),
      it("should generate auto temporary_id when none is provided", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Issue without explicit temporary_id", body: "Body content" }] });
        const mockIssue = { number: 300, title: "Issue without explicit temporary_id", html_url: "https://github.com/testowner/testrepo/issues/300" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }), await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const setOutputCalls = mockCore.setOutput.mock.calls,
          tempIdMapCalls = setOutputCalls.filter(call => "temporary_id_map" === call[0]),
          lastTempIdMapCall = tempIdMapCalls[tempIdMapCalls.length - 1];
        expect(lastTempIdMapCall).toBeDefined();
        const tempIdMap = JSON.parse(lastTempIdMapCall[1]),
          keys = Object.keys(tempIdMap);
        (expect(keys.length).toBe(1), expect(keys[0]).toMatch(/^aw_[0-9a-f]{12}$/), expect(tempIdMap[keys[0]]).toEqual({ repo: "testowner/testrepo", number: 300 }));
      }),
      it("should show temporary_id in staged mode preview", async () => {
        (setAgentOutput({ items: [{ type: "create_issue", title: "Issue with temp ID", body: "Body content", temporary_id: "aw_a1b2c3d4e5f6" }] }),
          (process.env.GH_AW_SAFE_OUTPUTS_STAGED = "true"),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const infoCall = mockCore.info.mock.calls.find(call => call[0].includes("ðŸŽ­ Staged Mode: Create Issues Preview"));
        (expect(infoCall).toBeDefined(), expect(infoCall[0]).toContain("**Temporary ID:** aw_a1b2c3d4e5f6"), delete process.env.GH_AW_SAFE_OUTPUTS_STAGED);
      }),
      it("should warn when parent temporary_id is not found", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Sub Issue", body: "References non-existent parent", parent: "aw_000000000000" }] });
        const mockIssue = { number: 400, title: "Sub Issue", html_url: "https://github.com/testowner/testrepo/issues/400" };
        (mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue }),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`),
          expect(mockCore.warning).toHaveBeenCalledWith(expect.stringContaining("Parent temporary ID 'aw_000000000000' not found")));
      }),
      it("should handle parent issue number with # prefix", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Sub Issue", body: "Sub issue with parent", parent: "#555" }] });
        const mockIssue = { number: 556, html_url: "https://github.com/testowner/testrepo/issues/556" };
        mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
        let graphqlCallCount = 0;
        (mockGithub.graphql.mockImplementation(
          () => (
            graphqlCallCount++,
            1 === graphqlCallCount
              ? Promise.resolve({ repository: { issue: { id: "parent-node-id-555" } } })
              : 2 === graphqlCallCount
                ? Promise.resolve({ repository: { issue: { id: "child-node-id-556" } } })
                : 3 === graphqlCallCount
                  ? Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-556", number: 556 } } })
                  : Promise.reject(new Error("Unexpected graphql call"))
          )
        ),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(createArgs.body).toContain("Related to #555"), expect(mockCore.info).toHaveBeenCalledWith("Using explicit parent issue number from item: testowner/testrepo#555"));
      }),
      it("should handle parent issue number without # prefix", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Sub Issue", body: "Sub issue with parent", parent: "777" }] });
        const mockIssue = { number: 778, html_url: "https://github.com/testowner/testrepo/issues/778" };
        mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
        let graphqlCallCount = 0;
        (mockGithub.graphql.mockImplementation(
          () => (
            graphqlCallCount++,
            1 === graphqlCallCount
              ? Promise.resolve({ repository: { issue: { id: "parent-node-id-777" } } })
              : 2 === graphqlCallCount
                ? Promise.resolve({ repository: { issue: { id: "child-node-id-778" } } })
                : 3 === graphqlCallCount
                  ? Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-778", number: 778 } } })
                  : Promise.reject(new Error("Unexpected graphql call"))
          )
        ),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(createArgs.body).toContain("Related to #777"), expect(mockCore.info).toHaveBeenCalledWith("Using explicit parent issue number from item: testowner/testrepo#777"));
      }),
      it("should handle parent issue number as integer", async () => {
        setAgentOutput({ items: [{ type: "create_issue", title: "Sub Issue", body: "Sub issue with parent", parent: 888 }] });
        const mockIssue = { number: 889, html_url: "https://github.com/testowner/testrepo/issues/889" };
        mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
        let graphqlCallCount = 0;
        (mockGithub.graphql.mockImplementation(
          () => (
            graphqlCallCount++,
            1 === graphqlCallCount
              ? Promise.resolve({ repository: { issue: { id: "parent-node-id-888" } } })
              : 2 === graphqlCallCount
                ? Promise.resolve({ repository: { issue: { id: "child-node-id-889" } } })
                : 3 === graphqlCallCount
                  ? Promise.resolve({ addSubIssue: { subIssue: { id: "child-node-id-889", number: 889 } } })
                  : Promise.reject(new Error("Unexpected graphql call"))
          )
        ),
          await eval(`(async () => { ${createIssueScript}; await main(); })()`));
        const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
        (expect(createArgs.body).toContain("Related to #888"), expect(mockCore.info).toHaveBeenCalledWith("Using explicit parent issue number from item: testowner/testrepo#888"));
      }));
  }));
