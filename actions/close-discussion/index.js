// @ts-check
/// <reference types="@actions/github-script" />

// === Inlined from ./load_agent_output.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

const fs = require("fs");

/**
 * Maximum content length to log for debugging purposes
 * @type {number}
 */
const MAX_LOG_CONTENT_LENGTH = 10000;

/**
 * Truncate content for logging if it exceeds the maximum length
 * @param {string} content - Content to potentially truncate
 * @returns {string} Truncated content with indicator if truncated
 */
function truncateForLogging(content) {
  if (content.length <= MAX_LOG_CONTENT_LENGTH) {
    return content;
  }
  return content.substring(0, MAX_LOG_CONTENT_LENGTH) + `\n... (truncated, total length: ${content.length})`;
}

/**
 * Load and parse agent output from the GH_AW_AGENT_OUTPUT file
 *
 * This utility handles the common pattern of:
 * 1. Reading the GH_AW_AGENT_OUTPUT environment variable
 * 2. Loading the file content
 * 3. Validating the JSON structure
 * 4. Returning parsed items array
 *
 * @returns {{
 *   success: true,
 *   items: any[]
 * } | {
 *   success: false,
 *   items?: undefined,
 *   error?: string
 * }} Result object with success flag and items array (if successful) or error message
 */
function loadAgentOutput() {
  const agentOutputFile = process.env.GH_AW_AGENT_OUTPUT;

  // No agent output file specified
  if (!agentOutputFile) {
    core.info("No GH_AW_AGENT_OUTPUT environment variable found");
    return { success: false };
  }

  // Read agent output from file
  let outputContent;
  try {
    outputContent = fs.readFileSync(agentOutputFile, "utf8");
  } catch (error) {
    const errorMessage = `Error reading agent output file: ${error instanceof Error ? error.message : String(error)}`;
    core.error(errorMessage);
    return { success: false, error: errorMessage };
  }

  // Check for empty content
  if (outputContent.trim() === "") {
    core.info("Agent output content is empty");
    return { success: false };
  }

  core.info(`Agent output content length: ${outputContent.length}`);

  // Parse the validated output JSON
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    const errorMessage = `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`;
    core.error(errorMessage);
    core.info(`Failed to parse content:\n${truncateForLogging(outputContent)}`);
    return { success: false, error: errorMessage };
  }

  // Validate items array exists
  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    core.info("No valid items found in agent output");
    core.info(`Parsed content: ${truncateForLogging(JSON.stringify(validatedOutput))}`);
    return { success: false };
  }

  return { success: true, items: validatedOutput.items };
}

// === End of ./load_agent_output.cjs ===

// === Inlined from ./generate_footer.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Generates an XML comment marker with agentic workflow metadata for traceability.
 * This marker enables searching and tracing back items generated by an agentic workflow.
 *
 * Note: This function is duplicated in messages_footer.cjs. While normally we would
 * consolidate to a shared module, importing messages_footer.cjs here would cause the
 * bundler to inline messages_core.cjs which contains 'GH_AW_SAFE_OUTPUT_MESSAGES:' in
 * a warning message, breaking tests that check for env var declarations.
 *
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @returns {string} XML comment marker with workflow metadata
 */
function generateXMLMarker(workflowName, runUrl) {
  // Read engine metadata from environment variables
  const engineId = process.env.GH_AW_ENGINE_ID || "";
  const engineVersion = process.env.GH_AW_ENGINE_VERSION || "";
  const engineModel = process.env.GH_AW_ENGINE_MODEL || "";
  const trackerId = process.env.GH_AW_TRACKER_ID || "";

  // Build the key-value pairs for the marker
  const parts = [];

  // Always include agentic-workflow name
  parts.push(`agentic-workflow: ${workflowName}`);

  // Add tracker-id if available (for searchability and tracing)
  if (trackerId) {
    parts.push(`tracker-id: ${trackerId}`);
  }

  // Add engine ID if available
  if (engineId) {
    parts.push(`engine: ${engineId}`);
  }

  // Add version if available
  if (engineVersion) {
    parts.push(`version: ${engineVersion}`);
  }

  // Add model if available
  if (engineModel) {
    parts.push(`model: ${engineModel}`);
  }

  // Always include run URL
  parts.push(`run: ${runUrl}`);

  // Return the XML comment marker
  return `<!-- ${parts.join(", ")} -->`;
}

/**
 * Generate footer with AI attribution and workflow installation instructions
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)
 * @param {string} workflowSourceURL - GitHub URL for the workflow source
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow
 * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow
 * @returns {string} Footer text
 */
function generateFooter(
  workflowName,
  runUrl,
  workflowSource,
  workflowSourceURL,
  triggeringIssueNumber,
  triggeringPRNumber,
  triggeringDiscussionNumber
) {
  let footer = `\n\n> AI generated by [${workflowName}](${runUrl})`;

  // Add reference to triggering issue/PR/discussion if available
  if (triggeringIssueNumber) {
    footer += ` for #${triggeringIssueNumber}`;
  } else if (triggeringPRNumber) {
    footer += ` for #${triggeringPRNumber}`;
  } else if (triggeringDiscussionNumber) {
    footer += ` for discussion #${triggeringDiscussionNumber}`;
  }

  if (workflowSource && workflowSourceURL) {
    footer += `\n>\n> To add this workflow in your repository, run \`gh aw add ${workflowSource}\`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).`;
  }

  // Add XML comment marker for traceability
  footer += "\n\n" + generateXMLMarker(workflowName, runUrl);

  footer += "\n";
  return footer;
}

// === End of ./generate_footer.cjs ===

// === Inlined from ./get_tracker_id.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Get tracker-id from environment variable, log it, and optionally format it
 * @param {string} [format] - Output format: "markdown" for HTML comment, "text" for plain text, or undefined for raw value
 * @returns {string} Tracker ID in requested format or empty string
 */
function getTrackerID(format) {
  const trackerID = process.env.GH_AW_TRACKER_ID || "";
  if (trackerID) {
    core.info(`Tracker ID: ${trackerID}`);
    return format === "markdown" ? `\n\n<!-- tracker-id: ${trackerID} -->` : trackerID;
  }
  return "";
}

// === End of ./get_tracker_id.cjs ===

// === Inlined from ./get_repository_url.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Get the repository URL for different purposes
 * This helper handles trial mode where target repository URLs are different from execution context
 * @returns {string} Repository URL
 */
function getRepositoryUrl() {
  // For trial mode, use target repository for issue/PR URLs but execution context for action runs
  const targetRepoSlug = process.env.GH_AW_TARGET_REPO_SLUG;

  if (targetRepoSlug) {
    // Use target repository for issue/PR URLs in trial mode
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    return `${githubServer}/${targetRepoSlug}`;
  } else if (context.payload.repository?.html_url) {
    // Use execution context repository (default behavior)
    return context.payload.repository.html_url;
  } else {
    // Final fallback for action runs when context repo is not available
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    return `${githubServer}/${context.repo.owner}/${context.repo.repo}`;
  }
}

// === End of ./get_repository_url.cjs ===


/**
 * Get discussion details using GraphQL
 * @param {any} github - GitHub GraphQL instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} discussionNumber - Discussion number
 * @returns {Promise<{id: string, title: string, category: {name: string}, labels: {nodes: Array<{name: string}>}, url: string}>} Discussion details
 */
async function getDiscussionDetails(github, owner, repo, discussionNumber) {
  const { repository } = await github.graphql(
    `
    query($owner: String!, $repo: String!, $num: Int!) {
      repository(owner: $owner, name: $repo) {
        discussion(number: $num) { 
          id
          title
          category {
            name
          }
          labels(first: 100) {
            nodes {
              name
            }
          }
          url
        }
      }
    }`,
    { owner, repo, num: discussionNumber }
  );

  if (!repository || !repository.discussion) {
    throw new Error(`Discussion #${discussionNumber} not found in ${owner}/${repo}`);
  }

  return repository.discussion;
}

/**
 * Add comment to a GitHub Discussion using GraphQL
 * @param {any} github - GitHub GraphQL instance
 * @param {string} discussionId - Discussion node ID
 * @param {string} message - Comment body
 * @returns {Promise<{id: string, url: string}>} Comment details
 */
async function addDiscussionComment(github, discussionId, message) {
  const result = await github.graphql(
    `
    mutation($dId: ID!, $body: String!) {
      addDiscussionComment(input: { discussionId: $dId, body: $body }) {
        comment { 
          id 
          url
        }
      }
    }`,
    { dId: discussionId, body: message }
  );

  return result.addDiscussionComment.comment;
}

/**
 * Close a GitHub Discussion using GraphQL
 * @param {any} github - GitHub GraphQL instance
 * @param {string} discussionId - Discussion node ID
 * @param {string|undefined} reason - Optional close reason (RESOLVED, DUPLICATE, OUTDATED, or ANSWERED)
 * @returns {Promise<{id: string, url: string}>} Discussion details
 */
async function closeDiscussion(github, discussionId, reason) {
  const mutation = reason
    ? `
      mutation($dId: ID!, $reason: DiscussionCloseReason!) {
        closeDiscussion(input: { discussionId: $dId, reason: $reason }) {
          discussion { 
            id
            url
          }
        }
      }`
    : `
      mutation($dId: ID!) {
        closeDiscussion(input: { discussionId: $dId }) {
          discussion { 
            id
            url
          }
        }
      }`;

  const variables = reason ? { dId: discussionId, reason } : { dId: discussionId };
  const result = await github.graphql(mutation, variables);

  return result.closeDiscussion.discussion;
}

async function main() {
  // Check if we're in staged mode
  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";

  const result = loadAgentOutput();
  if (!result.success) {
    return;
  }

  // Find all close-discussion items
  const closeDiscussionItems = result.items.filter(/** @param {any} item */ item => item.type === "close_discussion");
  if (closeDiscussionItems.length === 0) {
    core.info("No close-discussion items found in agent output");
    return;
  }

  core.info(`Found ${closeDiscussionItems.length} close-discussion item(s)`);

  // Get configuration from environment
  const requiredLabels = process.env.GH_AW_CLOSE_DISCUSSION_REQUIRED_LABELS
    ? process.env.GH_AW_CLOSE_DISCUSSION_REQUIRED_LABELS.split(",").map(l => l.trim())
    : [];
  const requiredTitlePrefix = process.env.GH_AW_CLOSE_DISCUSSION_REQUIRED_TITLE_PREFIX || "";
  const requiredCategory = process.env.GH_AW_CLOSE_DISCUSSION_REQUIRED_CATEGORY || "";
  const target = process.env.GH_AW_CLOSE_DISCUSSION_TARGET || "triggering";

  core.info(
    `Configuration: requiredLabels=${requiredLabels.join(",")}, requiredTitlePrefix=${requiredTitlePrefix}, requiredCategory=${requiredCategory}, target=${target}`
  );

  // Check if we're in a discussion context
  const isDiscussionContext = context.eventName === "discussion" || context.eventName === "discussion_comment";

  // If in staged mode, emit step summary instead of closing discussions
  if (isStaged) {
    let summaryContent = "## üé≠ Staged Mode: Close Discussions Preview\n\n";
    summaryContent += "The following discussions would be closed if staged mode was disabled:\n\n";

    for (let i = 0; i < closeDiscussionItems.length; i++) {
      const item = closeDiscussionItems[i];
      summaryContent += `### Discussion ${i + 1}\n`;

      const discussionNumber = item.discussion_number;
      if (discussionNumber) {
        const repoUrl = getRepositoryUrl();
        const discussionUrl = `${repoUrl}/discussions/${discussionNumber}`;
        summaryContent += `**Target Discussion:** [#${discussionNumber}](${discussionUrl})\n\n`;
      } else {
        summaryContent += `**Target:** Current discussion\n\n`;
      }

      if (item.reason) {
        summaryContent += `**Reason:** ${item.reason}\n\n`;
      }

      summaryContent += `**Comment:**\n${item.body || "No content provided"}\n\n`;

      if (requiredLabels.length > 0) {
        summaryContent += `**Required Labels:** ${requiredLabels.join(", ")}\n\n`;
      }
      if (requiredTitlePrefix) {
        summaryContent += `**Required Title Prefix:** ${requiredTitlePrefix}\n\n`;
      }
      if (requiredCategory) {
        summaryContent += `**Required Category:** ${requiredCategory}\n\n`;
      }

      summaryContent += "---\n\n";
    }

    // Write to step summary
    await core.summary.addRaw(summaryContent).write();
    core.info("üìù Discussion close preview written to step summary");
    return;
  }

  // Validate context based on target configuration
  if (target === "triggering" && !isDiscussionContext) {
    core.info('Target is "triggering" but not running in discussion context, skipping discussion close');
    return;
  }

  // Extract triggering context for footer generation
  const triggeringDiscussionNumber = context.payload?.discussion?.number;

  const closedDiscussions = [];

  // Process each close-discussion item
  for (let i = 0; i < closeDiscussionItems.length; i++) {
    const item = closeDiscussionItems[i];
    core.info(`Processing close-discussion item ${i + 1}/${closeDiscussionItems.length}: bodyLength=${item.body.length}`);

    // Determine the discussion number
    let discussionNumber;

    if (target === "*") {
      // For target "*", we need an explicit number from the item
      const targetNumber = item.discussion_number;
      if (targetNumber) {
        discussionNumber = parseInt(targetNumber, 10);
        if (isNaN(discussionNumber) || discussionNumber <= 0) {
          core.info(`Invalid discussion number specified: ${targetNumber}`);
          continue;
        }
      } else {
        core.info(`Target is "*" but no discussion_number specified in close-discussion item`);
        continue;
      }
    } else if (target && target !== "triggering") {
      // Explicit number specified in target configuration
      discussionNumber = parseInt(target, 10);
      if (isNaN(discussionNumber) || discussionNumber <= 0) {
        core.info(`Invalid discussion number in target configuration: ${target}`);
        continue;
      }
    } else {
      // Default behavior: use triggering discussion
      if (isDiscussionContext) {
        discussionNumber = context.payload.discussion?.number;
        if (!discussionNumber) {
          core.info("Discussion context detected but no discussion found in payload");
          continue;
        }
      } else {
        core.info("Not in discussion context and no explicit target specified");
        continue;
      }
    }

    try {
      // Fetch discussion details to check filters
      const discussion = await getDiscussionDetails(github, context.repo.owner, context.repo.repo, discussionNumber);

      // Apply label filter
      if (requiredLabels.length > 0) {
        const discussionLabels = discussion.labels.nodes.map(l => l.name);
        const hasRequiredLabel = requiredLabels.some(required => discussionLabels.includes(required));
        if (!hasRequiredLabel) {
          core.info(`Discussion #${discussionNumber} does not have required labels: ${requiredLabels.join(", ")}`);
          continue;
        }
      }

      // Apply title prefix filter
      if (requiredTitlePrefix && !discussion.title.startsWith(requiredTitlePrefix)) {
        core.info(`Discussion #${discussionNumber} does not have required title prefix: ${requiredTitlePrefix}`);
        continue;
      }

      // Apply category filter
      if (requiredCategory && discussion.category.name !== requiredCategory) {
        core.info(`Discussion #${discussionNumber} is not in required category: ${requiredCategory}`);
        continue;
      }

      // Extract body from the JSON item
      let body = item.body.trim();

      // Add AI disclaimer with workflow name and run url
      const workflowName = process.env.GH_AW_WORKFLOW_NAME || "Workflow";
      const workflowSource = process.env.GH_AW_WORKFLOW_SOURCE || "";
      const workflowSourceURL = process.env.GH_AW_WORKFLOW_SOURCE_URL || "";
      const runId = context.runId;
      const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
      const runUrl = context.payload.repository
        ? `${context.payload.repository.html_url}/actions/runs/${runId}`
        : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;

      // Add fingerprint comment if present
      body += getTrackerID("markdown");

      body += generateFooter(workflowName, runUrl, workflowSource, workflowSourceURL, undefined, undefined, triggeringDiscussionNumber);

      core.info(`Adding comment to discussion #${discussionNumber}`);
      core.info(`Comment content length: ${body.length}`);

      // Add comment first
      const comment = await addDiscussionComment(github, discussion.id, body);
      core.info("Added discussion comment: " + comment.url);

      // Then close the discussion
      core.info(`Closing discussion #${discussionNumber} with reason: ${item.reason || "none"}`);
      const closedDiscussion = await closeDiscussion(github, discussion.id, item.reason);
      core.info("Closed discussion: " + closedDiscussion.url);

      closedDiscussions.push({
        number: discussionNumber,
        url: discussion.url,
        comment_url: comment.url,
      });

      // Set output for the last closed discussion (for backward compatibility)
      if (i === closeDiscussionItems.length - 1) {
        core.setOutput("discussion_number", discussionNumber);
        core.setOutput("discussion_url", discussion.url);
        core.setOutput("comment_url", comment.url);
      }
    } catch (error) {
      core.error(`‚úó Failed to close discussion #${discussionNumber}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  // Write summary for all closed discussions
  if (closedDiscussions.length > 0) {
    let summaryContent = "\n\n## Closed Discussions\n";
    for (const discussion of closedDiscussions) {
      summaryContent += `- Discussion #${discussion.number}: [View Discussion](${discussion.url})\n`;
      summaryContent += `  - Comment: [View Comment](${discussion.comment_url})\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }

  core.info(`Successfully closed ${closedDiscussions.length} discussion(s)`);
  return closedDiscussions;
}
await main();
