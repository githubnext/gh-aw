// @ts-check
/// <reference types="@actions/github-script" />

// === Inlined from ./close_entity_helpers.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

// === Inlined from ./load_agent_output.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

const fs = require("fs");

/**
 * Maximum content length to log for debugging purposes
 * @type {number}
 */
const MAX_LOG_CONTENT_LENGTH = 10000;

/**
 * Truncate content for logging if it exceeds the maximum length
 * @param {string} content - Content to potentially truncate
 * @returns {string} Truncated content with indicator if truncated
 */
function truncateForLogging(content) {
  if (content.length <= MAX_LOG_CONTENT_LENGTH) {
    return content;
  }
  return content.substring(0, MAX_LOG_CONTENT_LENGTH) + `\n... (truncated, total length: ${content.length})`;
}

/**
 * Load and parse agent output from the GH_AW_AGENT_OUTPUT file
 *
 * This utility handles the common pattern of:
 * 1. Reading the GH_AW_AGENT_OUTPUT environment variable
 * 2. Loading the file content
 * 3. Validating the JSON structure
 * 4. Returning parsed items array
 *
 * @returns {{
 *   success: true,
 *   items: any[]
 * } | {
 *   success: false,
 *   items?: undefined,
 *   error?: string
 * }} Result object with success flag and items array (if successful) or error message
 */
function loadAgentOutput() {
  const agentOutputFile = process.env.GH_AW_AGENT_OUTPUT;

  // No agent output file specified
  if (!agentOutputFile) {
    core.info("No GH_AW_AGENT_OUTPUT environment variable found");
    return { success: false };
  }

  // Read agent output from file
  let outputContent;
  try {
    outputContent = fs.readFileSync(agentOutputFile, "utf8");
  } catch (error) {
    const errorMessage = `Error reading agent output file: ${error instanceof Error ? error.message : String(error)}`;
    core.error(errorMessage);
    return { success: false, error: errorMessage };
  }

  // Check for empty content
  if (outputContent.trim() === "") {
    core.info("Agent output content is empty");
    return { success: false };
  }

  core.info(`Agent output content length: ${outputContent.length}`);

  // Parse the validated output JSON
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    const errorMessage = `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`;
    core.error(errorMessage);
    core.info(`Failed to parse content:\n${truncateForLogging(outputContent)}`);
    return { success: false, error: errorMessage };
  }

  // Validate items array exists
  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    core.info("No valid items found in agent output");
    core.info(`Parsed content: ${truncateForLogging(JSON.stringify(validatedOutput))}`);
    return { success: false };
  }

  return { success: true, items: validatedOutput.items };
}

// === End of ./load_agent_output.cjs ===

// === Inlined from ./generate_footer.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Generates an XML comment marker with agentic workflow metadata for traceability.
 * This marker enables searching and tracing back items generated by an agentic workflow.
 *
 * Note: This function is duplicated in messages_footer.cjs. While normally we would
 * consolidate to a shared module, importing messages_footer.cjs here would cause the
 * bundler to inline messages_core.cjs which contains 'GH_AW_SAFE_OUTPUT_MESSAGES:' in
 * a warning message, breaking tests that check for env var declarations.
 *
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @returns {string} XML comment marker with workflow metadata
 */
function generateXMLMarker(workflowName, runUrl) {
  // Read engine metadata from environment variables
  const engineId = process.env.GH_AW_ENGINE_ID || "";
  const engineVersion = process.env.GH_AW_ENGINE_VERSION || "";
  const engineModel = process.env.GH_AW_ENGINE_MODEL || "";
  const trackerId = process.env.GH_AW_TRACKER_ID || "";

  // Build the key-value pairs for the marker
  const parts = [];

  // Always include agentic-workflow name
  parts.push(`agentic-workflow: ${workflowName}`);

  // Add tracker-id if available (for searchability and tracing)
  if (trackerId) {
    parts.push(`tracker-id: ${trackerId}`);
  }

  // Add engine ID if available
  if (engineId) {
    parts.push(`engine: ${engineId}`);
  }

  // Add version if available
  if (engineVersion) {
    parts.push(`version: ${engineVersion}`);
  }

  // Add model if available
  if (engineModel) {
    parts.push(`model: ${engineModel}`);
  }

  // Always include run URL
  parts.push(`run: ${runUrl}`);

  // Return the XML comment marker
  return `<!-- ${parts.join(", ")} -->`;
}

/**
 * Generate footer with AI attribution and workflow installation instructions
 * @param {string} workflowName - Name of the workflow
 * @param {string} runUrl - URL of the workflow run
 * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)
 * @param {string} workflowSourceURL - GitHub URL for the workflow source
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow
 * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow
 * @returns {string} Footer text
 */
function generateFooter(
  workflowName,
  runUrl,
  workflowSource,
  workflowSourceURL,
  triggeringIssueNumber,
  triggeringPRNumber,
  triggeringDiscussionNumber
) {
  let footer = `\n\n> AI generated by [${workflowName}](${runUrl})`;

  // Add reference to triggering issue/PR/discussion if available
  if (triggeringIssueNumber) {
    footer += ` for #${triggeringIssueNumber}`;
  } else if (triggeringPRNumber) {
    footer += ` for #${triggeringPRNumber}`;
  } else if (triggeringDiscussionNumber) {
    footer += ` for discussion #${triggeringDiscussionNumber}`;
  }

  if (workflowSource && workflowSourceURL) {
    footer += `\n>\n> To add this workflow in your repository, run \`gh aw add ${workflowSource}\`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).`;
  }

  // Add XML comment marker for traceability
  footer += "\n\n" + generateXMLMarker(workflowName, runUrl);

  footer += "\n";
  return footer;
}

// === End of ./generate_footer.cjs ===

// === Inlined from ./get_tracker_id.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Get tracker-id from environment variable, log it, and optionally format it
 * @param {string} [format] - Output format: "markdown" for HTML comment, "text" for plain text, or undefined for raw value
 * @returns {string} Tracker ID in requested format or empty string
 */
function getTrackerID(format) {
  const trackerID = process.env.GH_AW_TRACKER_ID || "";
  if (trackerID) {
    core.info(`Tracker ID: ${trackerID}`);
    return format === "markdown" ? `\n\n<!-- tracker-id: ${trackerID} -->` : trackerID;
  }
  return "";
}

// === End of ./get_tracker_id.cjs ===

// === Inlined from ./get_repository_url.cjs ===
// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Get the repository URL for different purposes
 * This helper handles trial mode where target repository URLs are different from execution context
 * @returns {string} Repository URL
 */
function getRepositoryUrl() {
  // For trial mode, use target repository for issue/PR URLs but execution context for action runs
  const targetRepoSlug = process.env.GH_AW_TARGET_REPO_SLUG;

  if (targetRepoSlug) {
    // Use target repository for issue/PR URLs in trial mode
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    return `${githubServer}/${targetRepoSlug}`;
  } else if (context.payload.repository?.html_url) {
    // Use execution context repository (default behavior)
    return context.payload.repository.html_url;
  } else {
    // Final fallback for action runs when context repo is not available
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    return `${githubServer}/${context.repo.owner}/${context.repo.repo}`;
  }
}

// === End of ./get_repository_url.cjs ===


/**
 * @typedef {'issue' | 'pull_request'} EntityType
 */

/**
 * @typedef {Object} EntityConfig
 * @property {EntityType} entityType - The type of entity (issue or pull_request)
 * @property {string} itemType - The agent output item type (e.g., "close_issue")
 * @property {string} itemTypeDisplay - Human-readable item type for log messages (e.g., "close-issue")
 * @property {string} numberField - The field name for the entity number in agent output (e.g., "issue_number")
 * @property {string} envVarPrefix - Environment variable prefix (e.g., "GH_AW_CLOSE_ISSUE")
 * @property {string[]} contextEvents - GitHub event names for this entity context
 * @property {string} contextPayloadField - The field name in context.payload (e.g., "issue")
 * @property {string} urlPath - URL path segment (e.g., "issues" or "pull")
 * @property {string} displayName - Human-readable display name (e.g., "issue" or "pull request")
 * @property {string} displayNamePlural - Human-readable display name plural (e.g., "issues" or "pull requests")
 * @property {string} displayNameCapitalized - Capitalized display name (e.g., "Issue" or "Pull Request")
 * @property {string} displayNameCapitalizedPlural - Capitalized display name plural (e.g., "Issues" or "Pull Requests")
 */

/**
 * @typedef {Object} EntityCallbacks
 * @property {(github: any, owner: string, repo: string, entityNumber: number) => Promise<{number: number, title: string, labels: Array<{name: string}>, html_url: string, state: string}>} getDetails
 * @property {(github: any, owner: string, repo: string, entityNumber: number, message: string) => Promise<{id: number, html_url: string}>} addComment
 * @property {(github: any, owner: string, repo: string, entityNumber: number) => Promise<{number: number, html_url: string, title: string}>} closeEntity
 */

/**
 * Build the run URL for the current workflow
 * @returns {string} The workflow run URL
 */
function buildRunUrl() {
  const runId = context.runId;
  const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
  return context.payload.repository
    ? `${context.payload.repository.html_url}/actions/runs/${runId}`
    : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
}

/**
 * Build comment body with tracker ID and footer
 * @param {string} body - The original comment body
 * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow
 * @param {number|undefined} triggeringPRNumber - PR number that triggered this workflow
 * @returns {string} The complete comment body with tracker ID and footer
 */
function buildCommentBody(body, triggeringIssueNumber, triggeringPRNumber) {
  const workflowName = process.env.GH_AW_WORKFLOW_NAME || "Workflow";
  const workflowSource = process.env.GH_AW_WORKFLOW_SOURCE || "";
  const workflowSourceURL = process.env.GH_AW_WORKFLOW_SOURCE_URL || "";
  const runUrl = buildRunUrl();

  let commentBody = body.trim();
  commentBody += getTrackerID("markdown");
  commentBody += generateFooter(
    workflowName,
    runUrl,
    workflowSource,
    workflowSourceURL,
    triggeringIssueNumber,
    triggeringPRNumber,
    undefined
  );

  return commentBody;
}

/**
 * Check if labels match the required labels filter
 * @param {Array<{name: string}>} entityLabels - Labels on the entity
 * @param {string[]} requiredLabels - Required labels (any match)
 * @returns {boolean} True if entity has at least one required label
 */
function checkLabelFilter(entityLabels, requiredLabels) {
  if (requiredLabels.length === 0) {
    return true;
  }
  const labelNames = entityLabels.map(l => l.name);
  return requiredLabels.some(required => labelNames.includes(required));
}

/**
 * Check if title matches the required prefix filter
 * @param {string} title - Entity title
 * @param {string} requiredTitlePrefix - Required title prefix
 * @returns {boolean} True if title starts with required prefix
 */
function checkTitlePrefixFilter(title, requiredTitlePrefix) {
  if (!requiredTitlePrefix) {
    return true;
  }
  return title.startsWith(requiredTitlePrefix);
}

/**
 * Generate staged preview content for a close entity operation
 * @param {EntityConfig} config - Entity configuration
 * @param {any[]} items - Items to preview
 * @param {string[]} requiredLabels - Required labels filter
 * @param {string} requiredTitlePrefix - Required title prefix filter
 * @returns {Promise<void>}
 */
async function generateCloseEntityStagedPreview(config, items, requiredLabels, requiredTitlePrefix) {
  let summaryContent = `## ðŸŽ­ Staged Mode: Close ${config.displayNameCapitalizedPlural} Preview\n\n`;
  summaryContent += `The following ${config.displayNamePlural} would be closed if staged mode was disabled:\n\n`;

  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    summaryContent += `### ${config.displayNameCapitalized} ${i + 1}\n`;

    const entityNumber = item[config.numberField];
    if (entityNumber) {
      const repoUrl = getRepositoryUrl();
      const entityUrl = `${repoUrl}/${config.urlPath}/${entityNumber}`;
      summaryContent += `**Target ${config.displayNameCapitalized}:** [#${entityNumber}](${entityUrl})\n\n`;
    } else {
      summaryContent += `**Target:** Current ${config.displayName}\n\n`;
    }

    summaryContent += `**Comment:**\n${item.body || "No content provided"}\n\n`;

    if (requiredLabels.length > 0) {
      summaryContent += `**Required Labels:** ${requiredLabels.join(", ")}\n\n`;
    }
    if (requiredTitlePrefix) {
      summaryContent += `**Required Title Prefix:** ${requiredTitlePrefix}\n\n`;
    }

    summaryContent += "---\n\n";
  }

  // Write to step summary
  await core.summary.addRaw(summaryContent).write();
  core.info(`ðŸ“ ${config.displayNameCapitalized} close preview written to step summary`);
}

/**
 * Parse configuration from environment variables
 * @param {string} envVarPrefix - Environment variable prefix
 * @returns {{requiredLabels: string[], requiredTitlePrefix: string, target: string}}
 */
function parseEntityConfig(envVarPrefix) {
  const labelsEnvVar = `${envVarPrefix}_REQUIRED_LABELS`;
  const titlePrefixEnvVar = `${envVarPrefix}_REQUIRED_TITLE_PREFIX`;
  const targetEnvVar = `${envVarPrefix}_TARGET`;

  const requiredLabels = process.env[labelsEnvVar] ? process.env[labelsEnvVar].split(",").map(l => l.trim()) : [];
  const requiredTitlePrefix = process.env[titlePrefixEnvVar] || "";
  const target = process.env[targetEnvVar] || "triggering";

  return { requiredLabels, requiredTitlePrefix, target };
}

/**
 * Resolve the entity number based on target configuration and context
 * @param {EntityConfig} config - Entity configuration
 * @param {string} target - Target configuration ("triggering", "*", or explicit number)
 * @param {any} item - The agent output item
 * @param {boolean} isEntityContext - Whether we're in the correct entity context
 * @returns {{success: true, number: number} | {success: false, message: string}}
 */
function resolveEntityNumber(config, target, item, isEntityContext) {
  if (target === "*") {
    const targetNumber = item[config.numberField];
    if (targetNumber) {
      const parsed = parseInt(targetNumber, 10);
      if (isNaN(parsed) || parsed <= 0) {
        return {
          success: false,
          message: `Invalid ${config.displayName} number specified: ${targetNumber}`,
        };
      }
      return { success: true, number: parsed };
    }
    return {
      success: false,
      message: `Target is "*" but no ${config.numberField} specified in ${config.itemTypeDisplay} item`,
    };
  }

  if (target !== "triggering") {
    const parsed = parseInt(target, 10);
    if (isNaN(parsed) || parsed <= 0) {
      return {
        success: false,
        message: `Invalid ${config.displayName} number in target configuration: ${target}`,
      };
    }
    return { success: true, number: parsed };
  }

  // Default behavior: use triggering entity
  if (isEntityContext) {
    const number = context.payload[config.contextPayloadField]?.number;
    if (!number) {
      return {
        success: false,
        message: `${config.displayNameCapitalized} context detected but no ${config.displayName} found in payload`,
      };
    }
    return { success: true, number };
  }

  return {
    success: false,
    message: `Not in ${config.displayName} context and no explicit target specified`,
  };
}

/**
 * Escape special markdown characters in a title
 * @param {string} title - The title to escape
 * @returns {string} Escaped title
 */
function escapeMarkdownTitle(title) {
  return title.replace(/[[\]()]/g, "\\$&");
}

/**
 * Process close entity items from agent output
 * @param {EntityConfig} config - Entity configuration
 * @param {EntityCallbacks} callbacks - Entity-specific API callbacks
 * @returns {Promise<Array<{entity: {number: number, html_url: string, title: string}, comment: {id: number, html_url: string}}>|undefined>}
 */
async function processCloseEntityItems(config, callbacks) {
  // Check if we're in staged mode
  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";

  const result = loadAgentOutput();
  if (!result.success) {
    return;
  }

  // Find all items of this type
  const items = result.items.filter(/** @param {any} item */ item => item.type === config.itemType);
  if (items.length === 0) {
    core.info(`No ${config.itemTypeDisplay} items found in agent output`);
    return;
  }

  core.info(`Found ${items.length} ${config.itemTypeDisplay} item(s)`);

  // Get configuration from environment
  const { requiredLabels, requiredTitlePrefix, target } = parseEntityConfig(config.envVarPrefix);

  core.info(`Configuration: requiredLabels=${requiredLabels.join(",")}, requiredTitlePrefix=${requiredTitlePrefix}, target=${target}`);

  // Check if we're in the correct entity context
  const isEntityContext = config.contextEvents.some(event => context.eventName === event);

  // If in staged mode, emit step summary instead of closing entities
  if (isStaged) {
    await generateCloseEntityStagedPreview(config, items, requiredLabels, requiredTitlePrefix);
    return;
  }

  // Validate context based on target configuration
  if (target === "triggering" && !isEntityContext) {
    core.info(`Target is "triggering" but not running in ${config.displayName} context, skipping ${config.displayName} close`);
    return;
  }

  // Extract triggering context for footer generation
  const triggeringIssueNumber = context.payload?.issue?.number;
  const triggeringPRNumber = context.payload?.pull_request?.number;

  const closedEntities = [];

  // Process each item
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    core.info(`Processing ${config.itemTypeDisplay} item ${i + 1}/${items.length}: bodyLength=${item.body.length}`);

    // Resolve entity number
    const resolved = resolveEntityNumber(config, target, item, isEntityContext);
    if (!resolved.success) {
      core.info(resolved.message);
      continue;
    }
    const entityNumber = resolved.number;

    try {
      // Fetch entity details to check filters
      const entity = await callbacks.getDetails(github, context.repo.owner, context.repo.repo, entityNumber);

      // Apply label filter
      if (!checkLabelFilter(entity.labels, requiredLabels)) {
        core.info(`${config.displayNameCapitalized} #${entityNumber} does not have required labels: ${requiredLabels.join(", ")}`);
        continue;
      }

      // Apply title prefix filter
      if (!checkTitlePrefixFilter(entity.title, requiredTitlePrefix)) {
        core.info(`${config.displayNameCapitalized} #${entityNumber} does not have required title prefix: ${requiredTitlePrefix}`);
        continue;
      }

      // Check if already closed
      if (entity.state === "closed") {
        core.info(`${config.displayNameCapitalized} #${entityNumber} is already closed, skipping`);
        continue;
      }

      // Build comment body
      const commentBody = buildCommentBody(item.body, triggeringIssueNumber, triggeringPRNumber);

      // Add comment before closing
      const comment = await callbacks.addComment(github, context.repo.owner, context.repo.repo, entityNumber, commentBody);
      core.info(`âœ“ Added comment to ${config.displayName} #${entityNumber}: ${comment.html_url}`);

      // Close the entity
      const closedEntity = await callbacks.closeEntity(github, context.repo.owner, context.repo.repo, entityNumber);
      core.info(`âœ“ Closed ${config.displayName} #${entityNumber}: ${closedEntity.html_url}`);

      closedEntities.push({
        entity: closedEntity,
        comment,
      });

      // Set outputs for the last closed entity (for backward compatibility)
      if (i === items.length - 1) {
        const numberOutputName = config.entityType === "issue" ? "issue_number" : "pull_request_number";
        const urlOutputName = config.entityType === "issue" ? "issue_url" : "pull_request_url";
        core.setOutput(numberOutputName, closedEntity.number);
        core.setOutput(urlOutputName, closedEntity.html_url);
        core.setOutput("comment_url", comment.html_url);
      }
    } catch (error) {
      core.error(`âœ— Failed to close ${config.displayName} #${entityNumber}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  // Write summary for all closed entities
  if (closedEntities.length > 0) {
    let summaryContent = `\n\n## Closed ${config.displayNameCapitalizedPlural}\n`;
    for (const { entity, comment } of closedEntities) {
      const escapedTitle = escapeMarkdownTitle(entity.title);
      summaryContent += `- ${config.displayNameCapitalized} #${entity.number}: [${escapedTitle}](${entity.html_url}) ([comment](${comment.html_url}))\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }

  core.info(`Successfully closed ${closedEntities.length} ${config.displayName}(s)`);
  return closedEntities;
}

/**
 * Configuration for closing issues
 * @type {EntityConfig}
 */
const ISSUE_CONFIG = {
  entityType: "issue",
  itemType: "close_issue",
  itemTypeDisplay: "close-issue",
  numberField: "issue_number",
  envVarPrefix: "GH_AW_CLOSE_ISSUE",
  contextEvents: ["issues", "issue_comment"],
  contextPayloadField: "issue",
  urlPath: "issues",
  displayName: "issue",
  displayNamePlural: "issues",
  displayNameCapitalized: "Issue",
  displayNameCapitalizedPlural: "Issues",
};

/**
 * Configuration for closing pull requests
 * @type {EntityConfig}
 */
const PULL_REQUEST_CONFIG = {
  entityType: "pull_request",
  itemType: "close_pull_request",
  itemTypeDisplay: "close-pull-request",
  numberField: "pull_request_number",
  envVarPrefix: "GH_AW_CLOSE_PR",
  contextEvents: ["pull_request", "pull_request_review_comment"],
  contextPayloadField: "pull_request",
  urlPath: "pull",
  displayName: "pull request",
  displayNamePlural: "pull requests",
  displayNameCapitalized: "Pull Request",
  displayNameCapitalizedPlural: "Pull Requests",
};

// === End of ./close_entity_helpers.cjs ===


/**
 * Get pull request details using REST API
 * @param {any} github - GitHub REST API instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} prNumber - Pull request number
 * @returns {Promise<{number: number, title: string, labels: Array<{name: string}>, html_url: string, state: string}>} Pull request details
 */
async function getPullRequestDetails(github, owner, repo, prNumber) {
  const { data: pr } = await github.rest.pulls.get({
    owner,
    repo,
    pull_number: prNumber,
  });

  if (!pr) {
    throw new Error(`Pull request #${prNumber} not found in ${owner}/${repo}`);
  }

  return pr;
}

/**
 * Add comment to a GitHub Pull Request using REST API
 * @param {any} github - GitHub REST API instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} prNumber - Pull request number
 * @param {string} message - Comment body
 * @returns {Promise<{id: number, html_url: string}>} Comment details
 */
async function addPullRequestComment(github, owner, repo, prNumber, message) {
  const { data: comment } = await github.rest.issues.createComment({
    owner,
    repo,
    issue_number: prNumber,
    body: message,
  });

  return comment;
}

/**
 * Close a GitHub Pull Request using REST API
 * @param {any} github - GitHub REST API instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} prNumber - Pull request number
 * @returns {Promise<{number: number, html_url: string, title: string}>} Pull request details
 */
async function closePullRequest(github, owner, repo, prNumber) {
  const { data: pr } = await github.rest.pulls.update({
    owner,
    repo,
    pull_number: prNumber,
    state: "closed",
  });

  return pr;
}

async function main() {
  return processCloseEntityItems(PULL_REQUEST_CONFIG, {
    getDetails: getPullRequestDetails,
    addComment: addPullRequestComment,
    closeEntity: closePullRequest,
  });
}

await main();
