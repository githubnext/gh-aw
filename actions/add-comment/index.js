// Embedded files for bundling
const FILES = {
    "generate_footer.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Generates an XML comment marker with agentic workflow metadata for traceability.\n * This marker enables searching and tracing back items generated by an agentic workflow.\n *\n * Note: This function is duplicated in messages_footer.cjs. While normally we would\n * consolidate to a shared module, importing messages_footer.cjs here would cause the\n * bundler to inline messages_core.cjs which contains 'GH_AW_SAFE_OUTPUT_MESSAGES:' in\n * a warning message, breaking tests that check for env var declarations.\n *\n * @param {string} workflowName - Name of the workflow\n * @param {string} runUrl - URL of the workflow run\n * @returns {string} XML comment marker with workflow metadata\n */\nfunction generateXMLMarker(workflowName, runUrl) {\n  // Read engine metadata from environment variables\n  const engineId = process.env.GH_AW_ENGINE_ID || \"\";\n  const engineVersion = process.env.GH_AW_ENGINE_VERSION || \"\";\n  const engineModel = process.env.GH_AW_ENGINE_MODEL || \"\";\n  const trackerId = process.env.GH_AW_TRACKER_ID || \"\";\n\n  // Build the key-value pairs for the marker\n  const parts = [];\n\n  // Always include agentic-workflow name\n  parts.push(`agentic-workflow: `);\n\n  // Add tracker-id if available (for searchability and tracing)\n  if (trackerId) {\n    parts.push(`tracker-id: `);\n  }\n\n  // Add engine ID if available\n  if (engineId) {\n    parts.push(`engine: `);\n  }\n\n  // Add version if available\n  if (engineVersion) {\n    parts.push(`version: `);\n  }\n\n  // Add model if available\n  if (engineModel) {\n    parts.push(`model: `);\n  }\n\n  // Always include run URL\n  parts.push(`run: `);\n\n  // Return the XML comment marker\n  return `\u003c!-- ${parts.join(\", \")} --\u003e`;\n}\n\n/**\n * Generate footer with AI attribution and workflow installation instructions\n * @param {string} workflowName - Name of the workflow\n * @param {string} runUrl - URL of the workflow run\n * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)\n * @param {string} workflowSourceURL - GitHub URL for the workflow source\n * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow\n * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow\n * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow\n * @returns {string} Footer text\n */\nfunction generateFooter(\n  workflowName,\n  runUrl,\n  workflowSource,\n  workflowSourceURL,\n  triggeringIssueNumber,\n  triggeringPRNumber,\n  triggeringDiscussionNumber\n) {\n  let footer = `\\n\\n\u003e AI generated by []()`;\n\n  // Add reference to triggering issue/PR/discussion if available\n  if (triggeringIssueNumber) {\n    footer += ` for #`;\n  } else if (triggeringPRNumber) {\n    footer += ` for #`;\n  } else if (triggeringDiscussionNumber) {\n    footer += ` for discussion #`;\n  }\n\n  if (workflowSource \u0026\u0026 workflowSourceURL) {\n    footer += `\\n\u003e\\n\u003e To add this workflow in your repository, run \\`gh aw add \\`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).`;\n  }\n\n  // Add XML comment marker for traceability\n  footer += \"\\n\\n\" + generateXMLMarker(workflowName, runUrl);\n\n  footer += \"\\n\";\n  return footer;\n}\n\nmodule.exports = {\n  generateFooter,\n  generateXMLMarker,\n};\n",
    "get_repository_url.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Get the repository URL for different purposes\n * This helper handles trial mode where target repository URLs are different from execution context\n * @returns {string} Repository URL\n */\nfunction getRepositoryUrl() {\n  // For trial mode, use target repository for issue/PR URLs but execution context for action runs\n  const targetRepoSlug = process.env.GH_AW_TARGET_REPO_SLUG;\n\n  if (targetRepoSlug) {\n    // Use target repository for issue/PR URLs in trial mode\n    const githubServer = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n    return `/`;\n  } else if (context.payload.repository?.html_url) {\n    // Use execution context repository (default behavior)\n    return context.payload.repository.html_url;\n  } else {\n    // Final fallback for action runs when context repo is not available\n    const githubServer = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n    return `/${context.repo.owner}/${context.repo.repo}`;\n  }\n}\n\nmodule.exports = {\n  getRepositoryUrl,\n};\n",
    "get_tracker_id.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Get tracker-id from environment variable, log it, and optionally format it\n * @param {string} [format] - Output format: \"markdown\" for HTML comment, \"text\" for plain text, or undefined for raw value\n * @returns {string} Tracker ID in requested format or empty string\n */\nfunction getTrackerID(format) {\n  const trackerID = process.env.GH_AW_TRACKER_ID || \"\";\n  if (trackerID) {\n    core.info(`Tracker ID: `);\n    return format === \"markdown\" ? `\\n\\n\u003c!-- tracker-id:  --\u003e` : trackerID;\n  }\n  return \"\";\n}\n\nmodule.exports = {\n  getTrackerID,\n};\n",
    "load_agent_output.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\nconst fs = require(\"fs\");\n\n/**\n * Maximum content length to log for debugging purposes\n * @type {number}\n */\nconst MAX_LOG_CONTENT_LENGTH = 10000;\n\n/**\n * Truncate content for logging if it exceeds the maximum length\n * @param {string} content - Content to potentially truncate\n * @returns {string} Truncated content with indicator if truncated\n */\nfunction truncateForLogging(content) {\n  if (content.length \u003c= MAX_LOG_CONTENT_LENGTH) {\n    return content;\n  }\n  return content.substring(0, MAX_LOG_CONTENT_LENGTH) + `\\n... (truncated, total length: ${content.length})`;\n}\n\n/**\n * Load and parse agent output from the GH_AW_AGENT_OUTPUT file\n *\n * This utility handles the common pattern of:\n * 1. Reading the GH_AW_AGENT_OUTPUT environment variable\n * 2. Loading the file content\n * 3. Validating the JSON structure\n * 4. Returning parsed items array\n *\n * @returns {{\n *   success: true,\n *   items: any[]\n * } | {\n *   success: false,\n *   items?: undefined,\n *   error?: string\n * }} Result object with success flag and items array (if successful) or error message\n */\nfunction loadAgentOutput() {\n  const agentOutputFile = process.env.GH_AW_AGENT_OUTPUT;\n\n  // No agent output file specified\n  if (!agentOutputFile) {\n    core.info(\"No GH_AW_AGENT_OUTPUT environment variable found\");\n    return { success: false };\n  }\n\n  // Read agent output from file\n  let outputContent;\n  try {\n    outputContent = fs.readFileSync(agentOutputFile, \"utf8\");\n  } catch (error) {\n    const errorMessage = `Error reading agent output file: ${error instanceof Error ? error.message : String(error)}`;\n    core.error(errorMessage);\n    return { success: false, error: errorMessage };\n  }\n\n  // Check for empty content\n  if (outputContent.trim() === \"\") {\n    core.info(\"Agent output content is empty\");\n    return { success: false };\n  }\n\n  core.info(`Agent output content length: ${outputContent.length}`);\n\n  // Parse the validated output JSON\n  let validatedOutput;\n  try {\n    validatedOutput = JSON.parse(outputContent);\n  } catch (error) {\n    const errorMessage = `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`;\n    core.error(errorMessage);\n    core.info(`Failed to parse content:\\n${truncateForLogging(outputContent)}`);\n    return { success: false, error: errorMessage };\n  }\n\n  // Validate items array exists\n  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {\n    core.info(\"No valid items found in agent output\");\n    core.info(`Parsed content: ${truncateForLogging(JSON.stringify(validatedOutput))}`);\n    return { success: false };\n  }\n\n  return { success: true, items: validatedOutput.items };\n}\n\nmodule.exports = { loadAgentOutput, truncateForLogging, MAX_LOG_CONTENT_LENGTH };\n",
    "repo_helpers.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Repository-related helper functions for safe-output scripts\n * Provides common repository parsing, validation, and resolution logic\n */\n\n/**\n * Parse the allowed repos from environment variable\n * @returns {Set\u003cstring\u003e} Set of allowed repository slugs\n */\nfunction parseAllowedRepos() {\n  const allowedReposEnv = process.env.GH_AW_ALLOWED_REPOS;\n  const set = new Set();\n  if (allowedReposEnv) {\n    allowedReposEnv\n      .split(\",\")\n      .map(repo =\u003e repo.trim())\n      .filter(repo =\u003e repo)\n      .forEach(repo =\u003e set.add(repo));\n  }\n  return set;\n}\n\n/**\n * Get the default target repository\n * @returns {string} Repository slug in \"owner/repo\" format\n */\nfunction getDefaultTargetRepo() {\n  // First check if there's a target-repo override\n  const targetRepoSlug = process.env.GH_AW_TARGET_REPO_SLUG;\n  if (targetRepoSlug) {\n    return targetRepoSlug;\n  }\n  // Fall back to context repo\n  return `${context.repo.owner}/${context.repo.repo}`;\n}\n\n/**\n * Validate that a repo is allowed for operations\n * @param {string} repo - Repository slug to validate\n * @param {string} defaultRepo - Default target repository\n * @param {Set\u003cstring\u003e} allowedRepos - Set of explicitly allowed repos\n * @returns {{valid: boolean, error: string|null}}\n */\nfunction validateRepo(repo, defaultRepo, allowedRepos) {\n  // Default repo is always allowed\n  if (repo === defaultRepo) {\n    return { valid: true, error: null };\n  }\n  // Check if it's in the allowed repos list\n  if (allowedRepos.has(repo)) {\n    return { valid: true, error: null };\n  }\n  return {\n    valid: false,\n    error: `Repository '' is not in the allowed-repos list. Allowed: ${allowedRepos.size \u003e 0 ? \", \" + Array.from(allowedRepos).join(\", \") : \"\"}`,\n  };\n}\n\n/**\n * Parse owner and repo from a repository slug\n * @param {string} repoSlug - Repository slug in \"owner/repo\" format\n * @returns {{owner: string, repo: string}|null}\n */\nfunction parseRepoSlug(repoSlug) {\n  const parts = repoSlug.split(\"/\");\n  if (parts.length !== 2 || !parts[0] || !parts[1]) {\n    return null;\n  }\n  return { owner: parts[0], repo: parts[1] };\n}\n\nmodule.exports = {\n  parseAllowedRepos,\n  getDefaultTargetRepo,\n  validateRepo,\n  parseRepoSlug,\n};\n",
    "sanitize_label_content.cjs": "// @ts-check\n/**\n * Sanitize label content for GitHub API\n * Removes control characters, ANSI codes, and neutralizes @mentions\n * @module sanitize_label_content\n */\n\n/**\n * Sanitizes label content by removing control characters, ANSI escape codes,\n * and neutralizing @mentions to prevent unintended notifications.\n *\n * @param {string} content - The label content to sanitize\n * @returns {string} The sanitized label content\n */\nfunction sanitizeLabelContent(content) {\n  if (!content || typeof content !== \"string\") {\n    return \"\";\n  }\n  let sanitized = content.trim();\n  // Remove ANSI escape sequences FIRST (before removing control chars)\n  sanitized = sanitized.replace(/\\x1b\\[[0-9;]*[mGKH]/g, \"\");\n  // Then remove control characters (except newlines and tabs)\n  sanitized = sanitized.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, \"\");\n  sanitized = sanitized.replace(\n    /(^|[^\\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\\/[A-Za-z0-9._-]+)?)/g,\n    (_m, p1, p2) =\u003e `\\`@\\``\n  );\n  sanitized = sanitized.replace(/[\u003c\u003e\u0026'\"]/g, \"\");\n  return sanitized.trim();\n}\n\nmodule.exports = { sanitizeLabelContent };\n"
  };

// Helper to load embedded files
function requireFile(filename) {
  const content = FILES[filename];
  if (!content) {
    throw new Error(`File not found: ${filename}`);
  }
  const exports = {};
  const module = { exports };
  const func = new Function('exports', 'module', 'require', content);
  func(exports, module, requireFile);
  return module.exports;
}

// @ts-check
/// <reference types="@actions/github-script" />

const { loadAgentOutput } = requireFile('load_agent_output.cjs');
const { generateFooterWithMessages } = requireFile('messages_footer.cjs');
const { getTrackerID } = requireFile('get_tracker_id.cjs');
const { getRepositoryUrl } = requireFile('get_repository_url.cjs');
const { replaceTemporaryIdReferences, loadTemporaryIdMap } = requireFile('temporary_id.cjs');

/**
 * Comment on a GitHub Discussion using GraphQL
 * @param {any} github - GitHub REST API instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} discussionNumber - Discussion number
 * @param {string} message - Comment body
 * @param {string|undefined} replyToId - Optional comment node ID to reply to (for threaded comments)
 * @returns {Promise<{id: string, html_url: string, discussion_url: string}>} Comment details
 */
async function commentOnDiscussion(github, owner, repo, discussionNumber, message, replyToId) {
  // 1. Retrieve discussion node ID
  const { repository } = await github.graphql(
    `
    query($owner: String!, $repo: String!, $num: Int!) {
      repository(owner: $owner, name: $repo) {
        discussion(number: $num) { 
          id 
          url
        }
      }
    }`,
    { owner, repo, num: discussionNumber }
  );

  if (!repository || !repository.discussion) {
    throw new Error(`Discussion #${discussionNumber} not found in ${owner}/${repo}`);
  }

  const discussionId = repository.discussion.id;
  const discussionUrl = repository.discussion.url;

  // 2. Add comment (with optional replyToId for threading)
  let result;
  if (replyToId) {
    // Create a threaded reply to an existing comment
    result = await github.graphql(
      `
      mutation($dId: ID!, $body: String!, $replyToId: ID!) {
        addDiscussionComment(input: { discussionId: $dId, body: $body, replyToId: $replyToId }) {
          comment { 
            id 
            body 
            createdAt 
            url
          }
        }
      }`,
      { dId: discussionId, body: message, replyToId }
    );
  } else {
    // Create a top-level comment on the discussion
    result = await github.graphql(
      `
      mutation($dId: ID!, $body: String!) {
        addDiscussionComment(input: { discussionId: $dId, body: $body }) {
          comment { 
            id 
            body 
            createdAt 
            url
          }
        }
      }`,
      { dId: discussionId, body: message }
    );
  }

  const comment = result.addDiscussionComment.comment;

  return {
    id: comment.id,
    html_url: comment.url,
    discussion_url: discussionUrl,
  };
}

async function main() {
  // Check if we're in staged mode
  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";
  const isDiscussionExplicit = process.env.GITHUB_AW_COMMENT_DISCUSSION === "true";

  // Load the temporary ID map from create_issue job
  const temporaryIdMap = loadTemporaryIdMap();
  if (temporaryIdMap.size > 0) {
    core.info(`Loaded temporary ID map with ${temporaryIdMap.size} entries`);
  }

  const result = loadAgentOutput();
  if (!result.success) {
    return;
  }

  // Find all add-comment items
  const commentItems = result.items.filter(/** @param {any} item */ item => item.type === "add_comment");
  if (commentItems.length === 0) {
    core.info("No add-comment items found in agent output");
    return;
  }

  core.info(`Found ${commentItems.length} add-comment item(s)`);

  // Helper function to get the target number (issue, discussion, or pull request)
  function getTargetNumber(item) {
    return item.item_number;
  }

  // Get the target configuration from environment variable
  const commentTarget = process.env.GH_AW_COMMENT_TARGET || "triggering";
  core.info(`Comment target configuration: ${commentTarget}`);

  // Check if we're in an issue, pull request, or discussion context
  const isIssueContext = context.eventName === "issues" || context.eventName === "issue_comment";
  const isPRContext =
    context.eventName === "pull_request" ||
    context.eventName === "pull_request_review" ||
    context.eventName === "pull_request_review_comment";
  const isDiscussionContext = context.eventName === "discussion" || context.eventName === "discussion_comment";
  const isDiscussion = isDiscussionContext || isDiscussionExplicit;

  // If in staged mode, emit step summary instead of creating comments
  if (isStaged) {
    let summaryContent = "## ðŸŽ­ Staged Mode: Add Comments Preview\n\n";
    summaryContent += "The following comments would be added if staged mode was disabled:\n\n";

    // Show created items references if available
    const createdIssueUrl = process.env.GH_AW_CREATED_ISSUE_URL;
    const createdIssueNumber = process.env.GH_AW_CREATED_ISSUE_NUMBER;
    const createdDiscussionUrl = process.env.GH_AW_CREATED_DISCUSSION_URL;
    const createdDiscussionNumber = process.env.GH_AW_CREATED_DISCUSSION_NUMBER;
    const createdPullRequestUrl = process.env.GH_AW_CREATED_PULL_REQUEST_URL;
    const createdPullRequestNumber = process.env.GH_AW_CREATED_PULL_REQUEST_NUMBER;

    if (createdIssueUrl || createdDiscussionUrl || createdPullRequestUrl) {
      summaryContent += "#### Related Items\n\n";
      if (createdIssueUrl && createdIssueNumber) {
        summaryContent += `- Issue: [#${createdIssueNumber}](${createdIssueUrl})\n`;
      }
      if (createdDiscussionUrl && createdDiscussionNumber) {
        summaryContent += `- Discussion: [#${createdDiscussionNumber}](${createdDiscussionUrl})\n`;
      }
      if (createdPullRequestUrl && createdPullRequestNumber) {
        summaryContent += `- Pull Request: [#${createdPullRequestNumber}](${createdPullRequestUrl})\n`;
      }
      summaryContent += "\n";
    }

    for (let i = 0; i < commentItems.length; i++) {
      const item = commentItems[i];
      summaryContent += `### Comment ${i + 1}\n`;
      const targetNumber = getTargetNumber(item);
      if (targetNumber) {
        const repoUrl = getRepositoryUrl();
        if (isDiscussion) {
          const discussionUrl = `${repoUrl}/discussions/${targetNumber}`;
          summaryContent += `**Target Discussion:** [#${targetNumber}](${discussionUrl})\n\n`;
        } else {
          const issueUrl = `${repoUrl}/issues/${targetNumber}`;
          summaryContent += `**Target Issue:** [#${targetNumber}](${issueUrl})\n\n`;
        }
      } else {
        if (isDiscussion) {
          summaryContent += `**Target:** Current discussion\n\n`;
        } else {
          summaryContent += `**Target:** Current issue/PR\n\n`;
        }
      }
      summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
      summaryContent += "---\n\n";
    }

    // Write to step summary
    await core.summary.addRaw(summaryContent).write();
    core.info("ðŸ“ Comment creation preview written to step summary");
    return;
  }

  // Validate context based on target configuration
  if (commentTarget === "triggering" && !isIssueContext && !isPRContext && !isDiscussionContext) {
    core.info('Target is "triggering" but not running in issue, pull request, or discussion context, skipping comment creation');
    return;
  }

  // Extract triggering context for footer generation
  const triggeringIssueNumber =
    context.payload?.issue?.number && !context.payload?.issue?.pull_request ? context.payload.issue.number : undefined;
  const triggeringPRNumber =
    context.payload?.pull_request?.number || (context.payload?.issue?.pull_request ? context.payload.issue.number : undefined);
  const triggeringDiscussionNumber = context.payload?.discussion?.number;

  const createdComments = [];

  // Process each comment item
  for (let i = 0; i < commentItems.length; i++) {
    const commentItem = commentItems[i];
    core.info(`Processing add-comment item ${i + 1}/${commentItems.length}: bodyLength=${commentItem.body.length}`);

    // Determine the issue/PR number and comment endpoint for this comment
    let itemNumber;
    let commentEndpoint;

    if (commentTarget === "*") {
      // For target "*", we need an explicit number from the comment item
      const targetNumber = getTargetNumber(commentItem);
      if (targetNumber) {
        itemNumber = parseInt(targetNumber, 10);
        if (isNaN(itemNumber) || itemNumber <= 0) {
          core.info(`Invalid target number specified: ${targetNumber}`);
          continue;
        }
        commentEndpoint = isDiscussion ? "discussions" : "issues";
      } else {
        core.info(`Target is "*" but no number specified in comment item`);
        continue;
      }
    } else if (commentTarget && commentTarget !== "triggering") {
      // Explicit number specified in target configuration
      itemNumber = parseInt(commentTarget, 10);
      if (isNaN(itemNumber) || itemNumber <= 0) {
        core.info(`Invalid target number in target configuration: ${commentTarget}`);
        continue;
      }
      commentEndpoint = isDiscussion ? "discussions" : "issues";
    } else {
      // Default behavior: use triggering issue/PR/discussion
      if (isIssueContext) {
        itemNumber = context.payload.issue?.number || context.payload.pull_request?.number || context.payload.discussion?.number;
        if (context.payload.issue) {
          commentEndpoint = "issues";
        } else {
          core.info("Issue context detected but no issue found in payload");
          continue;
        }
      } else if (isPRContext) {
        itemNumber = context.payload.pull_request?.number || context.payload.issue?.number || context.payload.discussion?.number;
        if (context.payload.pull_request) {
          commentEndpoint = "issues"; // PR comments use the issues API endpoint
        } else {
          core.info("Pull request context detected but no pull request found in payload");
          continue;
        }
      } else if (isDiscussionContext) {
        itemNumber = context.payload.discussion?.number || context.payload.issue?.number || context.payload.pull_request?.number;
        if (context.payload.discussion) {
          commentEndpoint = "discussions"; // Discussion comments use GraphQL via commentOnDiscussion
        } else {
          core.info("Discussion context detected but no discussion found in payload");
          continue;
        }
      }
    }

    if (!itemNumber) {
      core.info("Could not determine issue, pull request, or discussion number");
      continue;
    }

    // Extract body from the JSON item and replace temporary ID references
    let body = replaceTemporaryIdReferences(commentItem.body.trim(), temporaryIdMap);

    // Append references to created issues, discussions, and pull requests if they exist
    const createdIssueUrl = process.env.GH_AW_CREATED_ISSUE_URL;
    const createdIssueNumber = process.env.GH_AW_CREATED_ISSUE_NUMBER;
    const createdDiscussionUrl = process.env.GH_AW_CREATED_DISCUSSION_URL;
    const createdDiscussionNumber = process.env.GH_AW_CREATED_DISCUSSION_NUMBER;
    const createdPullRequestUrl = process.env.GH_AW_CREATED_PULL_REQUEST_URL;
    const createdPullRequestNumber = process.env.GH_AW_CREATED_PULL_REQUEST_NUMBER;

    // Add references section if any URLs are available
    let hasReferences = false;
    let referencesSection = "\n\n#### Related Items\n\n";

    if (createdIssueUrl && createdIssueNumber) {
      referencesSection += `- Issue: [#${createdIssueNumber}](${createdIssueUrl})\n`;
      hasReferences = true;
    }
    if (createdDiscussionUrl && createdDiscussionNumber) {
      referencesSection += `- Discussion: [#${createdDiscussionNumber}](${createdDiscussionUrl})\n`;
      hasReferences = true;
    }
    if (createdPullRequestUrl && createdPullRequestNumber) {
      referencesSection += `- Pull Request: [#${createdPullRequestNumber}](${createdPullRequestUrl})\n`;
      hasReferences = true;
    }

    if (hasReferences) {
      body += referencesSection;
    }

    // Add AI disclaimer with workflow name and run url
    const workflowName = process.env.GH_AW_WORKFLOW_NAME || "Workflow";
    const workflowSource = process.env.GH_AW_WORKFLOW_SOURCE || "";
    const workflowSourceURL = process.env.GH_AW_WORKFLOW_SOURCE_URL || "";
    const runId = context.runId;
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    const runUrl = context.payload.repository
      ? `${context.payload.repository.html_url}/actions/runs/${runId}`
      : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;

    // Add fingerprint comment if present
    body += getTrackerID("markdown");

    body += generateFooterWithMessages(
      workflowName,
      runUrl,
      workflowSource,
      workflowSourceURL,
      triggeringIssueNumber,
      triggeringPRNumber,
      triggeringDiscussionNumber
    );

    try {
      let comment;

      // Use GraphQL API for discussions, REST API for issues/PRs
      if (commentEndpoint === "discussions") {
        core.info(`Creating comment on discussion #${itemNumber}`);
        core.info(`Comment content length: ${body.length}`);

        // For discussion_comment events, extract the comment node_id to create a threaded reply
        let replyToId;
        if (context.eventName === "discussion_comment" && context.payload?.comment?.node_id) {
          replyToId = context.payload.comment.node_id;
          core.info(`Creating threaded reply to comment ${replyToId}`);
        }

        // Create discussion comment using GraphQL
        comment = await commentOnDiscussion(github, context.repo.owner, context.repo.repo, itemNumber, body, replyToId);
        core.info("Created discussion comment #" + comment.id + ": " + comment.html_url);

        // Add discussion_url to the comment object for consistency
        comment.discussion_url = comment.discussion_url;
      } else {
        core.info(`Creating comment on ${commentEndpoint} #${itemNumber}`);
        core.info(`Comment content length: ${body.length}`);

        // Create regular issue/PR comment using REST API
        const { data: restComment } = await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: itemNumber,
          body: body,
        });

        comment = restComment;
        core.info("Created comment #" + comment.id + ": " + comment.html_url);
      }

      createdComments.push(comment);

      // Set output for the last created comment (for backward compatibility)
      if (i === commentItems.length - 1) {
        core.setOutput("comment_id", comment.id);
        core.setOutput("comment_url", comment.html_url);
      }
    } catch (error) {
      core.error(`âœ— Failed to create comment: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  // Write summary for all created comments
  if (createdComments.length > 0) {
    let summaryContent = "\n\n## GitHub Comments\n";
    for (const comment of createdComments) {
      summaryContent += `- Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }

  core.info(`Successfully created ${createdComments.length} comment(s)`);
  return createdComments;
}
await main();
