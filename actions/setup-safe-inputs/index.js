// Safe Inputs Copy Action
// Copies safe-inputs MCP server files to the agent environment

const core = require('@actions/core');
const fs = require('fs');
const path = require('path');

// Embedded safe-inputs files will be inserted here during build
const FILES = {
    "mcp_logger.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * MCP Logger Utility\n *\n * This module provides logger creation utilities for MCP servers.\n * It creates logger objects with debug and debugError methods that write\n * timestamped messages to stderr.\n *\n * Usage:\n *   const { createLogger } = require(\"./mcp_logger.cjs\");\n *   const logger = createLogger(\"my-server\");\n *   logger.debug(\"Server started\");\n *   logger.debugError(\"Error: \", new Error(\"Something went wrong\"));\n */\n\n/**\n * Create a logger object with debug and debugError methods\n * @param {string} serverName - Name to include in log messages\n * @returns {Object} Logger object with debug and debugError methods\n */\nfunction createLogger(serverName) {\n  const logger = {\n    /**\n     * Log a debug message to stderr with timestamp\n     * @param {string} msg - Message to log\n     */\n    debug: msg =\u003e {\n      const timestamp = new Date().toISOString();\n      process.stderr.write(`[] [] \\n`);\n    },\n\n    /**\n     * Log an error with optional stack trace\n     * @param {string} prefix - Prefix for the error message\n     * @param {Error|string|any} error - Error object or message\n     */\n    debugError: (prefix, error) =\u003e {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.debug(``);\n      if (error instanceof Error \u0026\u0026 error.stack) {\n        logger.debug(`Stack trace: ${error.stack}`);\n      }\n    },\n  };\n\n  return logger;\n}\n\nmodule.exports = {\n  createLogger,\n};\n",
    "mcp_server_core.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * MCP Server Core Module\n *\n * This module provides a reusable API for creating MCP (Model Context Protocol) servers.\n * It handles JSON-RPC 2.0 message parsing, tool registration, and server lifecycle.\n *\n * Usage:\n *   const { createServer, registerTool, start } = require(\"./mcp_server_core.cjs\");\n *\n *   const server = createServer({ name: \"my-server\", version: \"1.0.0\" });\n *   registerTool(server, {\n *     name: \"my_tool\",\n *     description: \"A tool\",\n *     inputSchema: { type: \"object\", properties: {} },\n *     handler: (args) =\u003e ({ content: [{ type: \"text\", text: \"result\" }] })\n *   });\n *   start(server);\n */\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst { ReadBuffer } = require(\"./read_buffer.cjs\");\nconst { validateRequiredFields } = require(\"./safe_inputs_validation.cjs\");\n\nconst encoder = new TextEncoder();\n\n/**\n * @typedef {Object} ServerInfo\n * @property {string} name - Server name\n * @property {string} version - Server version\n */\n\n/**\n * @typedef {Object} Tool\n * @property {string} name - Tool name\n * @property {string} description - Tool description\n * @property {Object} inputSchema - JSON Schema for tool inputs\n * @property {Function} [handler] - Tool handler function\n * @property {string} [handlerPath] - Optional file path to handler module (original path from config)\n * @property {number} [timeout] - Timeout in seconds for tool execution (default: 60)\n */\n\n/**\n * @typedef {Object} MCPServer\n * @property {ServerInfo} serverInfo - Server information\n * @property {Object\u003cstring, Tool\u003e} tools - Registered tools\n * @property {Function} debug - Debug logging function\n * @property {Function} debugError - Debug logging function for errors (extracts message from Error objects)\n * @property {Function} writeMessage - Write message to stdout\n * @property {Function} replyResult - Send a result response\n * @property {Function} replyError - Send an error response\n * @property {ReadBuffer} readBuffer - Message buffer\n * @property {string} [logDir] - Optional log directory\n * @property {string} [logFilePath] - Optional log file path\n * @property {boolean} logFileInitialized - Whether log file has been initialized\n */\n\n/**\n * Initialize log file for the server\n * @param {MCPServer} server - The MCP server instance\n */\nfunction initLogFile(server) {\n  if (server.logFileInitialized || !server.logDir || !server.logFilePath) return;\n  try {\n    if (!fs.existsSync(server.logDir)) {\n      fs.mkdirSync(server.logDir, { recursive: true });\n    }\n    // Initialize/truncate log file with header\n    const timestamp = new Date().toISOString();\n    fs.writeFileSync(server.logFilePath, `# ${server.serverInfo.name} MCP Server Log\\n# Started: \\n# Version: ${server.serverInfo.version}\\n\\n`);\n    server.logFileInitialized = true;\n  } catch {\n    // Silently ignore errors - logging to stderr will still work\n  }\n}\n\n/**\n * Create a debug function for the server\n * @param {MCPServer} server - The MCP server instance\n * @returns {Function} Debug function\n */\nfunction createDebugFunction(server) {\n  return msg =\u003e {\n    const timestamp = new Date().toISOString();\n    const formattedMsg = `[] [${server.serverInfo.name}] \\n`;\n\n    // Always write to stderr\n    process.stderr.write(formattedMsg);\n\n    // Also write to log file if log directory is set (initialize on first use)\n    if (server.logDir \u0026\u0026 server.logFilePath) {\n      if (!server.logFileInitialized) {\n        initLogFile(server);\n      }\n      if (server.logFileInitialized) {\n        try {\n          fs.appendFileSync(server.logFilePath, formattedMsg);\n        } catch {\n          // Silently ignore file write errors - stderr logging still works\n        }\n      }\n    }\n  };\n}\n\n/**\n * Create a debugError function for the server that handles error casting\n * @param {MCPServer} server - The MCP server instance\n * @returns {Function} Debug error function that extracts message from Error objects\n */\nfunction createDebugErrorFunction(server) {\n  return (prefix, error) =\u003e {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    server.debug(``);\n    if (error instanceof Error \u0026\u0026 error.stack) {\n      server.debug(`Stack trace: ${error.stack}`);\n    }\n  };\n}\n\n/**\n * Create a writeMessage function for the server\n * @param {MCPServer} server - The MCP server instance\n * @returns {Function} Write message function\n */\nfunction createWriteMessageFunction(server) {\n  return obj =\u003e {\n    const json = JSON.stringify(obj);\n    server.debug(`send: `);\n    const message = json + \"\\n\";\n    const bytes = encoder.encode(message);\n    fs.writeSync(1, bytes);\n  };\n}\n\n/**\n * Create a replyResult function for the server\n * @param {MCPServer} server - The MCP server instance\n * @returns {Function} Reply result function\n */\nfunction createReplyResultFunction(server) {\n  return (id, result) =\u003e {\n    if (id === undefined || id === null) return; // notification\n    const res = { jsonrpc: \"2.0\", id, result };\n    server.writeMessage(res);\n  };\n}\n\n/**\n * Create a replyError function for the server\n * @param {MCPServer} server - The MCP server instance\n * @returns {Function} Reply error function\n */\nfunction createReplyErrorFunction(server) {\n  return (id, code, message) =\u003e {\n    // Don't send error responses for notifications (id is null/undefined)\n    if (id === undefined || id === null) {\n      server.debug(`Error for notification: `);\n      return;\n    }\n\n    const error = { code, message };\n    const res = {\n      jsonrpc: \"2.0\",\n      id,\n      error,\n    };\n    server.writeMessage(res);\n  };\n}\n\n/**\n * Create a new MCP server instance\n * @param {ServerInfo} serverInfo - Server information (name and version)\n * @param {Object} [options] - Optional server configuration\n * @param {string} [options.logDir] - Directory for log file (optional)\n * @returns {MCPServer} The MCP server instance\n */\nfunction createServer(serverInfo, options = {}) {\n  const logDir = options.logDir || undefined;\n  const logFilePath = logDir ? path.join(logDir, \"server.log\") : undefined;\n\n  /** @type {MCPServer} */\n  const server = {\n    serverInfo,\n    tools: {},\n    debug: () =\u003e {}, // placeholder\n    debugError: () =\u003e {}, // placeholder\n    writeMessage: () =\u003e {}, // placeholder\n    replyResult: () =\u003e {}, // placeholder\n    replyError: () =\u003e {}, // placeholder\n    readBuffer: new ReadBuffer(),\n    logDir,\n    logFilePath,\n    logFileInitialized: false,\n  };\n\n  // Initialize functions with references to server\n  server.debug = createDebugFunction(server);\n  server.debugError = createDebugErrorFunction(server);\n  server.writeMessage = createWriteMessageFunction(server);\n  server.replyResult = createReplyResultFunction(server);\n  server.replyError = createReplyErrorFunction(server);\n\n  return server;\n}\n\n/**\n * Create a wrapped handler function that normalizes results to MCP format.\n * Extracted to avoid creating closures with excessive scope in loadToolHandlers.\n *\n * @param {MCPServer} server - The MCP server instance for logging\n * @param {string} toolName - Name of the tool for logging purposes\n * @param {Function} handlerFn - The original handler function to wrap\n * @returns {Function} Wrapped async handler function\n */\nfunction createWrappedHandler(server, toolName, handlerFn) {\n  return async args =\u003e {\n    server.debug(`  [] Invoking handler with args: ${JSON.stringify(args)}`);\n\n    try {\n      // Call the handler (may be sync or async)\n      const result = await Promise.resolve(handlerFn(args));\n      server.debug(`  [] Handler returned result type: ${typeof result}`);\n\n      // If the result is already in MCP format (has content array), return as-is\n      if (result \u0026\u0026 typeof result === \"object\" \u0026\u0026 Array.isArray(result.content)) {\n        server.debug(`  [] Result is already in MCP format`);\n        return result;\n      }\n\n      // Otherwise, serialize the result to text\n      // Use try-catch for serialization to handle circular references and non-serializable values\n      let serializedResult;\n      try {\n        serializedResult = JSON.stringify(result);\n      } catch (serializationError) {\n        server.debugError(`  [] Serialization error: `, serializationError);\n        // Fall back to String() for non-serializable values\n        serializedResult = String(result);\n      }\n      server.debug(`  [] Serialized result: ${serializedResult.substring(0, 200)}${serializedResult.length \u003e 200 ? \"...\" : \"\"}`);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: serializedResult,\n          },\n        ],\n      };\n    } catch (error) {\n      server.debugError(`  [] Handler threw error: `, error);\n      throw error;\n    }\n  };\n}\n\n/**\n * Load handler functions from file paths specified in tools configuration.\n * This function iterates through tools and loads handler modules based on file extension:\n *\n * For JavaScript handlers (.js, .cjs, .mjs):\n *   - Uses require() to load the module\n *   - Handler must export a function as default export\n *   - Handler signature: async function handler(args: Record\u003cstring, unknown\u003e): Promise\u003cunknown\u003e\n *\n * For Shell script handlers (.sh):\n *   - Uses GitHub Actions convention for passing inputs/outputs\n *   - Inputs are passed as environment variables prefixed with INPUT_ (uppercased)\n *   - Outputs are read from GITHUB_OUTPUT file (key=value format per line)\n *   - Returns: { stdout, stderr, outputs }\n *\n * For Python script handlers (.py):\n *   - Uses GitHub Actions convention for passing inputs/outputs\n *   - Inputs are passed as environment variables prefixed with INPUT_ (uppercased)\n *   - Outputs are read from GITHUB_OUTPUT file (key=value format per line)\n *   - Executed using python3 command\n *   - Returns: { stdout, stderr, outputs }\n *\n * SECURITY NOTE: Handler paths are loaded from tools.json configuration file,\n * which should be controlled by the server administrator. When basePath is provided,\n * relative paths are resolved within it, preventing directory traversal outside\n * the intended directory. Absolute paths bypass this validation but are still\n * logged for auditing purposes.\n *\n * @param {MCPServer} server - The MCP server instance for logging\n * @param {Array\u003cObject\u003e} tools - Array of tool configurations from tools.json\n * @param {string} [basePath] - Optional base path for resolving relative handler paths.\n *                              When provided, relative paths are validated to be within this directory.\n * @returns {Array\u003cObject\u003e} The tools array with loaded handlers attached\n */\nfunction loadToolHandlers(server, tools, basePath) {\n  server.debug(`Loading tool handlers...`);\n  server.debug(`  Total tools to process: ${tools.length}`);\n  server.debug(`  Base path: ${basePath || \"(not specified)\"}`);\n\n  let loadedCount = 0;\n  let skippedCount = 0;\n  let errorCount = 0;\n\n  for (const tool of tools) {\n    const toolName = tool.name || \"(unnamed)\";\n\n    // Check if tool has a handler path specified\n    if (!tool.handler) {\n      server.debug(`  [] No handler path specified, skipping handler load`);\n      skippedCount++;\n      continue;\n    }\n\n    const handlerPath = tool.handler;\n    server.debug(`  [] Handler path specified: `);\n\n    // Resolve the handler path\n    let resolvedPath = handlerPath;\n    if (basePath \u0026\u0026 !path.isAbsolute(handlerPath)) {\n      resolvedPath = path.resolve(basePath, handlerPath);\n      server.debug(`  [] Resolved relative path to: `);\n\n      // Security validation: Ensure resolved path is within basePath to prevent directory traversal\n      const normalizedBase = path.resolve(basePath);\n      const normalizedResolved = path.resolve(resolvedPath);\n      if (!normalizedResolved.startsWith(normalizedBase + path.sep) \u0026\u0026 normalizedResolved !== normalizedBase) {\n        server.debug(`  [] ERROR: Handler path escapes base directory:  is not within `);\n        errorCount++;\n        continue;\n      }\n    } else if (path.isAbsolute(handlerPath)) {\n      server.debug(`  [] Using absolute path (bypasses basePath validation): `);\n    }\n\n    // Store the original handler path for reference\n    tool.handlerPath = handlerPath;\n\n    try {\n      server.debug(`  [] Loading handler from: `);\n\n      // Check if file exists before loading\n      if (!fs.existsSync(resolvedPath)) {\n        server.debug(`  [] ERROR: Handler file does not exist: `);\n        errorCount++;\n        continue;\n      }\n\n      // Detect handler type by file extension\n      const ext = path.extname(resolvedPath).toLowerCase();\n      server.debug(`  [] Handler file extension: `);\n\n      if (ext === \".sh\") {\n        // Shell script handler - use GitHub Actions convention\n        server.debug(`  [] Detected shell script handler`);\n\n        // Make sure the script is executable (on Unix-like systems)\n        try {\n          fs.accessSync(resolvedPath, fs.constants.X_OK);\n          server.debug(`  [] Shell script is executable`);\n        } catch {\n          // Try to make it executable\n          try {\n            fs.chmodSync(resolvedPath, 0o755);\n            server.debug(`  [] Made shell script executable`);\n          } catch (chmodError) {\n            server.debugError(`  [] Warning: Could not make shell script executable: `, chmodError);\n            // Continue anyway - it might work depending on the shell\n          }\n        }\n\n        // Lazy-load shell handler module\n        const { createShellHandler } = require(\"./mcp_handler_shell.cjs\");\n        const timeout = tool.timeout || 60; // Default to 60 seconds if not specified\n        tool.handler = createShellHandler(server, toolName, resolvedPath, timeout);\n\n        loadedCount++;\n        server.debug(`  [] Shell handler created successfully with timeout: s`);\n      } else if (ext === \".py\") {\n        // Python script handler - use GitHub Actions convention\n        server.debug(`  [] Detected Python script handler`);\n\n        // Make sure the script is executable (on Unix-like systems)\n        try {\n          fs.accessSync(resolvedPath, fs.constants.X_OK);\n          server.debug(`  [] Python script is executable`);\n        } catch {\n          // Try to make it executable\n          try {\n            fs.chmodSync(resolvedPath, 0o755);\n            server.debug(`  [] Made Python script executable`);\n          } catch (chmodError) {\n            server.debugError(`  [] Warning: Could not make Python script executable: `, chmodError);\n            // Continue anyway - python3 will be called explicitly\n          }\n        }\n\n        // Lazy-load Python handler module\n        const { createPythonHandler } = require(\"./mcp_handler_python.cjs\");\n        const timeout = tool.timeout || 60; // Default to 60 seconds if not specified\n        tool.handler = createPythonHandler(server, toolName, resolvedPath, timeout);\n\n        loadedCount++;\n        server.debug(`  [] Python handler created successfully with timeout: s`);\n      } else {\n        // JavaScript/CommonJS handler - use require()\n        server.debug(`  [] Loading JavaScript handler module`);\n\n        // Load the handler module\n        const handlerModule = require(resolvedPath);\n        server.debug(`  [] Handler module loaded successfully`);\n        server.debug(`  [] Module type: ${typeof handlerModule}`);\n\n        // Get the handler function (support default export patterns)\n        let handlerFn = handlerModule;\n\n        // Handle ES module default export pattern (module.default)\n        if (handlerModule \u0026\u0026 typeof handlerModule === \"object\" \u0026\u0026 typeof handlerModule.default === \"function\") {\n          handlerFn = handlerModule.default;\n          server.debug(`  [] Using module.default export`);\n        }\n\n        // Validate that the handler is a function\n        if (typeof handlerFn !== \"function\") {\n          server.debug(`  [] ERROR: Handler is not a function, got: ${typeof handlerFn}`);\n          server.debug(`  [] Module keys: ${Object.keys(handlerModule || {}).join(\", \") || \"(none)\"}`);\n          errorCount++;\n          continue;\n        }\n\n        server.debug(`  [] Handler function validated successfully`);\n        server.debug(`  [] Handler function name: ${handlerFn.name || \"(anonymous)\"}`);\n\n        // Wrap the handler using the separate function to avoid bloating the closure\n        tool.handler = createWrappedHandler(server, toolName, handlerFn);\n\n        loadedCount++;\n        server.debug(`  [] JavaScript handler loaded and wrapped successfully`);\n      }\n    } catch (error) {\n      server.debugError(`  [] ERROR loading handler: `, error);\n      errorCount++;\n    }\n  }\n\n  server.debug(`Handler loading complete:`);\n  server.debug(`  Loaded: `);\n  server.debug(`  Skipped (no handler path): `);\n  server.debug(`  Errors: `);\n\n  return tools;\n}\n\n/**\n * Register a tool with the server\n * @param {MCPServer} server - The MCP server instance\n * @param {Tool} tool - The tool to register\n */\nfunction registerTool(server, tool) {\n  const normalizedName = normalizeTool(tool.name);\n  server.tools[normalizedName] = {\n    ...tool,\n    name: normalizedName,\n  };\n  server.debug(`Registered tool: `);\n}\n\n/**\n * Normalize a tool name (convert dashes to underscores, lowercase)\n * @param {string} name - The tool name to normalize\n * @returns {string} Normalized tool name\n */\nfunction normalizeTool(name) {\n  return name.replace(/-/g, \"_\").toLowerCase();\n}\n\n/**\n * Handle an incoming JSON-RPC request and return a response (for HTTP transport)\n * This function is compatible with the MCPServer class's handleRequest method.\n * @param {MCPServer} server - The MCP server instance\n * @param {Object} request - The incoming JSON-RPC request\n * @param {Function} [defaultHandler] - Default handler for tools without a handler\n * @returns {Promise\u003cObject|null\u003e} JSON-RPC response object, or null for notifications\n */\nasync function handleRequest(server, request, defaultHandler) {\n  const { id, method, params } = request;\n\n  try {\n    // Handle notifications per JSON-RPC 2.0 spec:\n    // Requests without id field are notifications (no response)\n    // Note: id can be null for valid requests, so we check for field presence with \"in\" operator\n    if (!(\"id\" in request)) {\n      // No id field - this is a notification (no response)\n      return null;\n    }\n\n    let result;\n\n    if (method === \"initialize\") {\n      const protocolVersion = params?.protocolVersion || \"2024-11-05\";\n      result = {\n        protocolVersion,\n        serverInfo: server.serverInfo,\n        capabilities: {\n          tools: {},\n        },\n      };\n    } else if (method === \"ping\") {\n      result = {};\n    } else if (method === \"tools/list\") {\n      const list = [];\n      Object.values(server.tools).forEach(tool =\u003e {\n        const toolDef = {\n          name: tool.name,\n          description: tool.description,\n          inputSchema: tool.inputSchema,\n        };\n        list.push(toolDef);\n      });\n      result = { tools: list };\n    } else if (method === \"tools/call\") {\n      const name = params?.name;\n      const args = params?.arguments ?? {};\n      if (!name || typeof name !== \"string\") {\n        throw {\n          code: -32602,\n          message: \"Invalid params: 'name' must be a string\",\n        };\n      }\n      const tool = server.tools[normalizeTool(name)];\n      if (!tool) {\n        throw {\n          code: -32602,\n          message: `Tool '' not found`,\n        };\n      }\n\n      // Use tool handler, or default handler, or error\n      let handler = tool.handler;\n      if (!handler \u0026\u0026 defaultHandler) {\n        handler = defaultHandler(tool.name);\n      }\n      if (!handler) {\n        throw {\n          code: -32603,\n          message: `No handler for tool: `,\n        };\n      }\n\n      const missing = validateRequiredFields(args, tool.inputSchema);\n      if (missing.length) {\n        throw {\n          code: -32602,\n          message: `Invalid arguments: missing or empty ${missing.map(m =\u003e `''`).join(\", \")}`,\n        };\n      }\n\n      // Call handler and await the result (supports both sync and async handlers)\n      const handlerResult = await Promise.resolve(handler(args));\n      const content = handlerResult \u0026\u0026 handlerResult.content ? handlerResult.content : [];\n      result = { content, isError: false };\n    } else if (/^notifications\\//.test(method)) {\n      // Notifications don't need a response\n      return null;\n    } else {\n      throw {\n        code: -32601,\n        message: `Method not found: `,\n      };\n    }\n\n    return {\n      jsonrpc: \"2.0\",\n      id,\n      result,\n    };\n  } catch (error) {\n    /** @type {any} */\n    const err = error;\n    return {\n      jsonrpc: \"2.0\",\n      id,\n      error: {\n        code: err.code || -32603,\n        message: err.message || \"Internal error\",\n      },\n    };\n  }\n}\n\n/**\n * Handle an incoming JSON-RPC message (for stdio transport)\n * @param {MCPServer} server - The MCP server instance\n * @param {Object} req - The incoming request\n * @param {Function} [defaultHandler] - Default handler for tools without a handler\n * @returns {Promise\u003cvoid\u003e}\n */\nasync function handleMessage(server, req, defaultHandler) {\n  // Validate basic JSON-RPC structure\n  if (!req || typeof req !== \"object\") {\n    server.debug(`Invalid message: not an object`);\n    return;\n  }\n\n  if (req.jsonrpc !== \"2.0\") {\n    server.debug(`Invalid message: missing or invalid jsonrpc field`);\n    return;\n  }\n\n  const { id, method, params } = req;\n\n  // Validate method field\n  if (!method || typeof method !== \"string\") {\n    server.replyError(id, -32600, \"Invalid Request: method must be a string\");\n    return;\n  }\n\n  try {\n    if (method === \"initialize\") {\n      const clientInfo = params?.clientInfo ?? {};\n      server.debug(`client info: ${JSON.stringify(clientInfo)}`);\n      const protocolVersion = params?.protocolVersion ?? undefined;\n      const result = {\n        serverInfo: server.serverInfo,\n        ...(protocolVersion ? { protocolVersion } : {}),\n        capabilities: {\n          tools: {},\n        },\n      };\n      server.replyResult(id, result);\n    } else if (method === \"tools/list\") {\n      const list = [];\n      Object.values(server.tools).forEach(tool =\u003e {\n        const toolDef = {\n          name: tool.name,\n          description: tool.description,\n          inputSchema: tool.inputSchema,\n        };\n        list.push(toolDef);\n      });\n      server.replyResult(id, { tools: list });\n    } else if (method === \"tools/call\") {\n      const name = params?.name;\n      const args = params?.arguments ?? {};\n      if (!name || typeof name !== \"string\") {\n        server.replyError(id, -32602, \"Invalid params: 'name' must be a string\");\n        return;\n      }\n      const tool = server.tools[normalizeTool(name)];\n      if (!tool) {\n        server.replyError(id, -32601, `Tool not found:  (${normalizeTool(name)})`);\n        return;\n      }\n\n      // Use tool handler, or default handler, or error\n      let handler = tool.handler;\n      if (!handler \u0026\u0026 defaultHandler) {\n        handler = defaultHandler(tool.name);\n      }\n      if (!handler) {\n        server.replyError(id, -32603, `No handler for tool: `);\n        return;\n      }\n\n      const missing = validateRequiredFields(args, tool.inputSchema);\n      if (missing.length) {\n        server.replyError(id, -32602, `Invalid arguments: missing or empty ${missing.map(m =\u003e `''`).join(\", \")}`);\n        return;\n      }\n\n      // Call handler and await the result (supports both sync and async handlers)\n      server.debug(`Calling handler for tool: `);\n      const result = await Promise.resolve(handler(args));\n      server.debug(`Handler returned for tool: `);\n      const content = result \u0026\u0026 result.content ? result.content : [];\n      server.replyResult(id, { content, isError: false });\n    } else if (/^notifications\\//.test(method)) {\n      server.debug(`ignore `);\n    } else {\n      server.replyError(id, -32601, `Method not found: `);\n    }\n  } catch (e) {\n    server.replyError(id, -32603, e instanceof Error ? e.message : String(e));\n  }\n}\n\n/**\n * Process the read buffer and handle messages\n * @param {MCPServer} server - The MCP server instance\n * @param {Function} [defaultHandler] - Default handler for tools without a handler\n * @returns {Promise\u003cvoid\u003e}\n */\nasync function processReadBuffer(server, defaultHandler) {\n  while (true) {\n    try {\n      const message = server.readBuffer.readMessage();\n      if (!message) {\n        break;\n      }\n      server.debug(`recv: ${JSON.stringify(message)}`);\n      await handleMessage(server, message, defaultHandler);\n    } catch (error) {\n      // For parse errors, we can't know the request id, so we shouldn't send a response\n      // according to JSON-RPC spec. Just log the error.\n      server.debug(`Parse error: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n}\n\n/**\n * Start the MCP server on stdio\n * @param {MCPServer} server - The MCP server instance\n * @param {Object} [options] - Start options\n * @param {Function} [options.defaultHandler] - Default handler for tools without a handler\n */\nfunction start(server, options = {}) {\n  const { defaultHandler } = options;\n\n  server.debug(`v${server.serverInfo.version} ready on stdio`);\n  server.debug(`  tools: ${Object.keys(server.tools).join(\", \")}`);\n\n  if (!Object.keys(server.tools).length) {\n    throw new Error(\"No tools registered\");\n  }\n\n  const onData = async chunk =\u003e {\n    server.readBuffer.append(chunk);\n    await processReadBuffer(server, defaultHandler);\n  };\n\n  process.stdin.on(\"data\", onData);\n  process.stdin.on(\"error\", err =\u003e server.debug(`stdin error: `));\n  process.stdin.resume();\n  server.debug(`listening...`);\n}\n\nmodule.exports = {\n  createServer,\n  registerTool,\n  normalizeTool,\n  handleRequest,\n  handleMessage,\n  processReadBuffer,\n  start,\n  loadToolHandlers,\n};\n",
    "safe_inputs_bootstrap.cjs": "// @ts-check\n\n/**\n * Safe Inputs Bootstrap Module\n *\n * This module provides shared bootstrap logic for safe-inputs MCP servers.\n * It handles configuration loading, tool handler loading, and cleanup that is\n * common between stdio and HTTP transport implementations.\n *\n * Usage:\n *   const { bootstrapSafeInputsServer } = require(\"./safe_inputs_bootstrap.cjs\");\n *   const { config, basePath, tools } = bootstrapSafeInputsServer(configPath, logger);\n */\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst { loadConfig } = require(\"./safe_inputs_config_loader.cjs\");\nconst { loadToolHandlers } = require(\"./mcp_server_core.cjs\");\n\n/**\n * @typedef {Object} Logger\n * @property {Function} debug - Debug logging function\n * @property {Function} debugError - Error logging function\n */\n\n/**\n * @typedef {Object} BootstrapResult\n * @property {Object} config - Loaded configuration\n * @property {string} basePath - Base path for resolving handler files\n * @property {Array} tools - Loaded tool handlers\n */\n\n/**\n * Bootstrap a safe-inputs server by loading configuration and tool handlers.\n * This function performs the common initialization steps shared by both stdio\n * and HTTP transport implementations.\n *\n * @param {string} configPath - Path to the configuration JSON file\n * @param {Logger} logger - Logger instance for debug messages\n * @returns {BootstrapResult} Configuration, base path, and loaded tools\n */\nfunction bootstrapSafeInputsServer(configPath, logger) {\n  // Load configuration\n  logger.debug(`Loading safe-inputs configuration from: `);\n  const config = loadConfig(configPath);\n\n  // Determine base path for resolving relative handler paths\n  const basePath = path.dirname(configPath);\n  logger.debug(`Base path for handlers: `);\n  logger.debug(`Tools to load: ${config.tools.length}`);\n\n  // Load tool handlers from file paths\n  const tools = loadToolHandlers(logger, config.tools, basePath);\n\n  return { config, basePath, tools };\n}\n\n/**\n * Delete the configuration file to ensure no secrets remain on disk.\n * This should be called after the server has been configured and started.\n *\n * @param {string} configPath - Path to the configuration file to delete\n * @param {Logger} logger - Logger instance for debug messages\n */\nfunction cleanupConfigFile(configPath, logger) {\n  try {\n    if (fs.existsSync(configPath)) {\n      fs.unlinkSync(configPath);\n      logger.debug(`Deleted configuration file: `);\n    }\n  } catch (error) {\n    logger.debugError(`Warning: Could not delete configuration file: `, error);\n    // Continue anyway - the server is already running\n  }\n}\n\nmodule.exports = {\n  bootstrapSafeInputsServer,\n  cleanupConfigFile,\n};\n",
    "safe_inputs_config_loader.cjs": "// @ts-check\n\n/**\n * Safe Inputs Configuration Loader\n *\n * This module provides utilities for loading and validating safe-inputs\n * configuration from JSON files.\n */\n\nconst fs = require(\"fs\");\n\n/**\n * @typedef {Object} SafeInputsToolConfig\n * @property {string} name - Tool name\n * @property {string} description - Tool description\n * @property {Object} inputSchema - JSON Schema for tool inputs\n * @property {string} [handler] - Path to handler file (.cjs, .sh, or .py)\n * @property {number} [timeout] - Timeout in seconds for tool execution (default: 60)\n */\n\n/**\n * @typedef {Object} SafeInputsConfig\n * @property {string} [serverName] - Server name (defaults to \"safeinputs\")\n * @property {string} [version] - Server version (defaults to \"1.0.0\")\n * @property {string} [logDir] - Log directory path\n * @property {SafeInputsToolConfig[]} tools - Array of tool configurations\n */\n\n/**\n * Load safe-inputs configuration from a JSON file\n * @param {string} configPath - Path to the configuration JSON file\n * @returns {SafeInputsConfig} The loaded configuration\n * @throws {Error} If the file doesn't exist or configuration is invalid\n */\nfunction loadConfig(configPath) {\n  if (!fs.existsSync(configPath)) {\n    throw new Error(`Configuration file not found: `);\n  }\n\n  const configContent = fs.readFileSync(configPath, \"utf-8\");\n  const config = JSON.parse(configContent);\n\n  // Validate required fields\n  if (!config.tools || !Array.isArray(config.tools)) {\n    throw new Error(\"Configuration must contain a 'tools' array\");\n  }\n\n  return config;\n}\n\nmodule.exports = {\n  loadConfig,\n};\n",
    "safe_inputs_mcp_server.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Safe Inputs MCP Server Module\n *\n * This module provides a reusable MCP server for safe-inputs configuration.\n * It uses the mcp_server_core module for JSON-RPC handling and tool registration.\n *\n * The server reads tool configuration from a JSON file and loads handlers from\n * JavaScript (.cjs), shell script (.sh), or Python script (.py) files.\n *\n * Usage:\n *   node safe_inputs_mcp_server.cjs /path/to/tools.json\n *\n * Or as a module:\n *   const { startSafeInputsServer } = require(\"./safe_inputs_mcp_server.cjs\");\n *   startSafeInputsServer(\"/path/to/tools.json\");\n */\n\nconst { createServer, registerTool, start } = require(\"./mcp_server_core.cjs\");\nconst { loadConfig } = require(\"./safe_inputs_config_loader.cjs\");\nconst { createToolConfig } = require(\"./safe_inputs_tool_factory.cjs\");\nconst { bootstrapSafeInputsServer, cleanupConfigFile } = require(\"./safe_inputs_bootstrap.cjs\");\n\n/**\n * @typedef {Object} SafeInputsToolConfig\n * @property {string} name - Tool name\n * @property {string} description - Tool description\n * @property {Object} inputSchema - JSON Schema for tool inputs\n * @property {string} [handler] - Path to handler file (.cjs, .sh, or .py)\n */\n\n/**\n * @typedef {Object} SafeInputsConfig\n * @property {string} [serverName] - Server name (defaults to \"safeinputs\")\n * @property {string} [version] - Server version (defaults to \"1.0.0\")\n * @property {string} [logDir] - Log directory path\n * @property {SafeInputsToolConfig[]} tools - Array of tool configurations\n */\n\n/**\n * Start the safe-inputs MCP server with the given configuration\n * @param {string} configPath - Path to the configuration JSON file\n * @param {Object} [options] - Additional options\n * @param {string} [options.logDir] - Override log directory from config\n * @param {boolean} [options.skipCleanup] - Skip deletion of config file (useful for stdio mode with agent restarts)\n */\nfunction startSafeInputsServer(configPath, options = {}) {\n  // Create server first to have logger available\n  const logDir = options.logDir || undefined;\n  const server = createServer({ name: \"safeinputs\", version: \"1.0.0\" }, { logDir });\n\n  // Bootstrap: load configuration and tools using shared logic\n  const { config, tools } = bootstrapSafeInputsServer(configPath, server);\n\n  // Update server info with actual config values\n  server.serverInfo.name = config.serverName || \"safeinputs\";\n  server.serverInfo.version = config.version || \"1.0.0\";\n\n  // Use logDir from config if not overridden by options\n  if (!options.logDir \u0026\u0026 config.logDir) {\n    server.logDir = config.logDir;\n  }\n\n  // Register all tools with the server\n  for (const tool of tools) {\n    registerTool(server, tool);\n  }\n\n  // Cleanup: delete the configuration file after loading (unless skipCleanup is true)\n  if (!options.skipCleanup) {\n    cleanupConfigFile(configPath, server);\n  }\n\n  // Start the server\n  start(server);\n}\n\n// If run directly, start the server with command-line arguments\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length \u003c 1) {\n    console.error(\"Usage: node safe_inputs_mcp_server.cjs \u003cconfig.json\u003e [--log-dir \u003cpath\u003e]\");\n    process.exit(1);\n  }\n\n  const configPath = args[0];\n  const options = {};\n\n  // Parse optional arguments\n  for (let i = 1; i \u003c args.length; i++) {\n    if (args[i] === \"--log-dir\" \u0026\u0026 args[i + 1]) {\n      options.logDir = args[i + 1];\n      i++;\n    }\n  }\n\n  try {\n    startSafeInputsServer(configPath, options);\n  } catch (error) {\n    console.error(`Error starting safe-inputs server: ${error instanceof Error ? error.message : String(error)}`);\n    process.exit(1);\n  }\n}\n\nmodule.exports = {\n  startSafeInputsServer,\n  // Re-export helpers for convenience\n  loadConfig,\n  createToolConfig,\n};\n",
    "safe_inputs_tool_factory.cjs": "// @ts-check\n\n/**\n * Safe Inputs Tool Factory\n *\n * This module provides a factory function for creating tool configuration objects\n * for different handler types (JavaScript, Shell, Python).\n */\n\n/**\n * @typedef {Object} SafeInputsToolConfig\n * @property {string} name - Tool name\n * @property {string} description - Tool description\n * @property {Object} inputSchema - JSON Schema for tool inputs\n * @property {string} handler - Path to handler file (.cjs, .sh, or .py)\n */\n\n/**\n * Create a tool configuration object\n * @param {string} name - Tool name\n * @param {string} description - Tool description\n * @param {Object} inputSchema - JSON Schema for tool inputs\n * @param {string} handlerPath - Path to the handler file (.cjs, .sh, or .py)\n * @returns {SafeInputsToolConfig} Tool configuration object\n */\nfunction createToolConfig(name, description, inputSchema, handlerPath) {\n  return {\n    name,\n    description,\n    inputSchema,\n    handler: handlerPath,\n  };\n}\n\nmodule.exports = {\n  createToolConfig,\n};\n",
    "safe_inputs_validation.cjs": "// @ts-check\n\n/**\n * Safe Inputs Validation Helpers\n *\n * This module provides validation utilities for safe-inputs MCP server.\n */\n\n/**\n * Validate required fields in tool arguments\n * @param {Object} args - The arguments object to validate\n * @param {Object} inputSchema - The input schema containing required fields\n * @returns {string[]} Array of missing field names (empty if all required fields are present)\n */\nfunction validateRequiredFields(args, inputSchema) {\n  const requiredFields = inputSchema \u0026\u0026 Array.isArray(inputSchema.required) ? inputSchema.required : [];\n\n  if (!requiredFields.length) {\n    return [];\n  }\n\n  const missing = requiredFields.filter(f =\u003e {\n    const value = args[f];\n    return value === undefined || value === null || (typeof value === \"string\" \u0026\u0026 value.trim() === \"\");\n  });\n\n  return missing;\n}\n\nmodule.exports = {\n  validateRequiredFields,\n};\n"
  };

async function run() {
  try {
    const destination = core.getInput('destination') || '/tmp/gh-aw/safe-inputs';
    
    core.info(`Copying safe-inputs files to ${destination}`);
    
    // Create destination directory if it doesn't exist
    if (!fs.existsSync(destination)) {
      fs.mkdirSync(destination, { recursive: true });
      core.info(`Created directory: ${destination}`);
    }
    
    let fileCount = 0;
    
    // Copy each embedded file
    for (const [filename, content] of Object.entries(FILES)) {
      const filePath = path.join(destination, filename);
      fs.writeFileSync(filePath, content, 'utf8');
      core.info(`Copied: ${filename}`);
      fileCount++;
    }
    
    core.setOutput('files-copied', fileCount.toString());
    core.info(`âœ“ Successfully copied ${fileCount} files`);
    
  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

run();
