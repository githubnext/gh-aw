// Embedded files for bundling
const FILES = {
    "expiration_helpers.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Add expiration XML comment to body lines if expires is set\n * @param {string[]} bodyLines - Array of body lines to append to\n * @param {string} envVarName - Name of the environment variable containing expires days (e.g., \"GH_AW_DISCUSSION_EXPIRES\")\n * @param {string} entityType - Type of entity for logging (e.g., \"Discussion\", \"Issue\", \"Pull Request\")\n * @returns {void}\n */\nfunction addExpirationComment(bodyLines, envVarName, entityType) {\n  const expiresEnv = process.env[envVarName];\n  if (expiresEnv) {\n    const expiresDays = parseInt(expiresEnv, 10);\n    if (!isNaN(expiresDays) \u0026\u0026 expiresDays \u003e 0) {\n      const expirationDate = new Date();\n      expirationDate.setDate(expirationDate.getDate() + expiresDays);\n      const expirationISO = expirationDate.toISOString();\n      bodyLines.push(`\u003c!-- gh-aw-expires:  --\u003e`);\n      core.info(` will expire on  ( days)`);\n    }\n  }\n}\n\nmodule.exports = {\n  addExpirationComment,\n};\n",
    "generate_footer.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Generates an XML comment marker with agentic workflow metadata for traceability.\n * This marker enables searching and tracing back items generated by an agentic workflow.\n *\n * Note: This function is duplicated in messages_footer.cjs. While normally we would\n * consolidate to a shared module, importing messages_footer.cjs here would cause the\n * bundler to inline messages_core.cjs which contains 'GH_AW_SAFE_OUTPUT_MESSAGES:' in\n * a warning message, breaking tests that check for env var declarations.\n *\n * @param {string} workflowName - Name of the workflow\n * @param {string} runUrl - URL of the workflow run\n * @returns {string} XML comment marker with workflow metadata\n */\nfunction generateXMLMarker(workflowName, runUrl) {\n  // Read engine metadata from environment variables\n  const engineId = process.env.GH_AW_ENGINE_ID || \"\";\n  const engineVersion = process.env.GH_AW_ENGINE_VERSION || \"\";\n  const engineModel = process.env.GH_AW_ENGINE_MODEL || \"\";\n  const trackerId = process.env.GH_AW_TRACKER_ID || \"\";\n\n  // Build the key-value pairs for the marker\n  const parts = [];\n\n  // Always include agentic-workflow name\n  parts.push(`agentic-workflow: `);\n\n  // Add tracker-id if available (for searchability and tracing)\n  if (trackerId) {\n    parts.push(`tracker-id: `);\n  }\n\n  // Add engine ID if available\n  if (engineId) {\n    parts.push(`engine: `);\n  }\n\n  // Add version if available\n  if (engineVersion) {\n    parts.push(`version: `);\n  }\n\n  // Add model if available\n  if (engineModel) {\n    parts.push(`model: `);\n  }\n\n  // Always include run URL\n  parts.push(`run: `);\n\n  // Return the XML comment marker\n  return `\u003c!-- ${parts.join(\", \")} --\u003e`;\n}\n\n/**\n * Generate footer with AI attribution and workflow installation instructions\n * @param {string} workflowName - Name of the workflow\n * @param {string} runUrl - URL of the workflow run\n * @param {string} workflowSource - Source of the workflow (owner/repo/path@ref)\n * @param {string} workflowSourceURL - GitHub URL for the workflow source\n * @param {number|undefined} triggeringIssueNumber - Issue number that triggered this workflow\n * @param {number|undefined} triggeringPRNumber - Pull request number that triggered this workflow\n * @param {number|undefined} triggeringDiscussionNumber - Discussion number that triggered this workflow\n * @returns {string} Footer text\n */\nfunction generateFooter(\n  workflowName,\n  runUrl,\n  workflowSource,\n  workflowSourceURL,\n  triggeringIssueNumber,\n  triggeringPRNumber,\n  triggeringDiscussionNumber\n) {\n  let footer = `\\n\\n\u003e AI generated by []()`;\n\n  // Add reference to triggering issue/PR/discussion if available\n  if (triggeringIssueNumber) {\n    footer += ` for #`;\n  } else if (triggeringPRNumber) {\n    footer += ` for #`;\n  } else if (triggeringDiscussionNumber) {\n    footer += ` for discussion #`;\n  }\n\n  if (workflowSource \u0026\u0026 workflowSourceURL) {\n    footer += `\\n\u003e\\n\u003e To add this workflow in your repository, run \\`gh aw add \\`. See [usage guide](https://githubnext.github.io/gh-aw/tools/cli/).`;\n  }\n\n  // Add XML comment marker for traceability\n  footer += \"\\n\\n\" + generateXMLMarker(workflowName, runUrl);\n\n  footer += \"\\n\";\n  return footer;\n}\n\nmodule.exports = {\n  generateFooter,\n  generateXMLMarker,\n};\n",
    "get_tracker_id.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Get tracker-id from environment variable, log it, and optionally format it\n * @param {string} [format] - Output format: \"markdown\" for HTML comment, \"text\" for plain text, or undefined for raw value\n * @returns {string} Tracker ID in requested format or empty string\n */\nfunction getTrackerID(format) {\n  const trackerID = process.env.GH_AW_TRACKER_ID || \"\";\n  if (trackerID) {\n    core.info(`Tracker ID: `);\n    return format === \"markdown\" ? `\\n\\n\u003c!-- tracker-id:  --\u003e` : trackerID;\n  }\n  return \"\";\n}\n\nmodule.exports = {\n  getTrackerID,\n};\n",
    "load_agent_output.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\nconst fs = require(\"fs\");\n\n/**\n * Maximum content length to log for debugging purposes\n * @type {number}\n */\nconst MAX_LOG_CONTENT_LENGTH = 10000;\n\n/**\n * Truncate content for logging if it exceeds the maximum length\n * @param {string} content - Content to potentially truncate\n * @returns {string} Truncated content with indicator if truncated\n */\nfunction truncateForLogging(content) {\n  if (content.length \u003c= MAX_LOG_CONTENT_LENGTH) {\n    return content;\n  }\n  return content.substring(0, MAX_LOG_CONTENT_LENGTH) + `\\n... (truncated, total length: ${content.length})`;\n}\n\n/**\n * Load and parse agent output from the GH_AW_AGENT_OUTPUT file\n *\n * This utility handles the common pattern of:\n * 1. Reading the GH_AW_AGENT_OUTPUT environment variable\n * 2. Loading the file content\n * 3. Validating the JSON structure\n * 4. Returning parsed items array\n *\n * @returns {{\n *   success: true,\n *   items: any[]\n * } | {\n *   success: false,\n *   items?: undefined,\n *   error?: string\n * }} Result object with success flag and items array (if successful) or error message\n */\nfunction loadAgentOutput() {\n  const agentOutputFile = process.env.GH_AW_AGENT_OUTPUT;\n\n  // No agent output file specified\n  if (!agentOutputFile) {\n    core.info(\"No GH_AW_AGENT_OUTPUT environment variable found\");\n    return { success: false };\n  }\n\n  // Read agent output from file\n  let outputContent;\n  try {\n    outputContent = fs.readFileSync(agentOutputFile, \"utf8\");\n  } catch (error) {\n    const errorMessage = `Error reading agent output file: ${error instanceof Error ? error.message : String(error)}`;\n    core.error(errorMessage);\n    return { success: false, error: errorMessage };\n  }\n\n  // Check for empty content\n  if (outputContent.trim() === \"\") {\n    core.info(\"Agent output content is empty\");\n    return { success: false };\n  }\n\n  core.info(`Agent output content length: ${outputContent.length}`);\n\n  // Parse the validated output JSON\n  let validatedOutput;\n  try {\n    validatedOutput = JSON.parse(outputContent);\n  } catch (error) {\n    const errorMessage = `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`;\n    core.error(errorMessage);\n    core.info(`Failed to parse content:\\n${truncateForLogging(outputContent)}`);\n    return { success: false, error: errorMessage };\n  }\n\n  // Validate items array exists\n  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {\n    core.info(\"No valid items found in agent output\");\n    core.info(`Parsed content: ${truncateForLogging(JSON.stringify(validatedOutput))}`);\n    return { success: false };\n  }\n\n  return { success: true, items: validatedOutput.items };\n}\n\nmodule.exports = { loadAgentOutput, truncateForLogging, MAX_LOG_CONTENT_LENGTH };\n",
    "repo_helpers.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Repository-related helper functions for safe-output scripts\n * Provides common repository parsing, validation, and resolution logic\n */\n\n/**\n * Parse the allowed repos from environment variable\n * @returns {Set\u003cstring\u003e} Set of allowed repository slugs\n */\nfunction parseAllowedRepos() {\n  const allowedReposEnv = process.env.GH_AW_ALLOWED_REPOS;\n  const set = new Set();\n  if (allowedReposEnv) {\n    allowedReposEnv\n      .split(\",\")\n      .map(repo =\u003e repo.trim())\n      .filter(repo =\u003e repo)\n      .forEach(repo =\u003e set.add(repo));\n  }\n  return set;\n}\n\n/**\n * Get the default target repository\n * @returns {string} Repository slug in \"owner/repo\" format\n */\nfunction getDefaultTargetRepo() {\n  // First check if there's a target-repo override\n  const targetRepoSlug = process.env.GH_AW_TARGET_REPO_SLUG;\n  if (targetRepoSlug) {\n    return targetRepoSlug;\n  }\n  // Fall back to context repo\n  return `${context.repo.owner}/${context.repo.repo}`;\n}\n\n/**\n * Validate that a repo is allowed for operations\n * @param {string} repo - Repository slug to validate\n * @param {string} defaultRepo - Default target repository\n * @param {Set\u003cstring\u003e} allowedRepos - Set of explicitly allowed repos\n * @returns {{valid: boolean, error: string|null}}\n */\nfunction validateRepo(repo, defaultRepo, allowedRepos) {\n  // Default repo is always allowed\n  if (repo === defaultRepo) {\n    return { valid: true, error: null };\n  }\n  // Check if it's in the allowed repos list\n  if (allowedRepos.has(repo)) {\n    return { valid: true, error: null };\n  }\n  return {\n    valid: false,\n    error: `Repository '' is not in the allowed-repos list. Allowed: ${allowedRepos.size \u003e 0 ? \", \" + Array.from(allowedRepos).join(\", \") : \"\"}`,\n  };\n}\n\n/**\n * Parse owner and repo from a repository slug\n * @param {string} repoSlug - Repository slug in \"owner/repo\" format\n * @returns {{owner: string, repo: string}|null}\n */\nfunction parseRepoSlug(repoSlug) {\n  const parts = repoSlug.split(\"/\");\n  if (parts.length !== 2 || !parts[0] || !parts[1]) {\n    return null;\n  }\n  return { owner: parts[0], repo: parts[1] };\n}\n\nmodule.exports = {\n  parseAllowedRepos,\n  getDefaultTargetRepo,\n  validateRepo,\n  parseRepoSlug,\n};\n",
    "sanitize_label_content.cjs": "// @ts-check\n/**\n * Sanitize label content for GitHub API\n * Removes control characters, ANSI codes, and neutralizes @mentions\n * @module sanitize_label_content\n */\n\n/**\n * Sanitizes label content by removing control characters, ANSI escape codes,\n * and neutralizing @mentions to prevent unintended notifications.\n *\n * @param {string} content - The label content to sanitize\n * @returns {string} The sanitized label content\n */\nfunction sanitizeLabelContent(content) {\n  if (!content || typeof content !== \"string\") {\n    return \"\";\n  }\n  let sanitized = content.trim();\n  // Remove ANSI escape sequences FIRST (before removing control chars)\n  sanitized = sanitized.replace(/\\x1b\\[[0-9;]*[mGKH]/g, \"\");\n  // Then remove control characters (except newlines and tabs)\n  sanitized = sanitized.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, \"\");\n  sanitized = sanitized.replace(\n    /(^|[^\\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\\/[A-Za-z0-9._-]+)?)/g,\n    (_m, p1, p2) =\u003e `\\`@\\``\n  );\n  sanitized = sanitized.replace(/[\u003c\u003e\u0026'\"]/g, \"\");\n  return sanitized.trim();\n}\n\nmodule.exports = { sanitizeLabelContent };\n",
    "staged_preview.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\n/**\n * Generate a staged mode preview summary and write it to the step summary.\n *\n * @param {Object} options - Configuration options for the preview\n * @param {string} options.title - The main title for the preview (e.g., \"Create Issues\")\n * @param {string} options.description - Description of what would happen if staged mode was disabled\n * @param {Array\u003cany\u003e} options.items - Array of items to preview\n * @param {(item: any, index: number) =\u003e string} options.renderItem - Function to render each item as markdown\n * @returns {Promise\u003cvoid\u003e}\n */\nasync function generateStagedPreview(options) {\n  const { title, description, items, renderItem } = options;\n\n  let summaryContent = `## üé≠ Staged Mode:  Preview\\n\\n`;\n  summaryContent += `\\n\\n`;\n\n  for (let i = 0; i \u003c items.length; i++) {\n    const item = items[i];\n    summaryContent += renderItem(item, i);\n    summaryContent += \"---\\n\\n\";\n  }\n\n  try {\n    await core.summary.addRaw(summaryContent).write();\n    core.info(summaryContent);\n    core.info(`üìù  preview written to step summary`);\n  } catch (error) {\n    core.setFailed(error instanceof Error ? error : String(error));\n  }\n}\n\nmodule.exports = { generateStagedPreview };\n",
    "temporary_id.cjs": "// @ts-check\n/// \u003creference types=\"@actions/github-script\" /\u003e\n\nconst crypto = require(\"crypto\");\n\n/**\n * Regex pattern for matching temporary ID references in text\n * Format: #aw_XXXXXXXXXXXX (aw_ prefix + 12 hex characters)\n */\nconst TEMPORARY_ID_PATTERN = /#(aw_[0-9a-f]{12})/gi;\n\n/**\n * @typedef {Object} RepoIssuePair\n * @property {string} repo - Repository slug in \"owner/repo\" format\n * @property {number} number - Issue or discussion number\n */\n\n/**\n * Generate a temporary ID with aw_ prefix for temporary issue IDs\n * @returns {string} A temporary ID in format aw_XXXXXXXXXXXX (12 hex characters)\n */\nfunction generateTemporaryId() {\n  return \"aw_\" + crypto.randomBytes(6).toString(\"hex\");\n}\n\n/**\n * Check if a value is a valid temporary ID (aw_ prefix + 12-character hex string)\n * @param {any} value - The value to check\n * @returns {boolean} True if the value is a valid temporary ID\n */\nfunction isTemporaryId(value) {\n  if (typeof value === \"string\") {\n    return /^aw_[0-9a-f]{12}$/i.test(value);\n  }\n  return false;\n}\n\n/**\n * Normalize a temporary ID to lowercase for consistent map lookups\n * @param {string} tempId - The temporary ID to normalize\n * @returns {string} Lowercase temporary ID\n */\nfunction normalizeTemporaryId(tempId) {\n  return String(tempId).toLowerCase();\n}\n\n/**\n * Replace temporary ID references in text with actual issue numbers\n * Format: #aw_XXXXXXXXXXXX -\u003e #123 (same repo) or owner/repo#123 (cross-repo)\n * @param {string} text - The text to process\n * @param {Map\u003cstring, RepoIssuePair\u003e} tempIdMap - Map of temporary_id to {repo, number}\n * @param {string} [currentRepo] - Current repository slug for same-repo references\n * @returns {string} Text with temporary IDs replaced with issue numbers\n */\nfunction replaceTemporaryIdReferences(text, tempIdMap, currentRepo) {\n  return text.replace(TEMPORARY_ID_PATTERN, (match, tempId) =\u003e {\n    const resolved = tempIdMap.get(normalizeTemporaryId(tempId));\n    if (resolved !== undefined) {\n      // If we have a currentRepo and the issue is in the same repo, use short format\n      if (currentRepo \u0026\u0026 resolved.repo === currentRepo) {\n        return `#${resolved.number}`;\n      }\n      // Otherwise use full repo#number format for cross-repo references\n      return `${resolved.repo}#${resolved.number}`;\n    }\n    // Return original if not found (it may be created later)\n    return match;\n  });\n}\n\n/**\n * Replace temporary ID references in text with actual issue numbers (legacy format)\n * This is a compatibility function that works with Map\u003cstring, number\u003e\n * Format: #aw_XXXXXXXXXXXX -\u003e #123\n * @param {string} text - The text to process\n * @param {Map\u003cstring, number\u003e} tempIdMap - Map of temporary_id to issue number\n * @returns {string} Text with temporary IDs replaced with issue numbers\n */\nfunction replaceTemporaryIdReferencesLegacy(text, tempIdMap) {\n  return text.replace(TEMPORARY_ID_PATTERN, (match, tempId) =\u003e {\n    const issueNumber = tempIdMap.get(normalizeTemporaryId(tempId));\n    if (issueNumber !== undefined) {\n      return `#`;\n    }\n    // Return original if not found (it may be created later)\n    return match;\n  });\n}\n\n/**\n * Load the temporary ID map from environment variable\n * Supports both old format (temporary_id -\u003e number) and new format (temporary_id -\u003e {repo, number})\n * @returns {Map\u003cstring, RepoIssuePair\u003e} Map of temporary_id to {repo, number}\n */\nfunction loadTemporaryIdMap() {\n  const mapJson = process.env.GH_AW_TEMPORARY_ID_MAP;\n  if (!mapJson || mapJson === \"{}\") {\n    return new Map();\n  }\n  try {\n    const mapObject = JSON.parse(mapJson);\n    /** @type {Map\u003cstring, RepoIssuePair\u003e} */\n    const result = new Map();\n\n    for (const [key, value] of Object.entries(mapObject)) {\n      const normalizedKey = normalizeTemporaryId(key);\n      if (typeof value === \"number\") {\n        // Legacy format: number only, use context repo\n        const contextRepo = `${context.repo.owner}/${context.repo.repo}`;\n        result.set(normalizedKey, { repo: contextRepo, number: value });\n      } else if (typeof value === \"object\" \u0026\u0026 value !== null \u0026\u0026 \"repo\" in value \u0026\u0026 \"number\" in value) {\n        // New format: {repo, number}\n        result.set(normalizedKey, { repo: String(value.repo), number: Number(value.number) });\n      }\n    }\n    return result;\n  } catch (error) {\n    if (typeof core !== \"undefined\") {\n      core.warning(`Failed to parse temporary ID map: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    return new Map();\n  }\n}\n\n/**\n * Resolve an issue number that may be a temporary ID or an actual issue number\n * Returns structured result with the resolved number, repo, and metadata\n * @param {any} value - The value to resolve (can be temporary ID, number, or string)\n * @param {Map\u003cstring, RepoIssuePair\u003e} temporaryIdMap - Map of temporary ID to {repo, number}\n * @returns {{resolved: RepoIssuePair|null, wasTemporaryId: boolean, errorMessage: string|null}}\n */\nfunction resolveIssueNumber(value, temporaryIdMap) {\n  if (value === undefined || value === null) {\n    return { resolved: null, wasTemporaryId: false, errorMessage: \"Issue number is missing\" };\n  }\n\n  // Check if it's a temporary ID\n  const valueStr = String(value);\n  if (isTemporaryId(valueStr)) {\n    const resolvedPair = temporaryIdMap.get(normalizeTemporaryId(valueStr));\n    if (resolvedPair !== undefined) {\n      return { resolved: resolvedPair, wasTemporaryId: true, errorMessage: null };\n    }\n    return {\n      resolved: null,\n      wasTemporaryId: true,\n      errorMessage: `Temporary ID '' not found in map. Ensure the issue was created before linking.`,\n    };\n  }\n\n  // It's a real issue number - use context repo as default\n  const issueNumber = typeof value === \"number\" ? value : parseInt(valueStr, 10);\n  if (isNaN(issueNumber) || issueNumber \u003c= 0) {\n    return { resolved: null, wasTemporaryId: false, errorMessage: `Invalid issue number: ` };\n  }\n\n  const contextRepo = typeof context !== \"undefined\" ? `${context.repo.owner}/${context.repo.repo}` : \"\";\n  return { resolved: { repo: contextRepo, number: issueNumber }, wasTemporaryId: false, errorMessage: null };\n}\n\n/**\n * Serialize the temporary ID map to JSON for output\n * @param {Map\u003cstring, RepoIssuePair\u003e} tempIdMap - Map of temporary_id to {repo, number}\n * @returns {string} JSON string of the map\n */\nfunction serializeTemporaryIdMap(tempIdMap) {\n  const obj = Object.fromEntries(tempIdMap);\n  return JSON.stringify(obj);\n}\n\nmodule.exports = {\n  TEMPORARY_ID_PATTERN,\n  generateTemporaryId,\n  isTemporaryId,\n  normalizeTemporaryId,\n  replaceTemporaryIdReferences,\n  replaceTemporaryIdReferencesLegacy,\n  loadTemporaryIdMap,\n  resolveIssueNumber,\n  serializeTemporaryIdMap,\n};\n"
  };

// Helper to load embedded files
function requireFile(filename) {
  const content = FILES[filename];
  if (!content) {
    throw new Error(`File not found: ${filename}`);
  }
  const exports = {};
  const module = { exports };
  const func = new Function('exports', 'module', 'require', content);
  func(exports, module, requireFile);
  return module.exports;
}

// @ts-check
/// <reference types="@actions/github-script" />

const { sanitizeLabelContent } = requireFile('sanitize_label_content.cjs');
const { loadAgentOutput } = requireFile('load_agent_output.cjs');
const { generateStagedPreview } = requireFile('staged_preview.cjs');
const { generateFooter } = requireFile('generate_footer.cjs');
const { getTrackerID } = requireFile('get_tracker_id.cjs');
const {
  generateTemporaryId,
  isTemporaryId,
  normalizeTemporaryId,
  replaceTemporaryIdReferences,
  serializeTemporaryIdMap,
} = requireFile('temporary_id.cjs');
const { parseAllowedRepos, getDefaultTargetRepo, validateRepo, parseRepoSlug } = requireFile('repo_helpers.cjs');
const { addExpirationComment } = requireFile('expiration_helpers.cjs');

async function main() {
  // Initialize outputs to empty strings to ensure they're always set
  core.setOutput("issue_number", "");
  core.setOutput("issue_url", "");
  core.setOutput("temporary_id_map", "{}");
  core.setOutput("issues_to_assign_copilot", "");

  const isStaged = process.env.GH_AW_SAFE_OUTPUTS_STAGED === "true";

  const result = loadAgentOutput();
  if (!result.success) {
    return;
  }

  const createIssueItems = result.items.filter(item => item.type === "create_issue");
  if (createIssueItems.length === 0) {
    core.info("No create-issue items found in agent output");
    return;
  }
  core.info(`Found ${createIssueItems.length} create-issue item(s)`);

  // Parse allowed repos and default target
  const allowedRepos = parseAllowedRepos();
  const defaultTargetRepo = getDefaultTargetRepo();
  core.info(`Default target repo: ${defaultTargetRepo}`);
  if (allowedRepos.size > 0) {
    core.info(`Allowed repos: ${Array.from(allowedRepos).join(", ")}`);
  }

  if (isStaged) {
    await generateStagedPreview({
      title: "Create Issues",
      description: "The following issues would be created if staged mode was disabled:",
      items: createIssueItems,
      renderItem: (item, index) => {
        let content = `### Issue ${index + 1}\n`;
        content += `**Title:** ${item.title || "No title provided"}\n\n`;
        if (item.temporary_id) {
          content += `**Temporary ID:** ${item.temporary_id}\n\n`;
        }
        if (item.repo) {
          content += `**Repository:** ${item.repo}\n\n`;
        }
        if (item.body) {
          content += `**Body:**\n${item.body}\n\n`;
        }
        if (item.labels && item.labels.length > 0) {
          content += `**Labels:** ${item.labels.join(", ")}\n\n`;
        }
        if (item.parent) {
          content += `**Parent:** ${item.parent}\n\n`;
        }
        return content;
      },
    });
    return;
  }
  const parentIssueNumber = context.payload?.issue?.number;

  // Map to track temporary_id -> {repo, number} relationships
  /** @type {Map<string, {repo: string, number: number}>} */
  const temporaryIdMap = new Map();

  // Extract triggering context for footer generation
  const triggeringIssueNumber =
    context.payload?.issue?.number && !context.payload?.issue?.pull_request ? context.payload.issue.number : undefined;
  const triggeringPRNumber =
    context.payload?.pull_request?.number || (context.payload?.issue?.pull_request ? context.payload.issue.number : undefined);
  const triggeringDiscussionNumber = context.payload?.discussion?.number;

  const labelsEnv = process.env.GH_AW_ISSUE_LABELS;
  let envLabels = labelsEnv
    ? labelsEnv
        .split(",")
        .map(label => label.trim())
        .filter(label => label)
    : [];
  const createdIssues = [];
  for (let i = 0; i < createIssueItems.length; i++) {
    const createIssueItem = createIssueItems[i];

    // Determine target repository for this issue
    const itemRepo = createIssueItem.repo ? String(createIssueItem.repo).trim() : defaultTargetRepo;

    // Validate the repository is allowed
    const repoValidation = validateRepo(itemRepo, defaultTargetRepo, allowedRepos);
    if (!repoValidation.valid) {
      core.warning(`Skipping issue: ${repoValidation.error}`);
      continue;
    }

    // Parse the repository slug
    const repoParts = parseRepoSlug(itemRepo);
    if (!repoParts) {
      core.warning(`Skipping issue: Invalid repository format '${itemRepo}'. Expected 'owner/repo'.`);
      continue;
    }

    // Get or generate the temporary ID for this issue
    const temporaryId = createIssueItem.temporary_id || generateTemporaryId();
    core.info(
      `Processing create-issue item ${i + 1}/${createIssueItems.length}: title=${createIssueItem.title}, bodyLength=${createIssueItem.body.length}, temporaryId=${temporaryId}, repo=${itemRepo}`
    );

    // Debug logging for parent field
    core.info(`Debug: createIssueItem.parent = ${JSON.stringify(createIssueItem.parent)}`);
    core.info(`Debug: parentIssueNumber from context = ${JSON.stringify(parentIssueNumber)}`);

    // Resolve parent: check if it's a temporary ID reference
    let effectiveParentIssueNumber;
    let effectiveParentRepo = itemRepo; // Default to same repo
    if (createIssueItem.parent !== undefined) {
      if (isTemporaryId(createIssueItem.parent)) {
        // It's a temporary ID, look it up in the map
        const resolvedParent = temporaryIdMap.get(normalizeTemporaryId(createIssueItem.parent));
        if (resolvedParent !== undefined) {
          effectiveParentIssueNumber = resolvedParent.number;
          effectiveParentRepo = resolvedParent.repo;
          core.info(`Resolved parent temporary ID '${createIssueItem.parent}' to ${effectiveParentRepo}#${effectiveParentIssueNumber}`);
        } else {
          core.warning(
            `Parent temporary ID '${createIssueItem.parent}' not found in map. Ensure parent issue is created before sub-issues.`
          );
          effectiveParentIssueNumber = undefined;
        }
      } else {
        // It's a real issue number
        effectiveParentIssueNumber = parseInt(String(createIssueItem.parent), 10);
        if (isNaN(effectiveParentIssueNumber)) {
          core.warning(`Invalid parent value: ${createIssueItem.parent}`);
          effectiveParentIssueNumber = undefined;
        }
      }
    } else {
      // Only use context parent if we're in the same repo as context
      const contextRepo = `${context.repo.owner}/${context.repo.repo}`;
      if (itemRepo === contextRepo) {
        effectiveParentIssueNumber = parentIssueNumber;
      }
    }
    core.info(
      `Debug: effectiveParentIssueNumber = ${JSON.stringify(effectiveParentIssueNumber)}, effectiveParentRepo = ${effectiveParentRepo}`
    );

    if (effectiveParentIssueNumber && createIssueItem.parent !== undefined) {
      core.info(`Using explicit parent issue number from item: ${effectiveParentRepo}#${effectiveParentIssueNumber}`);
    }
    let labels = [...envLabels];
    if (createIssueItem.labels && Array.isArray(createIssueItem.labels)) {
      labels = [...labels, ...createIssueItem.labels];
    }
    labels = labels
      .filter(label => !!label)
      .map(label => String(label).trim())
      .filter(label => label)
      .map(label => sanitizeLabelContent(label))
      .filter(label => label)
      .map(label => (label.length > 64 ? label.substring(0, 64) : label))
      .filter((label, index, arr) => arr.indexOf(label) === index);
    let title = createIssueItem.title ? createIssueItem.title.trim() : "";

    // Replace temporary ID references in the body using already-created issues
    let processedBody = replaceTemporaryIdReferences(createIssueItem.body, temporaryIdMap, itemRepo);
    let bodyLines = processedBody.split("\n");

    if (!title) {
      title = createIssueItem.body || "Agent Output";
    }
    const titlePrefix = process.env.GH_AW_ISSUE_TITLE_PREFIX;
    if (titlePrefix && !title.startsWith(titlePrefix)) {
      title = titlePrefix + title;
    }
    if (effectiveParentIssueNumber) {
      core.info("Detected issue context, parent issue " + effectiveParentRepo + "#" + effectiveParentIssueNumber);
      // Use full repo reference if cross-repo, short reference if same repo
      if (effectiveParentRepo === itemRepo) {
        bodyLines.push(`Related to #${effectiveParentIssueNumber}`);
      } else {
        bodyLines.push(`Related to ${effectiveParentRepo}#${effectiveParentIssueNumber}`);
      }
    }
    const workflowName = process.env.GH_AW_WORKFLOW_NAME || "Workflow";
    const workflowSource = process.env.GH_AW_WORKFLOW_SOURCE || "";
    const workflowSourceURL = process.env.GH_AW_WORKFLOW_SOURCE_URL || "";
    const runId = context.runId;
    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
    const runUrl = context.payload.repository
      ? `${context.payload.repository.html_url}/actions/runs/${runId}`
      : `${githubServer}/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;

    // Add tracker-id comment if present
    const trackerIDComment = getTrackerID("markdown");
    if (trackerIDComment) {
      bodyLines.push(trackerIDComment);
    }

    // Add expiration comment if expires is set
    addExpirationComment(bodyLines, "GH_AW_ISSUE_EXPIRES", "Issue");

    bodyLines.push(
      ``,
      ``,
      generateFooter(
        workflowName,
        runUrl,
        workflowSource,
        workflowSourceURL,
        triggeringIssueNumber,
        triggeringPRNumber,
        triggeringDiscussionNumber
      ).trimEnd(),
      ""
    );
    const body = bodyLines.join("\n").trim();
    core.info(`Creating issue in ${itemRepo} with title: ${title}`);
    core.info(`Labels: ${labels}`);
    core.info(`Body length: ${body.length}`);
    try {
      const { data: issue } = await github.rest.issues.create({
        owner: repoParts.owner,
        repo: repoParts.repo,
        title: title,
        body: body,
        labels: labels,
      });
      core.info(`Created issue ${itemRepo}#${issue.number}: ${issue.html_url}`);
      createdIssues.push({ ...issue, _repo: itemRepo });

      // Store the mapping of temporary_id -> {repo, number}
      temporaryIdMap.set(normalizeTemporaryId(temporaryId), { repo: itemRepo, number: issue.number });
      core.info(`Stored temporary ID mapping: ${temporaryId} -> ${itemRepo}#${issue.number}`);

      // Debug logging for sub-issue linking
      core.info(`Debug: About to check if sub-issue linking is needed. effectiveParentIssueNumber = ${effectiveParentIssueNumber}`);

      // Sub-issue linking only works within the same repository
      if (effectiveParentIssueNumber && effectiveParentRepo === itemRepo) {
        core.info(`Attempting to link issue #${issue.number} as sub-issue of #${effectiveParentIssueNumber}`);
        try {
          // First, get the node IDs for both parent and child issues
          core.info(`Fetching node ID for parent issue #${effectiveParentIssueNumber}...`);
          const getIssueNodeIdQuery = `
            query($owner: String!, $repo: String!, $issueNumber: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $issueNumber) {
                  id
                }
              }
            }
          `;

          // Get parent issue node ID
          const parentResult = await github.graphql(getIssueNodeIdQuery, {
            owner: repoParts.owner,
            repo: repoParts.repo,
            issueNumber: effectiveParentIssueNumber,
          });
          const parentNodeId = parentResult.repository.issue.id;
          core.info(`Parent issue node ID: ${parentNodeId}`);

          // Get child issue node ID
          core.info(`Fetching node ID for child issue #${issue.number}...`);
          const childResult = await github.graphql(getIssueNodeIdQuery, {
            owner: repoParts.owner,
            repo: repoParts.repo,
            issueNumber: issue.number,
          });
          const childNodeId = childResult.repository.issue.id;
          core.info(`Child issue node ID: ${childNodeId}`);

          // Link the child issue as a sub-issue of the parent
          core.info(`Executing addSubIssue mutation...`);
          const addSubIssueMutation = `
            mutation($issueId: ID!, $subIssueId: ID!) {
              addSubIssue(input: {
                issueId: $issueId,
                subIssueId: $subIssueId
              }) {
                subIssue {
                  id
                  number
                }
              }
            }
          `;

          await github.graphql(addSubIssueMutation, {
            issueId: parentNodeId,
            subIssueId: childNodeId,
          });

          core.info("‚úì Successfully linked issue #" + issue.number + " as sub-issue of #" + effectiveParentIssueNumber);
        } catch (error) {
          core.info(`Warning: Could not link sub-issue to parent: ${error instanceof Error ? error.message : String(error)}`);
          core.info(`Error details: ${error instanceof Error ? error.stack : String(error)}`);
          // Fallback: add a comment if sub-issue linking fails
          try {
            core.info(`Attempting fallback: adding comment to parent issue #${effectiveParentIssueNumber}...`);
            await github.rest.issues.createComment({
              owner: repoParts.owner,
              repo: repoParts.repo,
              issue_number: effectiveParentIssueNumber,
              body: `Created related issue: #${issue.number}`,
            });
            core.info("‚úì Added comment to parent issue #" + effectiveParentIssueNumber + " (sub-issue linking not available)");
          } catch (commentError) {
            core.info(
              `Warning: Could not add comment to parent issue: ${commentError instanceof Error ? commentError.message : String(commentError)}`
            );
          }
        }
      } else if (effectiveParentIssueNumber && effectiveParentRepo !== itemRepo) {
        core.info(`Skipping sub-issue linking: parent is in different repository (${effectiveParentRepo})`);
      } else {
        core.info(`Debug: No parent issue number set, skipping sub-issue linking`);
      }
      if (i === createIssueItems.length - 1) {
        core.setOutput("issue_number", issue.number);
        core.setOutput("issue_url", issue.html_url);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("Issues has been disabled in this repository")) {
        core.info(`‚ö† Cannot create issue "${title}" in ${itemRepo}: Issues are disabled for this repository`);
        core.info("Consider enabling issues in repository settings if you want to create issues automatically");
        continue;
      }
      core.error(`‚úó Failed to create issue "${title}" in ${itemRepo}: ${errorMessage}`);
      throw error;
    }
  }
  if (createdIssues.length > 0) {
    let summaryContent = "\n\n## GitHub Issues\n";
    for (const issue of createdIssues) {
      const repoLabel = issue._repo !== defaultTargetRepo ? ` (${issue._repo})` : "";
      summaryContent += `- Issue #${issue.number}${repoLabel}: [${issue.title}](${issue.html_url})\n`;
    }
    await core.summary.addRaw(summaryContent).write();
  }

  // Output the temporary ID map as JSON for use by downstream jobs
  const tempIdMapOutput = serializeTemporaryIdMap(temporaryIdMap);
  core.setOutput("temporary_id_map", tempIdMapOutput);
  core.info(`Temporary ID map: ${tempIdMapOutput}`);

  // Output issues that need copilot assignment for assign_to_agent job
  // This is used when create-issue has assignees: [copilot]
  const assignCopilot = process.env.GH_AW_ASSIGN_COPILOT === "true";
  if (assignCopilot && createdIssues.length > 0) {
    // Format: repo:number for each issue (for cross-repo support)
    const issuesToAssign = createdIssues.map(issue => `${issue._repo}:${issue.number}`).join(",");
    core.setOutput("issues_to_assign_copilot", issuesToAssign);
    core.info(`Issues to assign copilot: ${issuesToAssign}`);
  }

  core.info(`Successfully created ${createdIssues.length} issue(s)`);
}
(async () => {
  await main();
})();
