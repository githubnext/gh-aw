---
title: About Campaigns
description: Coordinate agentic workflows toward one goal, tracked in GitHub Projects.
sidebar:
  label: About Campaigns
banner:
  content: '<strong>Do not use.</strong> Campaigns are still incomplete and may produce unreliable or unintended results.'
---

import FeatureCard from '../../../../components/FeatureCard.astro';
import FeatureGrid from '../../../../components/FeatureGrid.astro';

## What are Agentic Campaigns?

**[Agentic campaigns](/gh-aw/reference/glossary/#agentic-campaign)** are a way to bundle agentic workflows around a shared goal.

This can be as lightweight tracking or grow over time to coordinate work across repositories and teams. Campaigns keep agentic work visible and easier to manage as it scales.

## Why use campaigns?

<FeatureGrid columns={2}>
  <FeatureCard icon="goal" title="Strategic Goals" href="/gh-aw/guides/campaigns/specs/#strategic-goals-objective--kpis">
    Define what “done” means with an objective and KPIs (and optional narrative context).
  </FeatureCard>
  <FeatureCard icon="workflow" title="Reuse Worker Workflows" href="/gh-aw/guides/campaigns/specs/#worker-workflows">
    Coordinate existing dispatchable workflows instead of rewriting automation.
  </FeatureCard>
  <FeatureCard icon="project" title="Unified Tracking" href="/gh-aw/guides/campaigns/specs/#unified-tracking-github-project">
    Track work and status updates in one GitHub Project board.
  </FeatureCard>
  <FeatureCard icon="shield" title="Built-in Governance" href="/gh-aw/guides/campaigns/specs/#governance-pacing--safety">
    Cap updates per run, opt out items, and keep changes predictable.
  </FeatureCard>
</FeatureGrid>

## Natural language to Campaign

Creating campaigns without agentic workflows would be tedious and error-prone.
Just like agentic workflows turn natural language into GitHub Actions,
campaigns turn brief natural language goal definitions into coordinated work tracked in GitHub Projects.

```md
Burn down all open code security alerts, prioritizing file-write alerts first
and batching up to 3 related alerts/PR with a brief fix rationale comment.
```

The above text gets automatically converted into the following campaign spec in a pull request
and a pull request is raised by the Copilot Coding Agent where you can now iterate on the details:

```yaml
---
id: security-alert-burndown
version: "v1"
name: "Security Alert Burndown"
description: "Drive the code security alerts backlog to zero"
engine: copilot

project-url: "https://github.com/orgs/ORG/projects/1"
tracker-label: "campaign:security-alert-burndown"

objective: "Reduce open code security alerts to zero without breaking CI."
kpis:
  - id: open_alerts
    name: "Open alerts"
    priority: primary
    direction: "decrease"
    target: 0

workflows:
  - security-alert-fix

governance:
  max-project-updates-per-run: 10
  max-comments-per-run: 10
---
```

The file has already been validated and comppiled to create the campaign's orchestrator workflow (`.campaign.lock.yml`) that GitHub Actions can execute.
Think of it like compiling code: you write a human-friendly campaign definition, and the compiler produces a hardened, machine-executable workflow.

## Next steps

- [Getting started](/gh-aw/guides/campaigns/getting-started/) – create your first campaign
- [Campaign specs](/gh-aw/guides/campaigns/specs/) – fields you can configure
- [Flow & Lifecycle](/gh-aw/guides/campaigns/flow/) – what the orchestrator does each run
- [CLI commands](/gh-aw/guides/campaigns/cli-commands/) – inspect and validate campaigns
