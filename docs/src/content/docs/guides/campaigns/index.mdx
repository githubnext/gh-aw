---
title: About Campaigns
description: Coordinate agentic workflows toward one goal, tracked in GitHub Projects.
sidebar:
  label: About Campaigns
banner:
  content: '<strong>Do not use.</strong> Campaigns are still incomplete and may produce unreliable or unintended results.'
---

import FeatureCard from '../../../../components/FeatureCard.astro';
import FeatureGrid from '../../../../components/FeatureGrid.astro';

## What are Agentic Campaigns?

**GitHub agentic campaigns** are AI-powered orchestration workflows that coordinate multiple **[agentic workflows](/gh-aw/reference/glossary/#agentic-workflow)** toward a shared goal across one or more repositories.

Just as [agentic workflows](/gh-aw/introduction/overview/) use natural language instructions to give an AI agent tasks and [safe outputs](/gh-aw/reference/safe-outputs/) to enable controlled GitHub operations, campaigns use **[campaign specs](/gh-aw/guides/campaigns/specs/)** (YAML configuration files that define campaign goals, governance, and worker coordination) to give an **orchestrator agent** (AI agent that manages campaign execution, worker dispatch, and progress tracking) high-level strategic instructions. The orchestrator agent interprets your campaign's objective and KPIs, then autonomously manages worker workflows to achieve the goal.

**Single workflow**: You write natural language instructions → AI agent executes tasks using safe outputs  
**Campaign**: You define goals in a spec → Orchestrator agent coordinates worker workflows toward the objective

Imagine you have a goal that takes more than one workflow run, across one or more repositories. You can write a worker workflow to do the work, but you still need a way to schedule it, fan it out, track what it created, and report progress.

Campaigns provide that orchestration layer: you define the goal and guardrails in a campaign spec, which gets compiled into an orchestrator workflow that runs on a schedule. On each run, the orchestrator can dispatch worker workflows, track the issues and pull requests they create, update a GitHub Project board, and publish a status update with metrics.

Use campaigns when work needs coordination across multiple workflows or repositories, plus tracking, pacing, and governance. If a single workflow is enough (even on a schedule), start with a standalone agentic workflow.

## Why use campaigns?

<FeatureGrid columns={2}>
  <FeatureCard icon="goal" title="Strategic Goals" href="/gh-aw/guides/campaigns/specs/#strategic-goals-objective--kpis">
    Define campaign objectives and key performance indicators (KPIs) with optional narrative context.
  </FeatureCard>
  <FeatureCard icon="workflow" title="Reuse Worker Workflows" href="/gh-aw/guides/campaigns/specs/#worker-workflows">
    Coordinate existing dispatchable workflows instead of rewriting automation.
  </FeatureCard>
  <FeatureCard icon="project" title="Unified Tracking" href="/gh-aw/guides/campaigns/specs/#unified-tracking-github-project">
    Track work and status updates in one GitHub Project board.
  </FeatureCard>
  <FeatureCard icon="shield" title="Built-in Governance" href="/gh-aw/guides/campaigns/specs/#governance-pacing--safety">
    Cap updates per run, opt out items, and keep changes predictable.
  </FeatureCard>
</FeatureGrid>

## Natural language to campaign

Campaigns use agentic workflows to generate configuration from natural language descriptions.

**Example input**: Describe your goal in plain language:

```md
Burn down all open code security alerts, prioritizing file-write alerts first
and batching up to 3 related alerts/PR with a brief fix rationale comment.
```

The campaign generator converts this into a **[campaign spec](/gh-aw/guides/campaigns/specs/)** in a pull request for review. Essential spec components include:

```yaml
---
id: security-alert-burndown
name: "Security Alert Burndown"
description: "Drive the code security alerts backlog to zero"

# GitHub Project for tracking
project-url: "https://github.com/orgs/ORG/projects/1"
tracker-label: "campaign:security-alert-burndown"

# Strategic goals
objective: "Reduce open code security alerts to zero without breaking CI."
kpis:
  - id: open_alerts
    name: "Open alerts"
    priority: primary
    direction: "decrease"
    target: 0

# Worker workflows to dispatch
workflows:
  - security-alert-fix

# Governance and pacing
governance:
  max-project-updates-per-run: 10
  max-comments-per-run: 10
---
```

The spec is validated and compiled into the campaign orchestrator workflow (`.campaign.lock.yml`) that GitHub Actions executes.

Once merged, the orchestrator runs on schedule (daily by default) to [dispatch worker workflows, discover items, update the Project board, and report status](/gh-aw/guides/campaigns/lifecycle/).

## Next steps

- [Getting started](/gh-aw/guides/campaigns/getting-started/) – create your first campaign
- [Campaign specs](/gh-aw/guides/campaigns/specs/) – fields you can configure
- [Campaign Lifecycle](/gh-aw/guides/campaigns/lifecycle/) – what the orchestrator does each run
- [CLI commands](/gh-aw/guides/campaigns/cli-commands/) – inspect and validate campaigns
