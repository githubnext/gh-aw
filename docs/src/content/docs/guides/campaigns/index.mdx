---
title: About Campaigns
description: Coordinate agentic workflows toward one goal, tracked in GitHub Projects.
sidebar:
  label: About Campaigns
banner:
  content: '<strong>Do not use.</strong> Campaigns are still incomplete and may produce unreliable or unintended results.'
---

import FeatureCard from '../../../../components/FeatureCard.astro';
import FeatureGrid from '../../../../components/FeatureGrid.astro';

## What are Agentic Campaigns?

**[Agentic campaigns](/gh-aw/reference/glossary/#agentic-campaign)** are a way to bundle agentic workflows around a shared goal.

This can be as lightweight tracking or grow over time to coordinate work across repositories and teams. Campaigns keep agentic work visible and easier to manage as it scales.

## Why use campaigns?

<FeatureGrid columns={2}>
  <FeatureCard icon="goal" title="Strategic Goals" href="/gh-aw/guides/campaigns/specs/#strategic-goals-objective--kpis">
    Define what “done” means with an objective and KPIs (and optional narrative context).
  </FeatureCard>
  <FeatureCard icon="workflow" title="Reuse Worker Workflows" href="/gh-aw/guides/campaigns/specs/#worker-workflows">
    Coordinate existing dispatchable workflows instead of rewriting automation.
  </FeatureCard>
  <FeatureCard icon="project" title="Unified Tracking" href="/gh-aw/guides/campaigns/specs/#unified-tracking-github-project">
    Track work and status updates in one GitHub Project board.
  </FeatureCard>
  <FeatureCard icon="shield" title="Built-in Governance" href="/gh-aw/guides/campaigns/specs/#governance-pacing--safety">
    Cap updates per run, opt out items, and keep changes predictable.
  </FeatureCard>
</FeatureGrid>

## Natural language to Campaign

Creating campaigns without agentic workflows would be tedious and error-prone.
Just like agentic workflows turn natural language into GitHub Actions,
campaigns turn brief natural language goal definitions into coordinated work tracked in GitHub Projects.

**Example input**: Describe your goal in plain language, such as:

```md
Burn down all open code security alerts, prioritizing file-write alerts first
and batching up to 3 related alerts/PR with a brief fix rationale comment.
```

The Copilot Coding Agent automatically converts this into a **[campaign spec](/gh-aw/guides/campaigns/specs/)** in a pull request where you can review and iterate on the details. Here's what the essential parts look like:

```yaml
---
id: security-alert-burndown
name: "Security Alert Burndown"
description: "Drive the code security alerts backlog to zero"

# GitHub Project for tracking
project-url: "https://github.com/orgs/ORG/projects/1"
tracker-label: "campaign:security-alert-burndown"

# Strategic goals
objective: "Reduce open code security alerts to zero without breaking CI."
kpis:
  - id: open_alerts
    name: "Open alerts"
    priority: primary
    direction: "decrease"
    target: 0

# Worker workflows to dispatch
workflows:
  - security-alert-fix

# Governance and pacing
governance:
  max-project-updates-per-run: 10
  max-comments-per-run: 10
---
```

The spec is validated and compiled to create the campaign's orchestrator workflow (`.campaign.lock.yml`) that GitHub Actions can execute.
Think of it like compiling code: you write a human-friendly campaign definition, and the compiler produces a hardened, machine-executable workflow.

**What happens next**: Once merged, the orchestrator runs on schedule (daily by default) to [dispatch worker workflows, discover items, update the Project board, and report status](/gh-aw/guides/campaigns/flow/). The campaign coordinates all work toward your objective while respecting governance limits.

## Next steps

- [Getting started](/gh-aw/guides/campaigns/getting-started/) – create your first campaign
- [Campaign specs](/gh-aw/guides/campaigns/specs/) – fields you can configure
- [Flow & Lifecycle](/gh-aw/guides/campaigns/flow/) – what the orchestrator does each run
- [CLI commands](/gh-aw/guides/campaigns/cli-commands/) – inspect and validate campaigns
