---
title: Cache Memory - Persistent Memory for Agentic Workflows
description: Complete guide to using cache-memory for persistent memory across workflow runs using GitHub Actions cache and MCP memory servers.
---

# Cache Memory - Persistent Memory for Agentic Workflows

The `cache-memory` feature enables agentic workflows to maintain persistent memory across workflow runs by integrating the Model Context Protocol (MCP) memory server with GitHub Actions cache.

## Overview

Cache Memory provides:

- **Persistent Memory**: AI agents can remember information across multiple workflow runs
- **GitHub Actions Integration**: Built on top of GitHub Actions cache infrastructure 
- **MCP Memory Server**: Uses the official Model Context Protocol memory server in a Docker container
- **Automatic Configuration**: Seamlessly integrates with Claude and Custom engines
- **Smart Caching**: Intelligent cache key generation and restoration strategies

## How It Works

When `cache-memory` is enabled, the workflow compiler automatically:

1. **Mounts Memory MCP Server**: Configures an official MCP memory server in a Docker container
2. **Creates Cache Steps**: Adds GitHub Actions cache steps to restore and save memory data
3. **Persistent Storage**: Maps `/tmp/cache-memory` to the MCP server's data directory
4. **Cache Key Management**: Generates intelligent cache keys with progressive fallback
5. **Tool Integration**: Adds "memory" tool to the MCP configuration for AI engines

## Basic Usage

### Simple Enable

Enable cache-memory with default settings:

```yaml
---
engine: claude
tools:
  cache-memory: true
  github:
    allowed: [get_repository]
---
```

This uses:
- **Default cache key**: `memory-${{ github.workflow }}-${{ github.run_id }}`
- **Default Docker image**: `mcp/memory` (official MCP memory server)
- **Default storage path**: `/tmp/cache-memory` mounted to `/app/dist` in container

### Advanced Configuration

Customize cache key, Docker image, and artifact retention:

```yaml
---
engine: claude
tools:
  cache-memory:
    key: custom-memory-${{ github.workflow }}-${{ github.run_id }}
    docker-image: "ghcr.io/modelcontextprotocol/server-memory:v1.0.0"
    retention-days: 30
  github:
    allowed: [get_repository]
---
```

### Custom Docker Images

Use specific versions or alternative memory server implementations:

```yaml
---
engine: claude
tools:
  cache-memory:
    docker-image: "ghcr.io/modelcontextprotocol/server-memory:sha-abcd123"
    retention-days: 7
  github:
    allowed: [get_repository]
---
```

### Artifact Retention

Configure how long memory data artifacts are retained:

```yaml
---
engine: claude
tools:
  cache-memory:
    key: persistent-memory
    retention-days: 90  # Keep artifacts for 90 days (1-90 range)
  github:
    allowed: [get_repository]
---
```

The `retention-days` option controls the `actions/upload-artifact` retention period:
- **Range**: 1-90 days
- **Default**: Repository setting (if not specified)
- **Purpose**: Provides alternative access to memory data beyond cache expiration

## Cache Behavior and GitHub Actions Integration

### Cache Key Strategy

Cache Memory builds on GitHub Actions cache infrastructure with these behaviors:

#### Automatic Key Generation

- **Default Pattern**: `memory-${{ github.workflow }}-${{ github.run_id }}`
- **Custom Keys**: Any custom key gets `-${{ github.run_id }}` appended automatically
- **Example**: `project-memory` becomes `project-memory-${{ github.run_id }}`

#### Progressive Restore Keys

Restore keys are automatically generated by splitting the cache key on dashes, creating a fallback hierarchy:

For key `custom-memory-project-v1-${{ github.run_id }}`, restore keys are:
```
custom-memory-project-v1-
custom-memory-project-
custom-memory-
custom-
```

This ensures the most specific match is found first, with progressive fallbacks.

### GitHub Actions Cache Integration

Cache Memory leverages GitHub Actions cache with these characteristics:

#### Cache Retention
- **Retention Period**: 7 days (GitHub Actions standard)
- **Size Limit**: 10GB per repository (GitHub Actions standard)
- **LRU Eviction**: Least recently used caches are evicted when limits are reached

#### Artifact Upload (Optional)
When `retention-days` is configured, memory data is also uploaded as artifacts:
- **Retention Period**: 1-90 days (configurable via `retention-days`)
- **Purpose**: Alternative access to memory data beyond cache expiration
- **Use Case**: Long-term memory persistence for workflows that run infrequently

#### Cache Scoping
- **Branch Scoping**: Caches are accessible across branches in the same repository
- **Workflow Scoping**: Each workflow maintains its own cache namespace by default
- **Run Scoping**: Each run gets unique cache keys to prevent conflicts

### Update Behavior

#### First Run
- **No Cache Hit**: Memory starts empty
- **Storage**: New memories are stored in `/tmp/cache-memory`
- **Cache Save**: Memory data is cached at workflow completion

#### Subsequent Runs
- **Cache Restore**: Previous memory data is restored from cache
- **Memory Continuity**: AI agent can access previously stored information
- **Incremental Updates**: New memories are added to existing data
- **Cache Update**: Updated memory data is saved with new cache key

#### Cache Expiration
- **Automatic Expiration**: Caches expire after 7 days of inactivity
- **Manual Cleanup**: Repository administrators can clear caches manually
- **Version Management**: Different cache keys allow for memory versioning

## Generated Workflow Steps

When cache-memory is enabled, these steps are automatically added to your workflow:

### Basic Configuration (Cache Only)

```yaml
# Cache memory MCP configuration from frontmatter processed below
- name: Create cache-memory directory
  run: mkdir -p /tmp/cache-memory

- name: Cache memory MCP data
  uses: actions/cache@v5
  with:
    key: memory-${{ github.workflow }}-${{ github.run_id }}
    path: /tmp/cache-memory
    restore-keys: |
      memory-${{ github.workflow }}-
      memory-
```

### With Artifact Upload (retention-days configured)

```yaml
# Cache memory MCP configuration from frontmatter processed below
- name: Create cache-memory directory
  run: mkdir -p /tmp/cache-memory

- name: Cache memory MCP data
  uses: actions/cache@v5
  with:
    key: memory-${{ github.workflow }}-${{ github.run_id }}
    path: /tmp/cache-memory
    restore-keys: |
      memory-${{ github.workflow }}-
      memory-

- name: Upload memory MCP data as artifact
  uses: actions/upload-artifact@v4
  with:
    name: cache-memory-data
    path: /tmp/cache-memory
    retention-days: 30
```

## MCP Server Configuration

The memory server is configured following official MCP documentation:

```json
"memory": {
  "command": "docker",
  "args": [
    "run", "-i", "--rm", "-v",
    "/tmp/cache-memory:/app/dist",
    "mcp/memory"
  ],
  "env": {
    "MEMORY_FILE_PATH": "/app/dist/memory.json"
  }
}
```

### Docker Image Options

#### Official Images
- `mcp/memory`: Official MCP memory server (default)
- `ghcr.io/modelcontextprotocol/server-memory:latest`: Alternative official image

#### Version Pinning
- `ghcr.io/modelcontextprotocol/server-memory:v1.0.0`: Specific version
- `ghcr.io/modelcontextprotocol/server-memory:sha-abcd123`: Specific commit SHA

## Memory Operations

### Storing Information

The AI agent can store information using the memory tool:

```
Remember that the user prefers verbose error messages when debugging.
```

### Retrieving Information

The AI agent can query its memory:

```
What do I know about the user's debugging preferences?
```

### Memory Categories

The MCP memory server organizes information into categories:

- **Basic Identity**: User identification and context
- **Behaviors**: Observed patterns and preferences  
- **Preferences**: Explicit user preferences
- **Goals**: Stated objectives and tasks
- **Relationships**: Connections between entities

## Best Practices

### Cache Key Naming

Use descriptive, hierarchical cache keys:

```yaml
tools:
  cache-memory:
    key: project-${{ github.repository_owner }}-${{ github.workflow }}
```

### Memory Scope

Consider the scope of memory needed:

- **Workflow-specific**: Default behavior, memory per workflow
- **Repository-wide**: Use repository name in cache key
- **User-specific**: Include user information in cache key

### Resource Management

Be mindful of cache usage:

- **Memory Size**: Monitor memory data growth over time
- **Cache Limits**: Respect GitHub's 10GB repository cache limit
- **Cleanup Strategy**: Consider periodic cache clearing for long-running projects

### Docker Image Selection

Choose appropriate Docker images:

- **Production**: Pin to specific versions for stability
- **Development**: Use latest for newest features
- **Security**: Prefer official images or verify third-party images

## Troubleshooting

### Common Issues

#### Memory Not Persisting
- **Check Cache Keys**: Ensure keys are consistent between runs
- **Verify Paths**: Confirm `/tmp/cache-memory` directory exists
- **Review Logs**: Check workflow logs for cache restore/save messages

#### Docker Image Issues
- **Image Availability**: Verify Docker image exists and is accessible
- **Version Compatibility**: Ensure MCP server version supports required features
- **Network Access**: Confirm runner can pull Docker images

#### Cache Size Issues
- **Monitor Usage**: Track cache size growth over time
- **Cleanup Strategy**: Implement periodic cache clearing
- **Key Rotation**: Use time-based cache keys for automatic expiration

### Debugging

Enable verbose logging to debug cache-memory issues:

```yaml
---
engine: claude
tools:
  cache-memory: true
timeout_minutes: 10  # Allow time for debugging
---

# Debug Cache Memory

Please debug the cache-memory functionality by:

1. Checking what's currently in memory
2. Storing a test message
3. Retrieving the stored message
4. Reporting on memory persistence
```

## Security Considerations

### Data Privacy

- **Sensitive Data**: Avoid storing sensitive information in memory
- **Access Control**: Memory data follows repository access permissions
- **Audit Trail**: Cache access is logged in workflow execution logs

### Docker Security

- **Image Verification**: Use official or verified Docker images
- **Container Isolation**: Memory server runs in isolated container
- **Network Security**: Container has no network access by default

## Examples

### Basic Memory Usage

```yaml
---
engine: claude
on:
  workflow_dispatch:
    inputs:
      remember:
        description: 'Information to remember'
        required: true

tools:
  cache-memory: true
  github:
    allowed: [get_repository]
---

# Memory Test Workflow

Store and retrieve information across workflow runs.

## Task

1. Check what you remember from previous runs
2. Store the new information: "${{ inputs.remember }}"
3. List all stored memories
4. Provide a summary of memory persistence
```

### Project-Specific Memory

```yaml
---
engine: claude
tools:
  cache-memory:
    key: project-docs-${{ github.repository }}-${{ github.workflow }}
    docker-image: "ghcr.io/modelcontextprotocol/server-memory:v1.0.0"
  github:
    allowed: [get_repository, list_files]
---

# Documentation Assistant

Use project-specific memory to maintain context about documentation updates.
```

### Multi-Workflow Memory Sharing

```yaml
---
engine: claude
tools:
  cache-memory:
    key: shared-memory-${{ github.repository }}
---

# Shared Memory Workflow

Share memory data across multiple workflows in the same repository.
```

## Related Documentation

- [Frontmatter Options](frontmatter.md) - Complete frontmatter configuration guide
- [MCP Tools](mcps.md) - Model Context Protocol integration
- [Safe Outputs](safe-outputs.md) - Output processing and automation
- [GitHub Actions Cache Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows) - Official GitHub cache documentation