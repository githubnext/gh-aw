---
title: Cache Memory
description: Complete guide to using cache-memory for persistent memory across workflow runs using GitHub Actions cache and MCP memory servers.
---

The `cache-memory` feature enables agentic workflows to maintain persistent memory across workflow runs by integrating the Model Context Protocol (MCP) memory server with GitHub Actions cache.

## Overview

Cache Memory provides:

- **Persistent Memory**: AI agents can remember information across multiple workflow runs
- **GitHub Actions Integration**: Built on top of GitHub Actions cache infrastructure 
- **MCP Memory Server**: Uses the official Model Context Protocol memory server via npx
- **Automatic Configuration**: Seamlessly integrates with Claude and Custom engines
- **Smart Caching**: Intelligent cache key generation and restoration strategies

## How It Works

When `cache-memory` is enabled, the workflow compiler automatically:

1. **Mounts Memory MCP Server**: Configures an official MCP memory server via npx
2. **Creates Cache Steps**: Adds GitHub Actions cache steps to restore and save memory data
3. **Persistent Storage**: Maps `/tmp/cache-memory` to store memory data files
4. **Cache Key Management**: Generates intelligent cache keys with progressive fallback
5. **Tool Integration**: Adds "memory" tool to the MCP configuration for AI engines

## Basic Usage

### Simple Enable

Enable cache-memory with default settings:

```yaml
---
engine: claude
tools:
  cache-memory: true
  github:
    allowed: [get_repository]
---
```

This uses:
- **Default cache key**: `memory-${{ github.workflow }}-${{ github.run_id }}`
- **Default setup**: Uses `npx @modelcontextprotocol/server-memory` 
- **Default storage path**: `/tmp/cache-memory` for memory data files

### Advanced Configuration

Customize cache key and artifact retention:

```yaml
---
engine: claude
tools:
  cache-memory:
    key: custom-memory-${{ github.workflow }}-${{ github.run_id }}
    retention-days: 30
  github:
    allowed: [get_repository]
---
```

### Artifact Retention

Configure how long memory data artifacts are retained:

```yaml
---
engine: claude
tools:
  cache-memory:
    key: persistent-memory
    retention-days: 90  # Keep artifacts for 90 days (1-90 range)
  github:
    allowed: [get_repository]
---
```

The `retention-days` option controls the `actions/upload-artifact` retention period:
- **Range**: 1-90 days
- **Default**: Repository setting (if not specified)
- **Purpose**: Provides alternative access to memory data beyond cache expiration

## Cache Behavior and GitHub Actions Integration

### Cache Key Strategy

Cache Memory builds on GitHub Actions cache infrastructure with these behaviors:

#### Automatic Key Generation

- **Default Pattern**: `memory-${{ github.workflow }}-${{ github.run_id }}`
- **Custom Keys**: Any custom key gets `-${{ github.run_id }}` appended automatically
- **Example**: `project-memory` becomes `project-memory-${{ github.run_id }}`

#### Progressive Restore Keys

Restore keys are automatically generated by splitting the cache key on dashes, creating a fallback hierarchy:

For key `custom-memory-project-v1-${{ github.run_id }}`, restore keys are:
```
custom-memory-project-v1-
custom-memory-project-
custom-memory-
custom-
```

This ensures the most specific match is found first, with progressive fallbacks.

### GitHub Actions Cache Integration

Cache Memory leverages GitHub Actions cache with these characteristics:

#### Cache Retention
- **Retention Period**: 7 days (GitHub Actions standard)
- **Size Limit**: 10GB per repository (GitHub Actions standard)
- **LRU Eviction**: Least recently used caches are evicted when limits are reached

#### Artifact Upload (Optional)
When `retention-days` is configured, memory data is also uploaded as artifacts:
- **Retention Period**: 1-90 days (configurable via `retention-days`)
- **Purpose**: Alternative access to memory data beyond cache expiration
- **Use Case**: Long-term memory persistence for workflows that run infrequently

#### Cache Scoping
- **Branch Scoping**: Caches are accessible across branches in the same repository
- **Workflow Scoping**: Each workflow maintains its own cache namespace by default
- **Run Scoping**: Each run gets unique cache keys to prevent conflicts

## MCP Server Configuration

The memory server is configured using npx following official MCP documentation:

```json
"memory": {
  "command": "npx",
  "args": [
    "@modelcontextprotocol/server-memory"
  ],
  "env": {
    "MEMORY_FILE_PATH": "/tmp/cache-memory/memory.json"
  }
}
```

## Memory Operations

### Storing Information

The AI agent can store information using the memory tool:

```
Remember that the user prefers verbose error messages when debugging.
```

### Retrieving Information

The AI agent can query its memory:

```
What do I know about the user's debugging preferences?
```

### Memory Categories

The MCP memory server organizes information into categories:

- **Basic Identity**: User identification and context
- **Behaviors**: Observed patterns and preferences  
- **Preferences**: Explicit user preferences
- **Goals**: Stated objectives and tasks
- **Relationships**: Connections between entities

## Best Practices

### Cache Key Naming

Use descriptive, hierarchical cache keys:

```yaml
tools:
  cache-memory:
    key: project-${{ github.repository_owner }}-${{ github.workflow }}
```

### Memory Scope

Consider the scope of memory needed:

- **Workflow-specific**: Default behavior, memory per workflow
- **Repository-wide**: Use repository name in cache key
- **User-specific**: Include user information in cache key

### Resource Management

Be mindful of cache usage:

- **Memory Size**: Monitor memory data growth over time
- **Cache Limits**: Respect GitHub's 10GB repository cache limit
- **Cleanup Strategy**: Consider periodic cache clearing for long-running projects

## Troubleshooting

### Common Issues

#### Memory Not Persisting
- **Check Cache Keys**: Ensure keys are consistent between runs
- **Verify Paths**: Confirm `/tmp/cache-memory` directory exists
- **Review Logs**: Check workflow logs for cache restore/save messages

#### Package Installation Issues
- **npm Registry Access**: Verify runner can access npm registry
- **Package Availability**: Confirm `@modelcontextprotocol/server-memory` package exists
- **Network Access**: Ensure runner has internet connectivity for package installation

#### Cache Size Issues
- **Monitor Usage**: Track cache size growth over time
- **Cleanup Strategy**: Implement periodic cache clearing
- **Key Rotation**: Use time-based cache keys for automatic expiration

### Debugging

Enable verbose logging to debug cache-memory issues:

```yaml
---
engine: claude
tools:
  cache-memory: true
timeout_minutes: 10  # Allow time for debugging
---

# Debug Cache Memory

Please debug the cache-memory functionality by:

1. Checking what's currently in memory
2. Storing a test message
3. Retrieving the stored message
4. Reporting on memory persistence
```

## Security Considerations

### Data Privacy

- **Sensitive Data**: Avoid storing sensitive information in memory
- **Access Control**: Memory data follows repository access permissions
- **Audit Trail**: Cache access is logged in workflow execution logs

### Package Security

- **Official Package**: Use only the official `@modelcontextprotocol/server-memory` package
- **Dependency Scanning**: npm automatically scans for vulnerabilities
- **Audit Trail**: Package installation is logged in workflow execution logs

## Examples

### Basic Memory Usage

```yaml
---
engine: claude
on:
  workflow_dispatch:
    inputs:
      remember:
        description: 'Information to remember'
        required: true

tools:
  cache-memory: true
  github:
    allowed: [get_repository]
---

# Memory Test Workflow

Store and retrieve information across workflow runs.

## Task

1. Check what you remember from previous runs
2. Store the new information: "${{ inputs.remember }}"
3. List all stored memories
4. Provide a summary of memory persistence
```

### Project-Specific Memory

```yaml
---
engine: claude
tools:
  cache-memory:
    key: project-docs-${{ github.repository }}-${{ github.workflow }}
  github:
    allowed: [get_repository, list_files]
---

# Documentation Assistant

Use project-specific memory to maintain context about documentation updates.
```

### Multi-Workflow Memory Sharing

```yaml
---
engine: claude
tools:
  cache-memory:
    key: shared-memory-${{ github.repository }}
---

# Shared Memory Workflow

Share memory data across multiple workflows in the same repository.
```

## Related Documentation

- [Frontmatter Options](../reference/frontmatter.md) - Complete frontmatter configuration guide
- [MCP Tools](../guides/mcps.md) - Model Context Protocol integration
- [Safe Outputs](../reference/safe-outputs.md) - Output processing and automation
- [GitHub Actions Cache Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows) - Official GitHub cache documentation