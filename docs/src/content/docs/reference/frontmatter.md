---
title: Frontmatter
description: Complete guide to all available frontmatter configuration options for GitHub Agentic Workflows, including triggers, permissions, AI engines, and workflow settings.
sidebar:
  order: 200
---

The frontmatter section of GitHub Agentic Workflows includes the triggers, permissions, AI engines, and workflow settings. For example:

```yaml wrap
---
on:
  issues:
    types: [opened]

tools:
  edit:
  bash: ["gh issue comment"]
---
...markdown instructions...
```

## Frontmatter Elements

The frontmatter combines standard GitHub Actions properties (`on`, `permissions`, `run-name`, `runs-on`, `timeout-minutes`, `concurrency`, `env`, `environment`, `container`, `services`, `if`, `steps`, `cache`) with GitHub Agentic Workflows-specific elements (`description`, `source`, `github-token`, `imports`, `engine`, `strict`, `roles`, `features`, `safe-outputs`, `network`, `tools`, `cache-memory`).

### Trigger Events (`on:`)

The `on:` section uses standard GitHub Actions syntax to define workflow triggers, with additional fields for security and approval controls:

- Standard GitHub Actions triggers (push, pull_request, issues, schedule, etc.)
- `reaction:` - Add emoji reactions to triggering items
- `stop-after:` - Automatically disable triggers after a deadline
- `manual-approval:` - Require manual approval using environment protection rules
- `forks:` - Configure fork filtering for pull_request triggers

See [Trigger Events](/gh-aw/reference/triggers/) for complete documentation.

#### Usage Guidance: String vs Object

**Use string form** when you have a simple trigger without filters:

```yaml wrap
# Simple trigger - workflow runs on any issue event
on: issues
```

**Use object form** when you need:
- Event-specific filters (types, branches, paths)
- Multiple trigger events
- Special features (reaction, stop-after, manual-approval)
- Fork filtering for pull_request triggers
- Command triggers

```yaml wrap
# Complex trigger with filters
on:
  issues:
    types: [opened, reopened]
  pull_request:
    types: [opened, synchronize]
    branches: [main, dev]
    forks: ["trusted-org/*"]
```

**Migration path:** Start with string form for basic triggers, expand to object form as you add event filters or additional trigger events.

### Description (`description:`)

The `description:` field provides a human-readable description of the workflow that is rendered as a comment in the generated lock file. This helps document the purpose and functionality of the workflow.

```yaml wrap
description: "Workflow that analyzes pull requests and provides feedback"
```

The description appears in the lock file header as a comment:

```yaml wrap
# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile
# For more information: https://github.com/githubnext/gh-aw/blob/main/.github/instructions/github-agentic-workflows.instructions.md
#
# Workflow that analyzes pull requests and provides feedback

name: "PR Analyzer"
...
```

### Source Tracking (`source:`)

The `source:` field tracks workflow origin (format: `owner/repo/path@ref`). This field is automatically populated when using `gh aw add` to install workflows from external repositories, enabling traceability, update tracking, and auditing.

```yaml wrap
source: "githubnext/agentics/workflows/ci-doctor.md@v1.0.0"
```

When you run `gh aw add githubnext/agentics/ci-doctor@v1.0.0`, the source field is automatically added to the workflow frontmatter. This field is optional for manually created workflows.

### GitHub Token (`github-token:`)

The `github-token:` field configures the default GitHub token for the entire workflow. This token is used for engine authentication, checkout steps, and safe-output operations unless overridden at more specific levels.

```yaml wrap
github-token: ${{ secrets.CUSTOM_PAT }}
```

:::caution[Secret Expression Required]
The `github-token` field **must** use a GitHub Actions secret expression (e.g., `${{ secrets.CUSTOM_PAT }}`). Plaintext tokens are rejected during compilation to prevent accidental secret leakage.

**Valid formats:**
- `${{ secrets.GITHUB_TOKEN }}`
- `${{ secrets.CUSTOM_PAT }}`
- `${{ secrets.GH_AW_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}`

**Invalid formats:**
- `ghp_1234567890...` (plaintext token)
- `${{ env.MY_TOKEN }}` (environment variable; not protected like secrets)
- `my-secret-token` (plaintext string)
:::

The token precedence hierarchy allows fine-grained control:

1. **Individual safe-output `github-token`** (highest priority) - e.g., `create-issue.github-token`
2. **Safe-outputs global `github-token`** - e.g., `safe-outputs.github-token`
3. **Top-level `github-token`** - Workflow-level default
4. **Default fallback** - `${{ secrets.GH_AW_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}`

This enables setting a workflow default while allowing specific operations to use different tokens. See the [Security Guide](/gh-aw/guides/security/#authorization-and-token-management) for complete token configuration documentation.

### Permissions (`permissions:`)

The `permissions:` section uses standard GitHub Actions permissions syntax to specify the permissions relevant to the agentic (natural language) part of the execution of the workflow. See [GitHub Actions permissions documentation](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#permissions).

```yaml wrap
# Specific permissions
permissions:
  issues: write
  contents: read
  pull-requests: write

# All permissions
permissions: write-all
permissions: read-all

# No permissions
permissions: {}
```

If you specify any permission, unspecified ones are set to `none`.

#### Permission Validation

The compiler validates that workflows have sufficient permissions for their configured tools. When GitHub toolsets require permissions not declared in the frontmatter, the compiler behavior depends on the mode:

**Non-strict mode (default):**
```bash wrap
gh aw compile
```

Emits actionable warnings with suggestions to either add missing permissions or reduce toolset requirements:

```
warning: Missing required permissions for github toolsets:
  - contents: write (required by repos)
  - issues: write (required by issues)

To fix this, you can either:

Option 1: Add missing permissions to your workflow frontmatter:
permissions:
  contents: write
  issues: write

Option 2: Reduce the required toolsets in your workflow:
Remove or adjust toolsets that require these permissions:
  - issues
  - repos
```

**Strict mode:**
```bash wrap
gh aw compile --strict
```

Treats under-provisioned permissions as compilation errors, requiring workflows to declare all necessary permissions before deployment.

Use strict mode for production workflows that require enhanced security validation or compliance with security policies.

#### Usage Guidance: String vs Object

**Use string form** for broad permission sets:

```yaml wrap
# Read all permissions
permissions: read-all

# Write all permissions (⚠️ use with caution)
permissions: write-all
```

**Use object form** for granular permission control (recommended):

```yaml wrap
# Specific permissions only
permissions:
  contents: read
  issues: write
  pull-requests: write
```

**Migration path:** Start with `read-all` for prototyping, then switch to object form with specific permissions for production. When using safe-outputs, the main job only needs read permissions.

**Best practice:** Use object form with `safe-outputs` to minimize permissions in the main job. Safe-output jobs automatically receive necessary write permissions.

### Repository Access Roles (`roles:`)

Controls who can trigger agentic workflows based on repository permission level. Defaults to `[admin, maintainer, write]` for security.

```yaml wrap
roles: [admin, maintainer, write]  # Default
roles: [admin, maintainer]         # Restrict to admin/maintainer only
roles: [write]                     # Allow write access only
roles: all                         # Allow any user (⚠️ use with caution)
```

Available roles: `admin` (full access), `maintainer` (manage repository), `write` (push and manage issues/PRs), `read` (read/clone only), `all` (no permission checking).

Workflows with potentially unsafe triggers (`push`, `issues`, `pull_request`) automatically enforce permission checks. Safe triggers (`schedule`, `workflow_run`) skip checks by default. Failed permission checks cancel the workflow with a warning.

#### Usage Guidance: String vs Array

**Use string form** to disable role checking:

```yaml wrap
# Allow any authenticated user (⚠️ security consideration)
roles: all
```

**Use array form** for role-based access control (recommended):

```yaml wrap
# Default - maintainers and above
roles: [admin, maintainer, write]

# Restrict to repository owners only
roles: [admin]

# Allow contributors with write access
roles: [admin, maintainer, write]
```

**Migration path:** Start with the default array (`[admin, maintainer, write]`), tighten to `[admin]` for sensitive workflows, or use `all` only for public, read-only operations.

**Best practice:** Keep the default array for most workflows. Use `[admin]` for workflows that modify repository settings or trigger expensive operations.

### Strict Mode (`strict:`)

Enables enhanced validation for production workflows, enforcing security constraints. When enabled, the compiler rejects workflows that don't meet strict mode requirements.

```yaml wrap
strict: true  # Enable (default: false)
```

Strict mode enforces: (1) no write permissions for `contents`, `issues`, or `pull-requests` (use `safe-outputs` instead), (2) explicit network configuration required, (3) no wildcard `*` in `network.allowed`, (4) network configuration for custom MCP servers with containers.

Enable with `strict: true` in frontmatter or `gh aw compile --strict` (CLI flag applies to all workflows and takes precedence). Use for production workflows requiring enhanced security validation or security policy compliance.

### Feature Flags (`features:`)

Enable experimental or optional features for your workflow using feature flags. Each feature is a boolean key-value pair.

```yaml wrap
features:
  my-experimental-feature: true
```

:::note[Firewall Feature Removed]
The `features.firewall` flag has been removed. Use `network.firewall` instead. See [Network Permissions](/gh-aw/reference/network/) for details.

**Correct format:**
```yaml wrap
network:
  firewall: true
```
:::

### AI Engine (`engine:`)

The `engine:` section specifies which AI engine to use to interpret the markdown section of the workflow, and controls options about how this execution proceeds. See [AI Engines](/gh-aw/reference/engines/) for details.

```yaml wrap
engine: copilot
```

### Network Permissions (`network:`)

Control network access for AI engines using ecosystem identifiers and domain allowlists. See [Network Permissions](/gh-aw/reference/network/) for detailed configuration options, security model, and examples.

Quick example:
```yaml wrap
engine:
  id: claude

network:
  allowed:
    - defaults              # Basic infrastructure
    - python               # Python/PyPI ecosystem
    - "api.example.com"    # Custom domain
```

#### Usage Guidance: String vs Object

**Use string form** for default network permissions:

```yaml wrap
# Basic infrastructure only (certificates, JSON schema, Ubuntu)
network: defaults
```

**Use object form** when you need custom network access:

```yaml wrap
# Custom domains and ecosystems
network:
  allowed:
    - defaults           # Include basic infrastructure
    - python            # Add Python ecosystem
    - node              # Add Node.js ecosystem
    - "api.custom.com"  # Add specific domain
  firewall: true        # Enable AWF (Copilot only)
```

**Deny all network access:**

```yaml wrap
# No network access (empty object)
network: {}
```

**Migration path:** Start with `network: defaults` or omit the field (defaults to `defaults`). Add object form with `allowed:` array when you need web-fetch or web-search capabilities. Add ecosystem identifiers as needed for specific tools.

**Best practice:** Use `defaults` for workflows without web access. Use object form with specific ecosystems and domains for workflows needing external APIs or package repositories.

### Safe Outputs (`safe-outputs:`)

See [Safe Outputs Processing](/gh-aw/reference/safe-outputs/) for automatic issue creation, comment posting and other safe outputs.

### Run Configuration (`run-name:`, `runs-on:`, `timeout-minutes:`)

Standard GitHub Actions properties:
```yaml wrap
run-name: "Custom workflow run name"  # Defaults to workflow name
runs-on: ubuntu-latest               # Defaults to ubuntu-latest (main job only)
timeout-minutes: 30                  # Defaults to 20 minutes (timeout_minutes deprecated)
```

**Note**: The `timeout_minutes` field is deprecated. Use `timeout-minutes` instead to follow GitHub Actions naming convention.

### Workflow Concurrency Control (`concurrency:`)

GitHub Agentic Workflows automatically generates concurrency policies for the agent job to control concurrent execution.

See [Concurrency Control](/gh-aw/reference/concurrency/) for complete documentation on agent concurrency configuration.

#### Usage Guidance: String vs Object

**Use string form** for simple concurrency grouping:

```yaml wrap
# Prevent concurrent runs of this workflow
concurrency: ${{ github.workflow }}

# Per-branch concurrency
concurrency: workflow-${{ github.ref }}
```

**Use object form** when you need to cancel in-progress runs:

```yaml wrap
# Cancel old runs when new ones start
concurrency:
  group: pr-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true
```

**Migration path:** Start with string form for basic queuing. Add object form with `cancel-in-progress: true` when you want newer runs to supersede older ones (useful for PR analysis workflows).

**Best practice:** Use string form with workflow-specific grouping for most cases. Use object form with `cancel-in-progress: true` for workflows where only the latest run matters.

## Environment Variables (`env:`)

GitHub Actions standard `env:` syntax:

```yaml wrap
env:
  CUSTOM_VAR: "value"
  SECRET_VAR: ${{ secrets.MY_SECRET }}
```

#### Usage Guidance: Object vs String

**Use object form** for structured environment variables (recommended):

```yaml wrap
env:
  NODE_ENV: production
  API_KEY: ${{ secrets.API_KEY }}
  DEBUG: "false"
```

**Use string form** for single-line environment definitions (rare, legacy support):

```yaml wrap
env: "NODE_ENV=production"
```

**Migration path:** Always use object form for clarity and maintainability. String form is supported for legacy compatibility but not recommended.

**Best practice:** Use object form with descriptive keys. Store sensitive values in secrets and reference them with `${{ secrets.* }}`.

## Environment Protection (`environment:`)

The `environment:` section specifies the environment that the job references, enabling deployment protection rules and environment-specific secrets and variables. This follows standard GitHub Actions syntax for job-level environment configuration.

**Simple environment name:**
```yaml wrap
environment: production
```

For more information about environments, see [GitHub Action's environment documentation](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment).

#### Usage Guidance: String vs Object

**Use string form** for basic environment references:

```yaml wrap
# Simple environment reference
environment: production
```

**Use object form** when you need deployment URLs:

```yaml wrap
# Environment with deployment URL
environment:
  name: production
  url: https://myapp.example.com
```

**Migration path:** Start with string form for basic protection rules. Add object form with `url` when you need deployment tracking in GitHub's deployments view.

**Best practice:** Use string form for environment protection rules and secrets. Add object form with `url` for deployments that should appear in GitHub's deployment dashboard.

## Container Configuration (`container:`)

The `container:` section specifies a container to run the job steps in, useful for standardized execution environments or specific runtime requirements.

**Simple container image:**
```yaml wrap
container: node:18
```

For more information about environments, see [GitHub Action's container documentation](https://docs.github.com/en/actions/how-tos/write-workflows/choose-where-workflows-run/run-jobs-in-a-container).

#### Usage Guidance: String vs Object

**Use string form** for public images without credentials:

```yaml wrap
# Public Docker Hub image
container: node:18

# Public GitHub Container Registry image
container: ghcr.io/owner/image:tag
```

**Use object form** when you need:
- Private registry authentication
- Custom environment variables
- Port mappings
- Volume mounts
- Additional container options

```yaml wrap
# Private image with credentials and custom settings
container:
  image: myregistry.azurecr.io/myapp:latest
  credentials:
    username: ${{ secrets.REGISTRY_USERNAME }}
    password: ${{ secrets.REGISTRY_PASSWORD }}
  env:
    NODE_ENV: production
  ports:
    - 3000
  volumes:
    - /data:/app/data
```

**Migration path:** Start with string form for public images. Expand to object form when you need authentication or custom configuration.

**Best practice:** Use string form for public images. Use object form for private registries or when you need container customization.

## Service Containers (`services:`)

The `services:` section defines service containers that run alongside your job, commonly used for databases, caches, or other dependencies during testing and deployment.

**Simple service:**
```yaml wrap
services:
  postgres:
    image: postgres:13
    env:
      POSTGRES_PASSWORD: postgres
    ports:
      - 5432:5432
```

For more information about containers and services, see [GitHub Action's container documentation](https://docs.github.com/en/actions/using-containerized-services).

## Conditional Execution (`if:`)

Standard GitHub Actions `if:` syntax:

```yaml wrap
if: github.event_name == 'push'
```

## Custom Steps (`steps:`)

Add custom steps before the agentic execution step using GitHub Actions standard `steps:` syntax:

```yaml wrap
steps:
  - name: Install dependencies
    run: npm ci
```

If no custom steps are specified, a default step to checkout the repository is added automatically.

#### Usage Guidance: Object vs Array

**Use object form** for single-step definitions (legacy syntax):

```yaml wrap
steps:
  name: Install dependencies
  run: npm ci
```

**Use array form** for multiple steps (recommended):

```yaml wrap
steps:
  - name: Checkout code
    uses: actions/checkout@v4
  - name: Install dependencies
    run: npm ci
  - name: Setup environment
    run: echo "Ready for AI execution"
```

**Migration path:** Start with array form for consistency with GitHub Actions. Object form is supported but array form is more flexible and standard.

**Best practice:** Always use array form for steps to support multiple steps and align with GitHub Actions conventions. If no custom steps are provided, a checkout step is added automatically.

## Post-Execution Steps (`post-steps:`)

Add custom steps after the agentic execution step using GitHub Actions standard `steps:` syntax. These steps run after the AI engine completes, regardless of whether the AI execution succeeds or fails (unless you add conditional expressions).

```yaml wrap
post-steps:
  - name: Upload Results
    if: always()
    uses: actions/upload-artifact@v4
    with:
      name: workflow-results
      path: /tmp/gh-aw/
      retention-days: 7
  
  - name: Generate Summary
    run: |
      echo "## Workflow Complete" >> $GITHUB_STEP_SUMMARY
      echo "AI execution finished" >> $GITHUB_STEP_SUMMARY
```

Post-steps are useful for:
- Uploading artifacts generated during AI execution
- Creating workflow summaries or reports
- Cleanup operations
- Triggering downstream workflows

#### Usage Guidance: Object vs Array

**Use object form** for single-step definitions (legacy syntax):

```yaml wrap
post-steps:
  name: Upload Results
  run: echo "Uploading results"
```

**Use array form** for multiple steps (recommended):

```yaml wrap
post-steps:
  - name: Upload Results
    if: always()
    uses: actions/upload-artifact@v4
    with:
      name: workflow-results
      path: /tmp/gh-aw/
  - name: Generate Summary
    run: echo "## Complete" >> $GITHUB_STEP_SUMMARY
```

**Migration path:** Start with array form for consistency with GitHub Actions. Object form is supported but array form is more flexible and standard.

**Best practice:** Always use array form for post-steps to support multiple steps and align with GitHub Actions conventions.

## Custom Jobs (`jobs:`)

Define custom jobs that run before the agentic execution using standard GitHub Actions `jobs:` syntax. Custom jobs support the complete GitHub Actions step specification including all standard properties (`id`, `if`, `name`, `uses`, `run`, `with`, `env`, `continue-on-error`, `timeout-minutes`, `working-directory`, `shell`).

```yaml wrap
jobs:
  super_linter:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Super-Linter
        uses: super-linter/super-linter@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: linter-results
          path: super-linter.log
```

The agentic execution job automatically waits for all custom jobs to complete before running. Custom jobs without explicit `needs:` dependencies automatically depend on the activation job (if present). This enables workflows that perform preliminary checks, prepare data, or run linters before the AI agent executes.

Custom jobs can share data with the agentic execution through artifacts or job outputs.

## Cache Configuration (`cache:`)

Cache configuration using standard GitHub Actions `actions/cache` syntax:

Single cache:
```yaml wrap
cache:
  key: node-modules-${{ hashFiles('package-lock.json') }}
  path: node_modules
  restore-keys: |
    node-modules-
```

#### Usage Guidance: Object vs Array

**Use object form** for a single cache:

```yaml wrap
# Single cache for node_modules
cache:
  key: node-modules-${{ hashFiles('package-lock.json') }}
  path: node_modules
  restore-keys: |
    node-modules-
```

**Use array form** for multiple caches:

```yaml wrap
# Multiple caches for different directories
cache:
  - key: node-modules-${{ hashFiles('package-lock.json') }}
    path: node_modules
    restore-keys: node-modules-
  - key: build-cache-${{ github.sha }}
    path: 
      - dist
      - .cache
    restore-keys: build-cache-
```

**Migration path:** Start with object form for simple dependency caching. Expand to array form when you need to cache multiple directories with different keys or restore strategies.

**Best practice:** Use object form for single-directory caching (e.g., `node_modules`). Use array form when caching multiple directories with different lifecycles (e.g., dependencies vs build outputs).

## Related Documentation

See also: [Trigger Events](/gh-aw/reference/triggers/), [AI Engines](/gh-aw/reference/engines/), [CLI Commands](/gh-aw/setup/cli/), [Workflow Structure](/gh-aw/reference/workflow-structure/), [Network Permissions](/gh-aw/reference/network/), [Command Triggers](/gh-aw/reference/command-triggers/), [MCPs](/gh-aw/guides/mcps/), [Tools](/gh-aw/reference/tools/), [Imports](/gh-aw/reference/imports/)
