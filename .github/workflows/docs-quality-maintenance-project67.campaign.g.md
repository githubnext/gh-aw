---
name: "Documentation Quality & Maintenance Campaign (Project 67)"
description: "Systematically improve documentation quality, consistency, and maintainability. Success: all docs follow Diátaxis framework, maintain accessibility standards, and pass quality checks."
on:
  schedule:
    - cron: "0 18 * * *"
  workflow_dispatch:
concurrency:
  group: "campaign-docs-quality-maintenance-project67-orchestrator-${{ github.ref }}"
  cancel-in-progress: false
engine: copilot
safe-outputs:
    add-comment:
        max: 10
    update-project:
        github-token: ${{ secrets.GH_AW_PROJECT_GITHUB_TOKEN }}
        max: 15
runs-on: ubuntu-latest
roles:
  - "admin"
  - "maintainer"
  - "write"
tools:
    bash:
        - '*'
    edit: null
    github:
        toolsets:
            - default
            - actions
            - code_security
    repo-memory:
        - branch-name: memory/campaigns
          campaign-id: docs-quality-maintenance-project67
          file-glob:
            - docs-quality-maintenance-project67/**
          id: campaigns
---

<!-- This file was automatically generated by gh-aw. DO NOT EDIT. -->
<!-- Source: .github/workflows/docs-quality-maintenance-project67.campaign.md -->

# Campaign Orchestrator

This workflow orchestrates the 'Documentation Quality & Maintenance Campaign (Project 67)' campaign.

- Tracker label: `campaign:docs-quality-maintenance-project67`
- Objective: Maintain high-quality, accessible, and consistent documentation following the Diátaxis framework while ensuring all docs are accurate, complete, and user-friendly
- KPIs:
  - Documentation coverage of features (primary): baseline 85 → target 95 over 90 days percent
  - Documentation accessibility score (supporting): baseline 90 → target 98 over 30 days percent
  - User-reported documentation issues (supporting): baseline 15 → target 5 over 30 days count
- Associated workflows: daily-doc-updater, docs-noob-tester, daily-multi-device-docs-tester, unbloat-docs, developer-docs-consolidator, technical-doc-writer
- Memory paths: memory/campaigns/docs-quality-maintenance-project67/**
- Metrics glob: `memory/campaigns/docs-quality-maintenance-project67/metrics/*.json`
- Cursor glob: `memory/campaigns/docs-quality-maintenance-project67/cursor.json`
- Project URL: https://github.com/orgs/githubnext/projects/67
- Governance: max new items per run: 8
- Governance: max discovery items per run: 100
- Governance: max discovery pages per run: 10
- Governance: max project updates per run: 15
- Governance: max comments per run: 10

## Campaign Orchestrator Rules

This orchestrator follows system-agnostic rules that enforce clean separation between workers and campaign coordination. It also maintains the campaign dashboard by ensuring the GitHub Project stays in sync with the campaign's tracker label.

### Traffic and rate limits (required)

- Minimize API calls: avoid full rescans when possible and avoid repeated reads of the same data in a single run.
- Prefer incremental processing: use deterministic ordering (e.g., by updated time) and process a bounded slice each run.
- Use strict pagination budgets: if a query would require many pages, stop early and continue next run.
- Use a durable cursor/checkpoint: persist the last processed boundary (e.g., updatedAt cutoff + last seen ID) so the next run can continue without rescanning.
- On throttling (HTTP 429 / rate limit 403), do not retry aggressively. Use backoff and end the run after reporting what remains.


**Cursor file (repo-memory)**: `memory/campaigns/docs-quality-maintenance-project67/cursor.json`

You must treat this file as the source of truth for incremental discovery:
- If it exists, read it first and continue from that boundary.
- If it does not exist yet, create it by the end of the run.
- Always write the updated cursor back to the same path.



**Metrics/KPI snapshots (repo-memory)**: `memory/campaigns/docs-quality-maintenance-project67/metrics/*.json`

You must persist a per-run metrics snapshot (including KPI values and trends) as a JSON file stored in the metrics directory implied by the glob above.

**Required JSON schema** for each metrics file:
```json
{
  "campaign_id": "docs-quality-maintenance-project67",
  "date": "YYYY-MM-DD",
  "tasks_total": 0,
  "tasks_completed": 0,
  "tasks_in_progress": 0,
  "tasks_blocked": 0,
  "velocity_per_day": 0.0,
  "estimated_completion": "YYYY-MM-DD",
  "kpi_trends": [
    {"name": "KPI Name", "trend": "Improving|Flat|Regressing", "value": 0.0}
  ]
}
```

**Required fields** (must be present):
- `campaign_id` (string): Must be exactly "docs-quality-maintenance-project67"
- `date` (string): ISO date in YYYY-MM-DD format (use UTC)
- `tasks_total` (integer): Total number of campaign tasks (≥0)
- `tasks_completed` (integer): Number of completed tasks (≥0)

**Optional fields** (omit or set to null if not applicable):
- `tasks_in_progress` (integer): Tasks currently being worked on (≥0)
- `tasks_blocked` (integer): Tasks that are blocked (≥0)
- `velocity_per_day` (number): Average tasks completed per day (≥0)
- `estimated_completion` (string): Estimated completion date in YYYY-MM-DD format
- `kpi_trends` (array): KPI trend information with name, trend status, and current value

Guidance:
- Use an ISO date (UTC) filename, for example: `metrics/2025-12-22.json`.
- Keep snapshots append-only: write a new file per run; do not rewrite historical snapshots.
- If a KPI is present, record its computed value and trend (Improving/Flat/Regressing) in the kpi_trends array.
- Count tasks from all sources: tracker-labeled issues, worker-created issues, and project board items.
- Set tasks_total to the total number of unique tasks discovered in this run.
- Set tasks_completed to the count of tasks with state "Done" or closed status.


**Read budget**: max discovery items per run: 100


**Read budget**: max discovery pages per run: 10


### Core Principles

1. **Workers are immutable** - Worker workflows never change based on campaign state
2. **Workers are campaign-agnostic** - Workers execute the same way regardless of campaign context
3. **Campaign logic is external** - All orchestration, sequencing, and decision-making happens here
4. **Workers only execute work** - No progress tracking or campaign-aware decisions in workers
5. **Campaign owns all coordination** - Sequencing, retries, continuation, and termination are campaign responsibilities
6. **State is external** - Campaign state lives in GitHub Projects, not in worker execution
7. **Single source of truth** - The GitHub Project board is the authoritative campaign state
8. **Correlation is explicit** - All work shares the campaign's tracker-id for correlation
9. **Separation of concerns** - State reads and state writes are separate operations
10. **Predefined fields only** - Only update explicitly defined project board fields
11. **Explicit outcomes** - Record actual outcomes, never infer status
12. **Idempotent operations** - Re-execution produces the same result without corruption
13. **Dashboard synchronization** - Keep Project items in sync with tracker-labeled issues/PRs

### Objective and KPIs (first-class)


**Objective**: Maintain high-quality, accessible, and consistent documentation following the Diátaxis framework while ensuring all docs are accurate, complete, and user-friendly



**KPIs** (max 3):

- Documentation coverage of features (primary): baseline 85 → target 95 over 90 days (unit: percent) (direction: increase) (source: custom)

- Documentation accessibility score (supporting): baseline 90 → target 98 over 30 days (unit: percent) (direction: increase) (source: custom)

- User-reported documentation issues (supporting): baseline 15 → target 5 over 30 days (unit: count) (direction: decrease) (source: pull_requests)



If objective/KPIs are present, you must:
- Compute a per-run KPI snapshot (as-of now) using GitHub signals.
- Determine trend status for each KPI: Improving / Flat / Regressing (use the KPI direction when present).
- Tie all decisions to the primary KPI first.

### Default signals (built-in)

Collect these signals every run (bounded by the read budgets above):
- **CI health**: recent check/workflow outcomes relevant to the repo(s) in scope.
- **PR cycle time**: recent PR open→merge latency and backlog size.
- **Security alerts**: open code scanning / Dependabot / secret scanning items (as available).

If a signal cannot be retrieved (permissions/tooling), explicitly report it as unavailable and proceed with the remaining signals.

### Orchestration Workflow

Execute these steps in sequence each time this orchestrator runs:

#### Phase 1: Read State (Discovery)

1. **Query tracker-labeled items** - Search for issues and PRs matching the campaign's tracker label
   - Search: `repo:OWNER/REPO label:TRACKER_LABEL` for all open and closed items
   - If governance opt-out labels are configured, exclude items with those labels
   - Collect all matching issue/PR URLs
   - Record metadata: number, title, state (open/closed), created date, updated date

2. **Query worker-created issues** (if workers are configured) - Search for issues containing worker tracker-ids
   - For each worker in `workflows`, search: `repo:OWNER/REPO "tracker-id: WORKER_ID" in:body`
   - Collect all matching issue URLs
   - Record issue metadata: number, title, state (open/closed), created date, updated date

3. **Query current project state** - Read the GitHub Project board
   - Retrieve all items currently on the project board
   - For each item, record: issue URL, status field value, other predefined field values
   - Create a snapshot of current board state

4. **Compare and identify gaps** - Determine what needs updating
   - Items from step 1 or 2 not on board = **new work to add**
   - Items on board with state mismatch = **status to update**
   - Items on board but no longer found = **check if archived/deleted**

#### Phase 2: Make Decisions (Planning)

4.5 **Deterministic planner step (required when objective/KPIs are present)**

Before choosing additions/updates, produce a small, bounded plan that is rule-based and reproducible from the discovered state:
- Output at most **3** planned actions.
- Prefer actions that are directly connected to improving the **primary** KPI.
- If signals indicate risk or uncertainty, prefer smaller, reversible actions.

Plan format (keep under 2KB):
```json
{
   "objective": "...",
   "primary_kpi": "...",
   "kpi_trends": [{"name": "...", "trend": "Improving|Flat|Regressing"}],
   "actions": [
      {"type": "add_to_project|update_status|comment", "why": "...", "target_url": "..."}
   ]
}
```

5. **Decide additions (with pacing)** - For each new item discovered:
   - Decision: Add to board? (Default: yes for all items with tracker label or worker tracker-id)
   - If `governance.max-new-items-per-run` is set, add at most that many new items
   - Prefer adding oldest (or least recently updated) missing items first
   - Determine initial status field value based on item state:
     - Open issue/PR → "Todo" status
     - Closed issue/PR → "Done" status

6. **Decide updates (no downgrade)** - For each existing board item with mismatched state:
   - Decision: Update status field? (Default: yes if item state changed)
   - If `governance.do-not-downgrade-done-items` is true, do not move items from Done back to active status
   - Determine new status field value:
     - Open issue/PR → "In Progress" or "Todo"
     - Closed issue/PR → "Done"

7. **Decide completion** - Check campaign completion criteria:
   - If all discovered issues are closed AND all board items are "Done" → Campaign complete
   - Otherwise → Campaign in progress

#### Phase 3: Write State (Execution)

8. **Execute additions** - Add new items to project board
   - Use `update-project` safe-output for each new item
   - Set predefined fields: `status` (required), optionally `priority`, `size`
   - Record outcome: success or failure with error details

9. **Execute updates** - Update existing board items
   - Use `update-project` safe-output for each status change
   - Update only predefined fields: `status` and related metadata
   - Record outcome: success or failure with error details

10. **Record completion state** - If campaign is complete:
    - Mark project metadata field `campaign_status` as "completed"
    - Do NOT create new work or modify existing items
    - This is a terminal state

#### Phase 4: Report (Output)

11. **Generate status report** - Summarize execution results:
    - Total items discovered via tracker label and worker tracker-ids
    - Items added to board this run (count and URLs)
    - Items updated on board this run (count and status changes)
    - Items skipped due to governance limits (and why)
    - Current campaign metrics: open vs closed, progress percentage
    - Any failures encountered during writes
    - Campaign completion status

### Predefined Project Fields

Only these fields may be updated on the project board:

- `status` (required) - Values: "Todo", "In Progress", "Done"
- `priority` (optional) - Values: "High", "Medium", "Low"
- `size` (optional) - Values: "Small", "Medium", "Large"
- `campaign_status` (metadata) - Values: "active", "completed"

Do NOT update any other fields or create custom fields.

### Correlation Mechanism

Workers embed a tracker-id in all created assets via XML comment:
```
<!-- agentic-workflow: WorkflowName, tracker-id: WORKER_ID -->
```

The orchestrator uses this tracker-id to discover worker output by searching issue bodies. This correlation is explicit and does not require workers to be aware of the campaign.

### Idempotency Guarantee

All operations must be idempotent:
- Adding an issue already on the board → No-op (do not duplicate)
- Updating a status that matches current value → No-op (no change recorded)
- Marking a completed campaign as completed → No-op (terminal state preserved)

Re-running the orchestrator produces consistent results regardless of how many times it executes.

### Project Board Integration

Execute state writes using the `update-project` safe-output. All writes must target this exact project URL:

**Project URL**: https://github.com/orgs/githubnext/projects/67

**Campaign ID**: Extract from tracker label `campaign:docs-quality-maintenance-project67` (format: `campaign:CAMPAIGN_ID`)


#### Adding New Issues

When adding an issue to the project board:
```
update-project:
  project: "https://github.com/orgs/githubnext/projects/67"
  item_url: "ISSUE_URL"
  status: "Todo"  # or "Done" if issue is already closed
  campaign_id: "CAMPAIGN_ID"  # Required: extract from tracker label campaign:docs-quality-maintenance-project67
```

**Note**: If your project board has `Start Date` and `End Date` fields, these will be **automatically populated** from the issue/PR timestamps:
- `Start Date` is set from the issue's `createdAt` timestamp
- `End Date` is set from the issue's `closedAt` timestamp (if closed)

No additional configuration is needed. The dates are extracted in ISO format (YYYY-MM-DD) and only populate if the fields exist and aren't already set. This enables roadmap timeline visualization.

**Recommended Custom Fields**: To enable advanced project board features (swimlanes, "Slice by" filtering), populate these fields when available:

```
update-project:
  project: "https://github.com/orgs/githubnext/projects/67"
  item_url: "ISSUE_URL"
  fields:
    status: "Todo"  # or "In Progress", "Blocked", "Done"
    campaign_id: "CAMPAIGN_ID"  # Extract from tracker label campaign:docs-quality-maintenance-project67
    worker_workflow: "WORKFLOW_ID"  # Enables swimlane grouping and filtering
    priority: "High"  # or "Medium", "Low" - enables priority-based views
    effort: "Medium"  # or "Small", "Large" - enables capacity planning
    team: "TEAM_NAME"  # Optional: for team-based grouping
    repository: "REPO_NAME"  # Optional: for cross-repository campaigns
```

**Custom Field Benefits**:
- `worker_workflow`: Groups items by workflow in Roadmap swimlanes; enables "Slice by" filtering in Table views (orchestrator populates this by discovering which worker created the item via tracker-id)
- `priority`: Enables priority-based filtering and sorting
- `effort`: Supports capacity planning and workload distribution
- `team`: Enables team-based grouping for multi-team campaigns
- `repository`: Enables repository-based grouping for cross-repository campaigns

**Worker Workflow Agnosticism**: Worker workflows remain campaign-agnostic. The orchestrator discovers which worker created an item (via tracker-id in the issue body) and populates the `worker_workflow` field. Workers don't need to know about campaigns or custom fields.

Only populate fields that exist on your project board. Field names are case-sensitive and should match exactly as configured in GitHub Projects.

#### Updating Existing Items

When updating status for an existing board item:
```
update-project:
  project: "https://github.com/orgs/githubnext/projects/67"
  item_url: "ISSUE_URL"
  status: "Done"  # or "In Progress", "Todo"
  campaign_id: "CAMPAIGN_ID"  # Required: extract from tracker label campaign:docs-quality-maintenance-project67
```

#### Idempotency

- If an issue is already on the board with matching status → Skip (no-op)
- If an issue is already on the board with different status → Update status field only
- If an issue URL is invalid or deleted → Record failure, continue with remaining items

#### Write Operation Rules

1. **Batch writes separately** - Do not mix reads and writes in the same operation
2. **Validate before writing** - Confirm issue URL exists and is accessible
3. **Record all outcomes** - Log success/failure for each write operation
4. **Never infer state** - Only update based on explicit issue state (open/closed)
5. **Fail gracefully** - If a write fails, record error and continue with remaining operations

### Summary

Execute all four phases in order:
1. **Read State** - Discover worker issues and query project board
2. **Make Decisions** - Determine what to add, update, or mark complete
3. **Write State** - Execute additions and updates via update-project
4. **Report** - Generate status report with execution outcomes

Remember: Workers are immutable and campaign-agnostic. All coordination, sequencing, and state management happens in this orchestrator. The GitHub Project board is the single source of truth for campaign state.
