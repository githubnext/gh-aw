# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Test Safe Output - Create Pull Request Review Comment"
on:
  pull_request:
    types:
    - opened
    - synchronize
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}"
  cancel-in-progress: true

run-name: "Test Safe Output - Create Pull Request Review Comment"

jobs:
  task:
    runs-on: ubuntu-latest
    permissions:
      actions: write  # Required for github.rest.actions.cancelWorkflowRun()
    steps:
      - name: Check team membership for workflow
        id: check-team-member
        uses: actions/github-script@v7
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function setCancelled(message) {
              try {
                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId,
                });
                core.info(`Cancellation requested for this workflow run: ${message}`);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to cancel workflow run: ${errorMessage}`);
                core.setFailed(message); // Fallback if API call fails
              }
            }
            async function main() {
              const { eventName } = context;
              // skip check for safe events
              const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
              if (safeEvents.includes(eventName)) {
                core.info(`✅ Event ${eventName} does not require validation`);
                return;
              }
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
              const requiredPermissions = requiredPermissionsEnv
                ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "")
                : [];
              if (!requiredPermissions || requiredPermissions.length === 0) {
                core.error(
                  "❌ Configuration error: Required permissions not specified. Contact repository administrator."
                );
                await setCancelled(
                  "Configuration error: Required permissions not specified"
                );
                return;
              }
              // Check if the actor has the required repository permissions
              try {
                core.debug(
                  `Checking if user '${actor}' has required permissions for ${owner}/${repo}`
                );
                core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                const repoPermission =
                  await github.rest.repos.getCollaboratorPermissionLevel({
                    owner: owner,
                    repo: repo,
                    username: actor,
                  });
                const permission = repoPermission.data.permission;
                core.debug(`Repository permission level: ${permission}`);
                // Check if user has one of the required permission levels
                for (const requiredPerm of requiredPermissions) {
                  if (
                    permission === requiredPerm ||
                    (requiredPerm === "maintainer" && permission === "maintain")
                  ) {
                    core.info(`✅ User has ${permission} access to repository`);
                    return;
                  }
                }
                core.warning(
                  `User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`
                );
              } catch (repoError) {
                const errorMessage =
                  repoError instanceof Error ? repoError.message : String(repoError);
                core.error(`Repository permission check failed: ${errorMessage}`);
                await setCancelled(`Repository permission check failed: ${errorMessage}`);
                return;
              }
              // Cancel the workflow when permission check fails
              core.warning(
                `❌ Access denied: Only authorized users can trigger this workflow. User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
              await setCancelled(
                `Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
            }
            await main();

  test-safe-output-create-pull-request-review-comment:
    needs: task
    runs-on: ubuntu-latest
    permissions: read-all
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v7
        with:
          script: |
            function main() {
              const fs = require("fs");
              const crypto = require("crypto");
              // Generate a random filename for the output file
              const randomId = crypto.randomBytes(8).toString("hex");
              const outputFile = `/tmp/aw_output_${randomId}.txt`;
              // Ensure the /tmp directory exists
              fs.mkdirSync("/tmp", { recursive: true });
              // We don't create the file, as the name is sufficiently random
              // and some engines (Claude) fails first Write to the file
              // if it exists and has not been read.
              // Set the environment variable for subsequent steps
              core.exportVariable("GITHUB_AW_SAFE_OUTPUTS", outputFile);
              // Also set as step output for reference
              core.setOutput("output_file", outputFile);
            }
            main();
      - name: Setup Safe Outputs
        run: |
          cat >> $GITHUB_ENV << 'EOF'
          GITHUB_AW_SAFE_OUTPUTS_CONFIG={"create-pull-request-review-comment":{"enabled":true,"max":3}}
          EOF
          mkdir -p /tmp/safe-outputs
          cat > /tmp/safe-outputs/mcp-server.cjs << 'EOF'
            const fs = require("fs");
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();
            const configEnv = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
            if (!configEnv) throw new Error("GITHUB_AW_SAFE_OUTPUTS_CONFIG not set");
            const safeOutputsConfig = JSON.parse(configEnv);
            const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
            if (!outputFile) throw new Error("GITHUB_AW_SAFE_OUTPUTS not set");
            const SERVER_INFO = { name: "gh-aw-safe-outputs", version: "1.0.0" };
            function writeMessage(obj) {
              const json = JSON.stringify(obj);
              const bytes = encoder.encode(json);
              const header = `Content-Length: ${bytes.byteLength}\r\n\r\n`;
              const headerBytes = encoder.encode(header);
              fs.writeSync(1, headerBytes);
              fs.writeSync(1, bytes);
            }
            let buffer = Buffer.alloc(0);
            function onData(chunk) {
              buffer = Buffer.concat([buffer, chunk]);
              while (true) {
                const sep = buffer.indexOf("\r\n\r\n");
                if (sep === -1) break;
                const headerPart = buffer.slice(0, sep).toString("utf8");
                const match = headerPart.match(/Content-Length:\s*(\d+)/i);
                if (!match) {
                  buffer = buffer.slice(sep + 4);
                  continue;
                }
                const length = parseInt(match[1], 10);
                const total = sep + 4 + length;
                if (buffer.length < total) break; // wait for full body
                const body = buffer.slice(sep + 4, total);
                buffer = buffer.slice(total);
                try {
                  const msg = JSON.parse(body.toString("utf8"));
                  handleMessage(msg);
                } catch (e) {
                  const err = {
                    jsonrpc: "2.0",
                    id: null,
                    error: { code: -32700, message: "Parse error", data: String(e) },
                  };
                  writeMessage(err);
                }
              }
            }
            process.stdin.on("data", onData);
            process.stdin.on("error", () => { });
            process.stdin.resume();
            function replyResult(id, result) {
              if (id === undefined || id === null) return; // notification
              const res = { jsonrpc: "2.0", id, result };
              writeMessage(res);
            }
            function replyError(id, code, message, data) {
              const res = {
                jsonrpc: "2.0",
                id: id ?? null,
                error: { code, message, data },
              };
              writeMessage(res);
            }
            function normalizeToolName(name) {
              return name.replace(/-/g, "_"); // Convert to kebab-case
            }
            function isToolEnabled(toolType) {
              const name = normalizeToolName(toolType);
              return safeOutputsConfig[name] && safeOutputsConfig[name].enabled;
            }
            function appendSafeOutput(entry) {
              if (!outputFile) {
                throw new Error("No output file configured");
              }
              const jsonLine = JSON.stringify(entry) + "\n";
              try {
                fs.appendFileSync(outputFile, jsonLine);
              } catch (error) {
                throw new Error(
                  `Failed to write to output file: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            }
            const defaultHandler = (type) => async (args) => {
              const entry = { ...(args || {}), type };
              appendSafeOutput(entry);
              return {
                content: [
                  {
                    type: "text",
                    text: `success`,
                  },
                ],
              };
            }
            const TOOLS = Object.fromEntries([{
              name: "create_issue",
              description: "Create a new GitHub issue",
              inputSchema: {
                type: "object",
                required: ["title", "body"],
                properties: {
                  title: { type: "string", description: "Issue title" },
                  body: { type: "string", description: "Issue body/description" },
                  labels: {
                    type: "array",
                    items: { type: "string" },
                    description: "Issue labels",
                  },
                },
                additionalProperties: false,
              }
            }, {
              name: "create_discussion",
              description: "Create a new GitHub discussion",
              inputSchema: {
                type: "object",
                required: ["title", "body"],
                properties: {
                  title: { type: "string", description: "Discussion title" },
                  body: { type: "string", description: "Discussion body/content" },
                  category: { type: "string", description: "Discussion category" },
                },
                additionalProperties: false,
              },
            }, {
              name: "add_issue_comment",
              description: "Add a comment to a GitHub issue or pull request",
              inputSchema: {
                type: "object",
                required: ["body"],
                properties: {
                  body: { type: "string", description: "Comment body/content" },
                  issue_number: {
                    type: "number",
                    description: "Issue or PR number (optional for current context)",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "create_pull_request",
              description: "Create a new GitHub pull request",
              inputSchema: {
                type: "object",
                required: ["title", "body"],
                properties: {
                  title: { type: "string", description: "Pull request title" },
                  body: { type: "string", description: "Pull request body/description" },
                  branch: {
                    type: "string",
                    description:
                      "Optional branch name (will be auto-generated if not provided)",
                  },
                  labels: {
                    type: "array",
                    items: { type: "string" },
                    description: "Optional labels to add to the PR",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "create_pull_request_review_comment",
              description: "Create a review comment on a GitHub pull request",
              inputSchema: {
                type: "object",
                required: ["path", "line", "body"],
                properties: {
                  path: { type: "string", description: "File path for the review comment" },
                  line: {
                    type: ["number", "string"],
                    description: "Line number for the comment",
                  },
                  body: { type: "string", description: "Comment body content" },
                  start_line: {
                    type: ["number", "string"],
                    description: "Optional start line for multi-line comments",
                  },
                  side: {
                    type: "string",
                    enum: ["LEFT", "RIGHT"],
                    description: "Optional side of the diff: LEFT or RIGHT",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "create_code_scanning_alert",
              description: "Create a code scanning alert",
              inputSchema: {
                type: "object",
                required: ["file", "line", "severity", "message"],
                properties: {
                  file: {
                    type: "string",
                    description: "File path where the issue was found",
                  },
                  line: {
                    type: ["number", "string"],
                    description: "Line number where the issue was found",
                  },
                  severity: {
                    type: "string",
                    enum: ["error", "warning", "info", "note"],
                    description: "Severity level",
                  },
                  message: {
                    type: "string",
                    description: "Alert message describing the issue",
                  },
                  column: {
                    type: ["number", "string"],
                    description: "Optional column number",
                  },
                  ruleIdSuffix: {
                    type: "string",
                    description: "Optional rule ID suffix for uniqueness",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "add_issue_label",
              description: "Add labels to a GitHub issue or pull request",
              inputSchema: {
                type: "object",
                required: ["labels"],
                properties: {
                  labels: {
                    type: "array",
                    items: { type: "string" },
                    description: "Labels to add",
                  },
                  issue_number: {
                    type: "number",
                    description: "Issue or PR number (optional for current context)",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "update_issue",
              description: "Update a GitHub issue",
              inputSchema: {
                type: "object",
                properties: {
                  status: {
                    type: "string",
                    enum: ["open", "closed"],
                    description: "Optional new issue status",
                  },
                  title: { type: "string", description: "Optional new issue title" },
                  body: { type: "string", description: "Optional new issue body" },
                  issue_number: {
                    type: ["number", "string"],
                    description: "Optional issue number for target '*'",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "push_to_pr_branch",
              description: "Push changes to a pull request branch",
              inputSchema: {
                type: "object",
                properties: {
                  message: { type: "string", description: "Optional commit message" },
                  pull_request_number: {
                    type: ["number", "string"],
                    description: "Optional pull request number for target '*'",
                  },
                },
                additionalProperties: false,
              },
            }, {
              name: "missing_tool",
              description:
                "Report a missing tool or functionality needed to complete tasks",
              inputSchema: {
                type: "object",
                required: ["tool", "reason"],
                properties: {
                  tool: { type: "string", description: "Name of the missing tool" },
                  reason: { type: "string", description: "Why this tool is needed" },
                  alternatives: {
                    type: "string",
                    description: "Possible alternatives or workarounds",
                  },
                },
                additionalProperties: false,
              },
            }].filter(({ name }) => isToolEnabled(name)).map(tool => [tool.name, tool]));
            if (!TOOLS.length) throw new Error("No tools enabled in configuration");
            function handleMessage(req) {
              const { id, method, params } = req;
              try {
                if (method === "initialize") {
                  const clientInfo = params?.clientInfo ?? {};
                  console.error(`client initialized:`, clientInfo);
                  const protocolVersion = params?.protocolVersion ?? undefined;
                  const result = {
                    serverInfo: SERVER_INFO,
                    ...(protocolVersion ? { protocolVersion } : {}),
                    capabilities: {
                      tools: {},
                    },
                  };
                  replyResult(id, result);
                }
                else if (method === "tools/list") {
                  const list = [];
                  Object.values(TOOLS).forEach(tool => {
                    const toolType = tool.name.replace(/_/g, "-"); // Convert to kebab-case
                    if (isToolEnabled(toolType)) {
                      list.push({
                        name: tool.name,
                        description: tool.description,
                        inputSchema: tool.inputSchema,
                      });
                    }
                  });
                  replyResult(id, { tools: list });
                }
                else if (method === "tools/call") {
                  const name = params?.name;
                  const args = params?.arguments ?? {};
                  if (!name || typeof name !== "string") {
                    replyError(id, -32602, "Invalid params: 'name' must be a string");
                    return;
                  }
                  const toolName = normalizeToolName(name);
                  const tool = TOOLS[toolName];
                  if (!tool) {
                    replyError(id, -32601, `Tool not found: ${toolName}`);
                    return;
                  }
                  const handler = tool.handler || defaultHandler(tool.name);
                  (async () => {
                    try {
                      const result = await handler(args);
                      replyResult(id, { content: result.content });
                    } catch (e) {
                      replyError(id, -32000, `Tool '${name}' failed`, {
                        message: e instanceof Error ? e.message : String(e),
                      });
                    }
                  })();
                  return;
                }
                replyError(id, -32601, `Method not found: ${method}`);
              } catch (e) {
                replyError(id, -32603, "Internal error", {
                  message: e instanceof Error ? e.message : String(e),
                });
              }
            }
            process.stderr.write(
              `[${SERVER_INFO.name}] v${SERVER_INFO.version} ready on stdio\n`
            );
            process.stderr.write(`[${SERVER_INFO.name}]  output file: ${outputFile}\n`)
            process.stderr.write(`[${SERVER_INFO.name}]  config: ${safeOutputsConfig}\n`)
            process.stderr.write(`[${SERVER_INFO.name}]  tools: ${Object.keys(TOOLS).join(", ")}\n`)
          EOF
          chmod +x /tmp/safe-outputs/mcp-server.cjs
          
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "safe_outputs": {
                "command": "node",
                "args": ["/tmp/safe-outputs/mcp-server.cjs"]
                "env": {
                  "GITHUB_AW_SAFE_OUTPUTS": "${{ env.GITHUB_AW_SAFE_OUTPUTS }}"
                  "GITHUB_AW_SAFE_OUTPUTS_CONFIG": "${{ env.GITHUB_AW_SAFE_OUTPUTS_CONFIG }}"
                }
              },
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-09deac4"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              }
            }
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Test Safe Output - Create Pull Request Review Comment
          
          This workflow tests the `create-pull-request-review-comment` safe output functionality using a custom engine that directly writes to the safe output file.
          
          ## Purpose
          
          This workflow validates the create-pull-request-review-comment safe output type by:
          - Generating JSON entries with the `create-pull-request-review-comment` type
          - Including all required fields: path, line, body
          - Testing both single-line and multi-line review comments
          - Using staged mode to prevent actual GitHub interactions
          - Demonstrating custom engine safe output writing for PR review comments
          
          ## Trigger Events
          
          - **workflow_dispatch**: Manual execution for testing
          - **pull_request.opened**: Responds to new pull requests being created
          - **pull_request.synchronize**: Responds to PR updates
          
          ## Safe Output Configuration
          
          - **staged: true**: Prevents real GitHub interactions
          - **max: 3**: Allows up to 3 review comments per workflow run
          - **side: "RIGHT"**: Comments target the new version of files (default behavior)
          
          ## Custom Engine Implementation
          
          The workflow uses a custom engine with GitHub Actions steps to:
          1. Generate multiple review comment JSON outputs for testing
          2. Test both single-line and multi-line comments (using start_line)
          3. Include comprehensive review information
          4. Target different files (README.md and package.json)
          5. Append entries to the $GITHUB_AW_SAFE_OUTPUTS file
          6. Verify the outputs were generated correctly
          
          This demonstrates how custom engines can leverage the safe output system for creating line-specific review comments on pull requests, enabling detailed code feedback.
          
          
          ---
          
          ## Reporting Missing Tools or Functionality
          
          **IMPORTANT**: To do the actions mentioned in the header of this section, use the **safe-outputs** tools, do NOT attempt to use `gh`, do NOT attempt to use the GitHub API. You don't have write access to the GitHub repo.
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "custom",
              engine_name: "Custom Steps",
              model: "",
              version: "",
              workflow_name: "Test Safe Output - Create Pull Request Review Comment",
              experimental: false,
              supports_tools_whitelist: false,
              supports_http_transport: false,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: true,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Generate PR Review Comment Safe Output
        run: |
          echo '{"type": "create-pull-request-review-comment", "path": "README.md", "line": 1, "body": "## Custom Engine Review Comment Test\n\nThis review comment was automatically created by the test-safe-output-create-pull-request-review-comment workflow to validate the create-pull-request-review-comment safe output functionality.\n\n**Review Details:**\n- Safe Output Type: create-pull-request-review-comment\n- Generated by: Custom Engine\n- Test time: '"$(date)"'\n- Workflow: test-safe-output-create-pull-request-review-comment\n- Event: ${{ github.event_name }}\n- Staged Mode: true\n\n✅ PR review comment safe output test completed.\n\nThis comment should not appear in actual pull requests due to staged mode."}' >> $GITHUB_AW_SAFE_OUTPUTS

          # Generate a second review comment to test multi-line comments
          echo '{"type": "create-pull-request-review-comment", "path": "package.json", "line": 5, "start_line": 3, "body": "### Multi-line Review Comment Test\n\nThis is a test of multi-line review comments using start_line and line properties.\n\n**Test Information:**\n- Lines: 3-5\n- File: package.json\n- Purpose: Validate multi-line comment functionality\n- Staged: true (no actual API calls)", "side": "RIGHT"}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
      - name: Verify Safe Output File
        run: |
          echo "Generated safe output entries:"
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            cat "$GITHUB_AW_SAFE_OUTPUTS"
          else
            echo "No safe outputs file found"
          fi
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
      - name: Ensure log file exists
        run: |
          echo "Custom steps execution completed" >> /tmp/test-safe-output-create-pull-request-review-comment.log
          touch /tmp/test-safe-output-create-pull-request-review-comment.log
      - name: Print Agent output
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Agent Output (JSONL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
          # Ensure there's a newline after the file content if it doesn't end with one
          if [ -s ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ] && [ "$(tail -c1 ${{ env.GITHUB_AW_SAFE_OUTPUTS }})" != "" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo '``````' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      - name: Upload agentic output file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe_output.jsonl
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Ingest agent output
        id: collect_output
        uses: actions/github-script@v7
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-pull-request-review-comment\":{\"enabled\":true,\"max\":3}}"
        with:
          script: |
            async function main() {
              const fs = require("fs");
              /**
               * Sanitizes content for safe output in GitHub Actions
               * @param {string} content - The content to sanitize
               * @returns {string} The sanitized content
               */
              function sanitizeContent(content) {
                if (!content || typeof content !== "string") {
                  return "";
                }
                // Read allowed domains from environment variable
                const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
                const defaultAllowedDomains = [
                  "github.com",
                  "github.io",
                  "githubusercontent.com",
                  "githubassets.com",
                  "github.dev",
                  "codespaces.new",
                ];
                const allowedDomains = allowedDomainsEnv
                  ? allowedDomainsEnv
                      .split(",")
                      .map(d => d.trim())
                      .filter(d => d)
                  : defaultAllowedDomains;
                let sanitized = content;
                // Neutralize @mentions to prevent unintended notifications
                sanitized = neutralizeMentions(sanitized);
                // Remove control characters (except newlines and tabs)
                sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
                // XML character escaping
                sanitized = sanitized
                  .replace(/&/g, "&amp;") // Must be first to avoid double-escaping
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&apos;");
                // URI filtering - replace non-https protocols with "(redacted)"
                sanitized = sanitizeUrlProtocols(sanitized);
                // Domain filtering for HTTPS URIs
                sanitized = sanitizeUrlDomains(sanitized);
                // Limit total length to prevent DoS (0.5MB max)
                const maxLength = 524288;
                if (sanitized.length > maxLength) {
                  sanitized =
                    sanitized.substring(0, maxLength) +
                    "\n[Content truncated due to length]";
                }
                // Limit number of lines to prevent log flooding (65k max)
                const lines = sanitized.split("\n");
                const maxLines = 65000;
                if (lines.length > maxLines) {
                  sanitized =
                    lines.slice(0, maxLines).join("\n") +
                    "\n[Content truncated due to line count]";
                }
                // Remove ANSI escape sequences
                sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
                // Neutralize common bot trigger phrases
                sanitized = neutralizeBotTriggers(sanitized);
                // Trim excessive whitespace
                return sanitized.trim();
                /**
                 * Remove unknown domains
                 * @param {string} s - The string to process
                 * @returns {string} The string with unknown domains redacted
                 */
                function sanitizeUrlDomains(s) {
                  return s.replace(
                    /\bhttps:\/\/([^\/\s\])}'"<>&\x00-\x1f]+)/gi,
                    (match, domain) => {
                      // Extract the hostname part (before first slash, colon, or other delimiter)
                      const hostname = domain.split(/[\/:\?#]/)[0].toLowerCase();
                      // Check if this domain or any parent domain is in the allowlist
                      const isAllowed = allowedDomains.some(allowedDomain => {
                        const normalizedAllowed = allowedDomain.toLowerCase();
                        return (
                          hostname === normalizedAllowed ||
                          hostname.endsWith("." + normalizedAllowed)
                        );
                      });
                      return isAllowed ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Remove unknown protocols except https
                 * @param {string} s - The string to process
                 * @returns {string} The string with non-https protocols redacted
                 */
                function sanitizeUrlProtocols(s) {
                  // Match both protocol:// and protocol: patterns
                  return s.replace(
                    /\b(\w+):(?:\/\/)?[^\s\])}'"<>&\x00-\x1f]+/gi,
                    (match, protocol) => {
                      // Allow https (case insensitive), redact everything else
                      return protocol.toLowerCase() === "https" ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Neutralizes @mentions by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized mentions
                 */
                function neutralizeMentions(s) {
                  // Replace @name or @org/team outside code with `@name`
                  return s.replace(
                    /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                    (_m, p1, p2) => `${p1}\`@${p2}\``
                  );
                }
                /**
                 * Neutralizes bot trigger phrases by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized bot triggers
                 */
                function neutralizeBotTriggers(s) {
                  // Neutralize common bot trigger phrases like "fixes #123", "closes #asdfs", etc.
                  return s.replace(
                    /\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi,
                    (match, action, ref) => `\`${action} #${ref}\``
                  );
                }
              }
              /**
               * Gets the maximum allowed count for a given output type
               * @param {string} itemType - The output item type
               * @param {any} config - The safe-outputs configuration
               * @returns {number} The maximum allowed count
               */
              function getMaxAllowedForType(itemType, config) {
                // Check if max is explicitly specified in config
                if (
                  config &&
                  config[itemType] &&
                  typeof config[itemType] === "object" &&
                  config[itemType].max
                ) {
                  return config[itemType].max;
                }
                // Use default limits for plural-supported types
                switch (itemType) {
                  case "create-issue":
                    return 1; // Only one issue allowed
                  case "add-issue-comment":
                    return 1; // Only one comment allowed
                  case "create-pull-request":
                    return 1; // Only one pull request allowed
                  case "create-pull-request-review-comment":
                    return 10; // Default to 10 review comments allowed
                  case "add-issue-label":
                    return 5; // Only one labels operation allowed
                  case "update-issue":
                    return 1; // Only one issue update allowed
                  case "push-to-pr-branch":
                    return 1; // Only one push to branch allowed
                  case "create-discussion":
                    return 1; // Only one discussion allowed
                  case "missing-tool":
                    return 1000; // Allow many missing tool reports (default: unlimited)
                  case "create-code-scanning-alert":
                    return 1000; // Allow many repository security advisories (default: unlimited)
                  default:
                    return 1; // Default to single item for unknown types
                }
              }
              /**
               * Attempts to repair common JSON syntax issues in LLM-generated content
               * @param {string} jsonStr - The potentially malformed JSON string
               * @returns {string} The repaired JSON string
               */
              function repairJson(jsonStr) {
                let repaired = jsonStr.trim();
                // remove invalid control characters like
                // U+0014 (DC4) — represented here as "\u0014"
                // Escape control characters not allowed in JSON strings (U+0000 through U+001F)
                // Preserve common JSON escapes for \b, \f, \n, \r, \t and use \uXXXX for the rest.
                /** @type {Record<number, string>} */
                const _ctrl = { 8: "\\b", 9: "\\t", 10: "\\n", 12: "\\f", 13: "\\r" };
                repaired = repaired.replace(/[\u0000-\u001F]/g, ch => {
                  const c = ch.charCodeAt(0);
                  return _ctrl[c] || "\\u" + c.toString(16).padStart(4, "0");
                });
                // Fix single quotes to double quotes (must be done first)
                repaired = repaired.replace(/'/g, '"');
                // Fix missing quotes around object keys
                repaired = repaired.replace(
                  /([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g,
                  '$1"$2":'
                );
                // Fix newlines and tabs inside strings by escaping them
                repaired = repaired.replace(/"([^"\\]*)"/g, (match, content) => {
                  if (
                    content.includes("\n") ||
                    content.includes("\r") ||
                    content.includes("\t")
                  ) {
                    const escaped = content
                      .replace(/\\/g, "\\\\")
                      .replace(/\n/g, "\\n")
                      .replace(/\r/g, "\\r")
                      .replace(/\t/g, "\\t");
                    return `"${escaped}"`;
                  }
                  return match;
                });
                // Fix unescaped quotes inside string values
                repaired = repaired.replace(
                  /"([^"]*)"([^":,}\]]*)"([^"]*)"(\s*[,:}\]])/g,
                  (match, p1, p2, p3, p4) => `"${p1}\\"${p2}\\"${p3}"${p4}`
                );
                // Fix wrong bracket/brace types - arrays should end with ] not }
                repaired = repaired.replace(
                  /(\[\s*(?:"[^"]*"(?:\s*,\s*"[^"]*")*\s*),?)\s*}/g,
                  "$1]"
                );
                // Fix missing closing braces/brackets
                const openBraces = (repaired.match(/\{/g) || []).length;
                const closeBraces = (repaired.match(/\}/g) || []).length;
                if (openBraces > closeBraces) {
                  repaired += "}".repeat(openBraces - closeBraces);
                } else if (closeBraces > openBraces) {
                  repaired = "{".repeat(closeBraces - openBraces) + repaired;
                }
                // Fix missing closing brackets for arrays
                const openBrackets = (repaired.match(/\[/g) || []).length;
                const closeBrackets = (repaired.match(/\]/g) || []).length;
                if (openBrackets > closeBrackets) {
                  repaired += "]".repeat(openBrackets - closeBrackets);
                } else if (closeBrackets > openBrackets) {
                  repaired = "[".repeat(closeBrackets - openBrackets) + repaired;
                }
                // Fix trailing commas in objects and arrays (AFTER fixing brackets/braces)
                repaired = repaired.replace(/,(\s*[}\]])/g, "$1");
                return repaired;
              }
              /**
               * Attempts to parse JSON with repair fallback
               * @param {string} jsonStr - The JSON string to parse
               * @returns {Object|undefined} The parsed JSON object, or undefined if parsing fails
               */
              function parseJsonWithRepair(jsonStr) {
                try {
                  // First, try normal JSON.parse
                  return JSON.parse(jsonStr);
                } catch (originalError) {
                  try {
                    // If that fails, try repairing and parsing again
                    const repairedJson = repairJson(jsonStr);
                    return JSON.parse(repairedJson);
                  } catch (repairError) {
                    // If repair also fails, throw the error
                    core.info(`invalid input json: ${jsonStr}`);
                    const originalMsg =
                      originalError instanceof Error
                        ? originalError.message
                        : String(originalError);
                    const repairMsg =
                      repairError instanceof Error
                        ? repairError.message
                        : String(repairError);
                    throw new Error(
                      `JSON parsing failed. Original: ${originalMsg}. After attempted repair: ${repairMsg}`
                    );
                  }
                }
              }
              const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              const safeOutputsConfig = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
              if (!outputFile) {
                core.info("GITHUB_AW_SAFE_OUTPUTS not set, no output to collect");
                core.setOutput("output", "");
                return;
              }
              if (!fs.existsSync(outputFile)) {
                core.info(`Output file does not exist: ${outputFile}`);
                core.setOutput("output", "");
                return;
              }
              const outputContent = fs.readFileSync(outputFile, "utf8");
              if (outputContent.trim() === "") {
                core.info("Output file is empty");
                core.setOutput("output", "");
                return;
              }
              core.info(`Raw output content length: ${outputContent.length}`);
              // Parse the safe-outputs configuration
              /** @type {any} */
              let expectedOutputTypes = {};
              if (safeOutputsConfig) {
                try {
                  expectedOutputTypes = JSON.parse(safeOutputsConfig);
                  core.info(
                    `Expected output types: ${JSON.stringify(Object.keys(expectedOutputTypes))}`
                  );
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  core.info(`Warning: Could not parse safe-outputs config: ${errorMsg}`);
                }
              }
              // Parse JSONL content
              const lines = outputContent.trim().split("\n");
              const parsedItems = [];
              const errors = [];
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue; // Skip empty lines
                try {
                  /** @type {any} */
                  const item = parseJsonWithRepair(line);
                  // If item is undefined (failed to parse), add error and process next line
                  if (item === undefined) {
                    errors.push(`Line ${i + 1}: Invalid JSON - JSON parsing failed`);
                    continue;
                  }
                  // Validate that the item has a 'type' field
                  if (!item.type) {
                    errors.push(`Line ${i + 1}: Missing required 'type' field`);
                    continue;
                  }
                  // Validate against expected output types
                  const itemType = item.type;
                  if (!expectedOutputTypes[itemType]) {
                    errors.push(
                      `Line ${i + 1}: Unexpected output type '${itemType}'. Expected one of: ${Object.keys(expectedOutputTypes).join(", ")}`
                    );
                    continue;
                  }
                  // Check for too many items of the same type
                  const typeCount = parsedItems.filter(
                    existing => existing.type === itemType
                  ).length;
                  const maxAllowed = getMaxAllowedForType(itemType, expectedOutputTypes);
                  if (typeCount >= maxAllowed) {
                    errors.push(
                      `Line ${i + 1}: Too many items of type '${itemType}'. Maximum allowed: ${maxAllowed}.`
                    );
                    continue;
                  }
                  // Basic validation based on type
                  switch (itemType) {
                    case "create-issue":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-issue-comment":
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: add-issue-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.body = sanitizeContent(item.body);
                      break;
                    case "create-pull-request":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize branch name if present
                      if (item.branch && typeof item.branch === "string") {
                        item.branch = sanitizeContent(item.branch);
                      }
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-issue-label":
                      if (!item.labels || !Array.isArray(item.labels)) {
                        errors.push(
                          `Line ${i + 1}: add-issue-label requires a 'labels' array field`
                        );
                        continue;
                      }
                      if (
                        item.labels.some(
                          /** @param {any} label */ label => typeof label !== "string"
                        )
                      ) {
                        errors.push(
                          `Line ${i + 1}: add-issue-label labels array must contain only strings`
                        );
                        continue;
                      }
                      // Sanitize label strings
                      item.labels = item.labels.map(
                        /** @param {any} label */ label => sanitizeContent(label)
                      );
                      break;
                    case "update-issue":
                      // Check that at least one updateable field is provided
                      const hasValidField =
                        item.status !== undefined ||
                        item.title !== undefined ||
                        item.body !== undefined;
                      if (!hasValidField) {
                        errors.push(
                          `Line ${i + 1}: update-issue requires at least one of: 'status', 'title', or 'body' fields`
                        );
                        continue;
                      }
                      // Validate status if provided
                      if (item.status !== undefined) {
                        if (
                          typeof item.status !== "string" ||
                          (item.status !== "open" && item.status !== "closed")
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'status' must be 'open' or 'closed'`
                          );
                          continue;
                        }
                      }
                      // Validate title if provided
                      if (item.title !== undefined) {
                        if (typeof item.title !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'title' must be a string`
                          );
                          continue;
                        }
                        item.title = sanitizeContent(item.title);
                      }
                      // Validate body if provided
                      if (item.body !== undefined) {
                        if (typeof item.body !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'body' must be a string`
                          );
                          continue;
                        }
                        item.body = sanitizeContent(item.body);
                      }
                      // Validate issue_number if provided (for target "*")
                      if (item.issue_number !== undefined) {
                        if (
                          typeof item.issue_number !== "number" &&
                          typeof item.issue_number !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'issue_number' must be a number or string`
                          );
                          continue;
                        }
                      }
                      break;
                    case "push-to-pr-branch":
                      // Validate message if provided (optional)
                      if (item.message !== undefined) {
                        if (typeof item.message !== "string") {
                          errors.push(
                            `Line ${i + 1}: push-to-pr-branch 'message' must be a string`
                          );
                          continue;
                        }
                        item.message = sanitizeContent(item.message);
                      }
                      // Validate pull_request_number if provided (for target "*")
                      if (item.pull_request_number !== undefined) {
                        if (
                          typeof item.pull_request_number !== "number" &&
                          typeof item.pull_request_number !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: push-to-pr-branch 'pull_request_number' must be a number or string`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-pull-request-review-comment":
                      // Validate required path field
                      if (!item.path || typeof item.path !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'path' string field`
                        );
                        continue;
                      }
                      // Validate required line field
                      if (
                        item.line === undefined ||
                        (typeof item.line !== "number" && typeof item.line !== "string")
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'line' number or string field`
                        );
                        continue;
                      }
                      // Validate line is a positive integer
                      const lineNumber =
                        typeof item.line === "string" ? parseInt(item.line, 10) : item.line;
                      if (
                        isNaN(lineNumber) ||
                        lineNumber <= 0 ||
                        !Number.isInteger(lineNumber)
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment 'line' must be a positive integer`
                        );
                        continue;
                      }
                      // Validate required body field
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize required text content
                      item.body = sanitizeContent(item.body);
                      // Validate optional start_line field
                      if (item.start_line !== undefined) {
                        if (
                          typeof item.start_line !== "number" &&
                          typeof item.start_line !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be a number or string`
                          );
                          continue;
                        }
                        const startLineNumber =
                          typeof item.start_line === "string"
                            ? parseInt(item.start_line, 10)
                            : item.start_line;
                        if (
                          isNaN(startLineNumber) ||
                          startLineNumber <= 0 ||
                          !Number.isInteger(startLineNumber)
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be a positive integer`
                          );
                          continue;
                        }
                        if (startLineNumber > lineNumber) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be less than or equal to 'line'`
                          );
                          continue;
                        }
                      }
                      // Validate optional side field
                      if (item.side !== undefined) {
                        if (
                          typeof item.side !== "string" ||
                          (item.side !== "LEFT" && item.side !== "RIGHT")
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'side' must be 'LEFT' or 'RIGHT'`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-discussion":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      break;
                    case "missing-tool":
                      // Validate required tool field
                      if (!item.tool || typeof item.tool !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'tool' string field`
                        );
                        continue;
                      }
                      // Validate required reason field
                      if (!item.reason || typeof item.reason !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'reason' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.tool = sanitizeContent(item.tool);
                      item.reason = sanitizeContent(item.reason);
                      // Validate optional alternatives field
                      if (item.alternatives !== undefined) {
                        if (typeof item.alternatives !== "string") {
                          errors.push(
                            `Line ${i + 1}: missing-tool 'alternatives' must be a string`
                          );
                          continue;
                        }
                        item.alternatives = sanitizeContent(item.alternatives);
                      }
                      break;
                    case "create-code-scanning-alert":
                      // Validate required fields
                      if (!item.file || typeof item.file !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'file' field (string)`
                        );
                        continue;
                      }
                      if (
                        item.line === undefined ||
                        item.line === null ||
                        (typeof item.line !== "number" && typeof item.line !== "string")
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'line' field (number or string)`
                        );
                        continue;
                      }
                      // Additional validation: line must be parseable as a positive integer
                      const parsedLine = parseInt(item.line, 10);
                      if (isNaN(parsedLine) || parsedLine <= 0) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'line' must be a valid positive integer (got: ${item.line})`
                        );
                        continue;
                      }
                      if (!item.severity || typeof item.severity !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'severity' field (string)`
                        );
                        continue;
                      }
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'message' field (string)`
                        );
                        continue;
                      }
                      // Validate severity level
                      const allowedSeverities = ["error", "warning", "info", "note"];
                      if (!allowedSeverities.includes(item.severity.toLowerCase())) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'severity' must be one of: ${allowedSeverities.join(", ")}`
                        );
                        continue;
                      }
                      // Validate optional column field
                      if (item.column !== undefined) {
                        if (
                          typeof item.column !== "number" &&
                          typeof item.column !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'column' must be a number or string`
                          );
                          continue;
                        }
                        // Additional validation: must be parseable as a positive integer
                        const parsedColumn = parseInt(item.column, 10);
                        if (isNaN(parsedColumn) || parsedColumn <= 0) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'column' must be a valid positive integer (got: ${item.column})`
                          );
                          continue;
                        }
                      }
                      // Validate optional ruleIdSuffix field
                      if (item.ruleIdSuffix !== undefined) {
                        if (typeof item.ruleIdSuffix !== "string") {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must be a string`
                          );
                          continue;
                        }
                        if (!/^[a-zA-Z0-9_-]+$/.test(item.ruleIdSuffix.trim())) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must contain only alphanumeric characters, hyphens, and underscores`
                          );
                          continue;
                        }
                      }
                      // Normalize severity to lowercase and sanitize string fields
                      item.severity = item.severity.toLowerCase();
                      item.file = sanitizeContent(item.file);
                      item.severity = sanitizeContent(item.severity);
                      item.message = sanitizeContent(item.message);
                      if (item.ruleIdSuffix) {
                        item.ruleIdSuffix = sanitizeContent(item.ruleIdSuffix);
                      }
                      break;
                    default:
                      errors.push(`Line ${i + 1}: Unknown output type '${itemType}'`);
                      continue;
                  }
                  core.info(`Line ${i + 1}: Valid ${itemType} item`);
                  parsedItems.push(item);
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  errors.push(`Line ${i + 1}: Invalid JSON - ${errorMsg}`);
                }
              }
              // Report validation results
              if (errors.length > 0) {
                core.warning("Validation errors found:");
                errors.forEach(error => core.warning(`  - ${error}`));
                if (parsedItems.length === 0) {
                  core.setFailed(errors.map(e => `  - ${e}`).join("\n"));
                  return;
                }
                // For now, we'll continue with valid items but log the errors
                // In the future, we might want to fail the workflow for invalid items
              }
              core.info(`Successfully parsed ${parsedItems.length} valid output items`);
              // Set the parsed and validated items as output
              const validatedOutput = {
                items: parsedItems,
                errors: errors,
              };
              // Store validatedOutput JSON in "agent_output.json" file
              const agentOutputFile = "/tmp/agent_output.json";
              const validatedOutputJson = JSON.stringify(validatedOutput);
              try {
                // Ensure the /tmp directory exists
                fs.mkdirSync("/tmp", { recursive: true });
                fs.writeFileSync(agentOutputFile, validatedOutputJson, "utf8");
                core.info(`Stored validated output to: ${agentOutputFile}`);
                // Set the environment variable GITHUB_AW_AGENT_OUTPUT to the file path
                core.exportVariable("GITHUB_AW_AGENT_OUTPUT", agentOutputFile);
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.error(`Failed to write agent output file: ${errorMsg}`);
              }
              core.setOutput("output", JSON.stringify(validatedOutput));
              core.setOutput("raw_output", outputContent);
            }
            // Call the main function
            await main();
      - name: Print sanitized agent output
        run: |
          echo "## Processed Output" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.collect_output.outputs.output }}' >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Upload sanitized agent output
        if: always() && env.GITHUB_AW_AGENT_OUTPUT
        uses: actions/upload-artifact@v4
        with:
          name: agent_output.json
          path: ${{ env.GITHUB_AW_AGENT_OUTPUT }}
          if-no-files-found: warn
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-safe-output-create-pull-request-review-comment.log
          path: /tmp/test-safe-output-create-pull-request-review-comment.log
          if-no-files-found: warn

  create_pr_review_comment:
    needs: test-safe-output-create-pull-request-review-comment
    if: (github.event.issue.number && github.event.issue.pull_request) || github.event.pull_request
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    timeout-minutes: 10
    outputs:
      review_comment_id: ${{ steps.create_pr_review_comment.outputs.review_comment_id }}
      review_comment_url: ${{ steps.create_pr_review_comment.outputs.review_comment_url }}
    steps:
      - name: Create PR Review Comment
        id: create_pr_review_comment
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-output-create-pull-request-review-comment.outputs.output }}
          GITHUB_AW_PR_REVIEW_COMMENT_SIDE: "RIGHT"
        with:
          script: |
            async function main() {
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find all create-pull-request-review-comment items
              const reviewCommentItems = validatedOutput.items.filter(
                /** @param {any} item */ item =>
                  item.type === "create-pull-request-review-comment"
              );
              if (reviewCommentItems.length === 0) {
                core.info(
                  "No create-pull-request-review-comment items found in agent output"
                );
                return;
              }
              core.info(
                `Found ${reviewCommentItems.length} create-pull-request-review-comment item(s)`
              );
              // If in staged mode, emit step summary instead of creating review comments
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent =
                  "## 🎭 Staged Mode: Create PR Review Comments Preview\n\n";
                summaryContent +=
                  "The following review comments would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < reviewCommentItems.length; i++) {
                  const item = reviewCommentItems[i];
                  summaryContent += `### Review Comment ${i + 1}\n`;
                  summaryContent += `**File:** ${item.path || "No path provided"}\n\n`;
                  summaryContent += `**Line:** ${item.line || "No line provided"}\n\n`;
                  if (item.start_line) {
                    summaryContent += `**Start Line:** ${item.start_line}\n\n`;
                  }
                  summaryContent += `**Side:** ${item.side || "RIGHT"}\n\n`;
                  summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 PR review comment creation preview written to step summary");
                return;
              }
              // Get the side configuration from environment variable
              const defaultSide = process.env.GITHUB_AW_PR_REVIEW_COMMENT_SIDE || "RIGHT";
              core.info(`Default comment side configuration: ${defaultSide}`);
              // Check if we're in a pull request context, or an issue comment context on a PR
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment" ||
                (context.eventName === "issue_comment" &&
                  context.payload.issue &&
                  context.payload.issue.pull_request);
              if (!isPRContext) {
                core.info(
                  "Not running in pull request context, skipping review comment creation"
                );
                return;
              }
              let pullRequest = context.payload.pull_request;
              if (!pullRequest) {
                //No, github.event.issue.pull_request does not contain the full pull request data like head.sha. It only includes a minimal object with a url pointing to the pull request API resource.
                //To get full PR details (like head.sha, base.ref, etc.), you need to make an API call using that URL.
                if (context.payload.issue && context.payload.issue.pull_request) {
                  // Fetch full pull request details using the GitHub API
                  const prUrl = context.payload.issue.pull_request.url;
                  try {
                    const { data: fullPR } = await github.request(`GET ${prUrl}`, {
                      headers: {
                        Accept: "application/vnd.github+json",
                      },
                    });
                    pullRequest = fullPR;
                    core.info("Fetched full pull request details from API");
                  } catch (error) {
                    core.info(
                      `Failed to fetch full pull request details: ${error instanceof Error ? error.message : String(error)}`
                    );
                    return;
                  }
                } else {
                  core.info(
                    "Pull request data not found in payload - cannot create review comments"
                  );
                  return;
                }
              }
              // Check if we have the commit SHA needed for creating review comments
              if (!pullRequest || !pullRequest.head || !pullRequest.head.sha) {
                core.info(
                  "Pull request head commit SHA not found in payload - cannot create review comments"
                );
                return;
              }
              const pullRequestNumber = pullRequest.number;
              core.info(`Creating review comments on PR #${pullRequestNumber}`);
              const createdComments = [];
              // Process each review comment item
              for (let i = 0; i < reviewCommentItems.length; i++) {
                const commentItem = reviewCommentItems[i];
                core.info(
                  `Processing create-pull-request-review-comment item ${i + 1}/${reviewCommentItems.length}: bodyLength=${commentItem.body ? commentItem.body.length : "undefined"}, path=${commentItem.path}, line=${commentItem.line}, startLine=${commentItem.start_line}`
                );
                // Validate required fields
                if (!commentItem.path) {
                  core.info('Missing required field "path" in review comment item');
                  continue;
                }
                if (
                  !commentItem.line ||
                  (typeof commentItem.line !== "number" &&
                    typeof commentItem.line !== "string")
                ) {
                  core.info(
                    'Missing or invalid required field "line" in review comment item'
                  );
                  continue;
                }
                if (!commentItem.body || typeof commentItem.body !== "string") {
                  core.info(
                    'Missing or invalid required field "body" in review comment item'
                  );
                  continue;
                }
                // Parse line numbers
                const line = parseInt(commentItem.line, 10);
                if (isNaN(line) || line <= 0) {
                  core.info(`Invalid line number: ${commentItem.line}`);
                  continue;
                }
                let startLine = undefined;
                if (commentItem.start_line) {
                  startLine = parseInt(commentItem.start_line, 10);
                  if (isNaN(startLine) || startLine <= 0 || startLine > line) {
                    core.info(
                      `Invalid start_line number: ${commentItem.start_line} (must be <= line: ${line})`
                    );
                    continue;
                  }
                }
                // Determine side (LEFT or RIGHT)
                const side = commentItem.side || defaultSide;
                if (side !== "LEFT" && side !== "RIGHT") {
                  core.info(`Invalid side value: ${side} (must be LEFT or RIGHT)`);
                  continue;
                }
                // Extract body from the JSON item
                let body = commentItem.body.trim();
                // Add AI disclaimer with run id, run htmlurl
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                body += `\n\n> Generated by Agentic Workflow [Run](${runUrl})\n`;
                core.info(
                  `Creating review comment on PR #${pullRequestNumber} at ${commentItem.path}:${line}${startLine ? ` (lines ${startLine}-${line})` : ""} [${side}]`
                );
                core.info(`Comment content length: ${body.length}`);
                try {
                  // Prepare the request parameters
                  /** @type {any} */
                  const requestParams = {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pullRequestNumber,
                    body: body,
                    path: commentItem.path,
                    commit_id: pullRequest && pullRequest.head ? pullRequest.head.sha : "", // Required for creating review comments
                    line: line,
                    side: side,
                  };
                  // Add start_line for multi-line comments
                  if (startLine !== undefined) {
                    requestParams.start_line = startLine;
                    requestParams.start_side = side; // start_side should match side for consistency
                  }
                  // Create the review comment using GitHub API
                  const { data: comment } =
                    await github.rest.pulls.createReviewComment(requestParams);
                  core.info(
                    "Created review comment #" + comment.id + ": " + comment.html_url
                  );
                  createdComments.push(comment);
                  // Set output for the last created comment (for backward compatibility)
                  if (i === reviewCommentItems.length - 1) {
                    core.setOutput("review_comment_id", comment.id);
                    core.setOutput("review_comment_url", comment.html_url);
                  }
                } catch (error) {
                  core.error(
                    `✗ Failed to create review comment: ${error instanceof Error ? error.message : String(error)}`
                  );
                  throw error;
                }
              }
              // Write summary for all created comments
              if (createdComments.length > 0) {
                let summaryContent = "\n\n## GitHub PR Review Comments\n";
                for (const comment of createdComments) {
                  summaryContent += `- Review Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdComments.length} review comment(s)`);
              return createdComments;
            }
            await main();

