---
name: "Security Alert Burndown"
description: "Systematically burns down code security alerts with focus on file write issues"
on:
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch:
concurrency:
  group: "campaign-security-alert-burndown-orchestrator-${{ github.ref }}"
  cancel-in-progress: false
engine: claude
safe-outputs:
  create-project-status-update:
    max: 1
  dispatch-workflow:
    max: 3
    workflows:
    - code-scanning-fixer
    - security-fix-pr
    - dependabot-bundler
    - secret-scanning-triage
  update-project:
    max: 10
runs-on: ubuntu-latest
roles:
  - "admin"
  - "maintainer"
  - "write"
tools:
  bash:
  - "*"
  edit: null
  repo-memory:
  - branch-name: memory/campaigns
    campaign-id: security-alert-burndown
    file-glob:
    - security-alert-burndown/**
    id: campaigns
steps:
- name: Create workspace directory
  run: mkdir -p ./.gh-aw
- env:
    GH_AW_CAMPAIGN_ID: security-alert-burndown
    GH_AW_CURSOR_PATH: ""
    GH_AW_DISCOVERY_REPOS: githubnext/gh-aw
    GH_AW_MAX_DISCOVERY_ITEMS: "100"
    GH_AW_MAX_DISCOVERY_PAGES: "5"
    GH_AW_PROJECT_URL: https://github.com/orgs/githubnext/projects/134
    GH_AW_TRACKER_LABEL: ""
    GH_AW_WORKFLOWS: code-scanning-fixer,security-fix-pr,dependabot-bundler,secret-scanning-triage
  id: discovery
  name: Run campaign discovery precomputation
  uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
  with:
    github-token: ${{ secrets.GH_AW_GITHUB_TOKEN || secrets.GITHUB_TOKEN || secrets.GH_AW_GITHUB_MCP_SERVER_TOKEN }}
    script: |
      
      const { setupGlobals } = require('/opt/gh-aw/actions/setup_globals.cjs');
      setupGlobals(core, github, context, exec, io);
      const { main } = require('/opt/gh-aw/actions/campaign_discovery.cjs');
      await main();
---

<!-- This file was automatically generated by gh-aw. DO NOT EDIT. -->
<!-- Source: .github/workflows/security-alert-burndown.campaign.md -->

# Campaign Orchestrator

This workflow orchestrates the 'Security Alert Burndown' campaign.

- Associated workflows: code-scanning-fixer, security-fix-pr, dependabot-bundler, secret-scanning-triage
- Project URL: https://github.com/orgs/githubnext/projects/134
- Governance: max new items per run: 3
- Governance: max discovery items per run: 100
- Governance: max discovery pages per run: 5
- Governance: opt-out labels: no-campaign, no-bot, skip-security-fix
- Governance: max project updates per run: 10
- Governance: max comments per run: 3

---
# WORKFLOW EXECUTION (PHASE 0)
---
# Workflow Execution

This campaign references the following campaign workers. These workers follow the first-class worker pattern: they are dispatch-only workflows with standardized input contracts.

**IMPORTANT: Workers are orchestrated, not autonomous. They accept `campaign_id` and `payload` inputs via workflow_dispatch.**

---

## Campaign Workers


The following campaign workers are referenced by this campaign:

1. `code-scanning-fixer`

2. `security-fix-pr`

3. `dependabot-bundler`

4. `secret-scanning-triage`



**Worker Pattern**: All workers MUST:
- Use `workflow_dispatch` as the ONLY trigger (no schedule/push/pull_request)
- Accept `campaign_id` (string) and `payload` (string; JSON) inputs
- Implement idempotency via deterministic work item keys
- Label all created items with `z_campaign_security-alert-burndown`

---

## Workflow Creation Guardrails

### Before Creating Any Worker Workflow, Ask:

1. **Does this workflow already exist?** - Check `.github/workflows/` thoroughly
2. **Can an existing workflow be adapted?** - Even if not perfect, existing is safer
3. **Is the requirement clear?** - Can you articulate exactly what it should do?
4. **Is it testable?** - Can you verify it works with test inputs?
5. **Is it reusable?** - Could other campaigns benefit from this worker?

### Only Create New Workers When:

✅ **All these conditions are met:**
- No existing workflow does the required task
- The campaign objective explicitly requires this capability
- You have a clear, specific design for the worker
- The worker has a focused, single-purpose scope
- You can test it independently before campaign use

❌ **Never create workers when:**
- You're unsure about requirements
- An existing workflow "mostly" works
- The worker would be complex or multi-purpose
- You haven't verified it doesn't already exist
- You can't clearly explain what it does in one sentence

---

## Worker Creation Template

If you must create a new worker (only after checking ALL guardrails above), use this template:

**Create the workflow file at `.github/workflows/<workflow-id>.md`:**

```yaml
---
name: <Worker Name>
description: <One sentence describing what it does>

on:
  workflow_dispatch:
    inputs:
      campaign_id:
        description: 'Campaign identifier'
        required: true
        type: string
      payload:
        description: 'JSON payload with work item details'
        required: true
        type: string

tracker-id: <workflow-id>

tools:
  github:
    toolsets: [default]
  # Add minimal additional tools as needed

safe-outputs:
  create-pull-request:
    max: 1  # Start conservative
  add-comment:
    max: 2
---

# <Worker Name>

You are a campaign worker that processes work items.

## Input Contract

Parse inputs:
```javascript
const campaignId = context.payload.inputs.campaign_id;
const payload = JSON.parse(context.payload.inputs.payload);
```

Expected payload structure:
```json
{
  "repository": "owner/repo",
  "work_item_id": "unique-id",
  "target_ref": "main",
  // Additional context...
}
```

## Idempotency Requirements

1. **Generate deterministic key**:
   ```
   const workKey = `campaign-${campaignId}-${payload.repository}-${payload.work_item_id}`;
   ```

2. **Check for existing work**:
   - Search for PRs/issues with `workKey` in title
  - Filter by label: `z_campaign_${campaignId}`
   - If found: Skip or update
   - If not: Create new

3. **Label all created items**:
  - Apply `z_campaign_${campaignId}` label
   - This enables discovery by orchestrator

## Task

<Specific task description>

## Output

Report:
- Link to created/updated PR or issue
- Whether work was skipped (exists) or completed
- Any errors or blockers
```

**After creating:**
- Compile: `gh aw compile <workflow-id>.md`
- **CRITICAL: Test with sample inputs** (see testing requirements below)

---

## Worker Testing (MANDATORY)

**Why test?** - Untested workers may fail during campaign execution. Test with sample inputs first to catch issues early.

**Testing steps:**

1. **Prepare test payload**:
   ```json
   {
     "repository": "test-org/test-repo",
     "work_item_id": "test-1",
     "target_ref": "main"
   }
   ```

2. **Trigger test run**:
   ```bash
   gh workflow run <workflow-id>.yml \
     -f campaign_id=security-alert-burndown \
     -f payload='{"repository":"test-org/test-repo","work_item_id":"test-1"}'
   ```
   
   Or via GitHub MCP:
   ```javascript
   mcp__github__run_workflow(
     workflow_id: "<workflow-id>", 
     ref: "main",
     inputs: {
       campaign_id: "security-alert-burndown",
       payload: JSON.stringify({repository: "test-org/test-repo", work_item_id: "test-1"})
     }
   )
   ```

3. **Wait for completion**: Poll until status is "completed"

4. **Verify success**:
   - Check that workflow succeeded
   - Verify idempotency: Run again with same inputs, should skip/update
   - Review created items have correct labels
   - Confirm deterministic keys are used

5. **Test failure actions**:
   - DO NOT use the worker if testing fails
   - Analyze failure logs
   - Make corrections
   - Recompile and retest
   - If unfixable after 2 attempts, report in status and skip

**Note**: Workflows that accept `workflow_dispatch` inputs can receive parameters from the orchestrator. This enables the orchestrator to provide context, priorities, or targets based on its decisions. See [DispatchOps documentation](https://githubnext.github.io/gh-aw/guides/dispatchops/#with-input-parameters) for input parameter examples.

---

## Orchestration Guidelines

**Execution pattern:**
- Workers are **orchestrated, not autonomous**
- Orchestrator discovers work items via discovery manifest
- Orchestrator decides which workers to run and with what inputs
- Workers receive `campaign_id` and `payload` via workflow_dispatch
- Sequential vs parallel execution is orchestrator's decision

**Worker dispatch:**
- Parse discovery manifest (`./.gh-aw/campaign.discovery.json`)
- For each work item needing processing:
  1. Determine appropriate worker for this item type
  2. Construct payload with work item details
  3. Dispatch worker via workflow_dispatch with campaign_id and payload
  4. Track dispatch status

**Input construction:**
```javascript
// Example: Dispatching security-fix worker
const workItem = discoveryManifest.items[0];
const payload = {
  repository: workItem.repo,
  work_item_id: `alert-${workItem.number}`,
  target_ref: "main",
  alert_type: "sql-injection",
  file_path: "src/db.go",
  line_number: 42
};

await github.actions.createWorkflowDispatch({
  owner: context.repo.owner,
  repo: context.repo.repo,
  workflow_id: "security-fix-worker.yml",
  ref: "main",
  inputs: {
    campaign_id: "security-alert-burndown",
    payload: JSON.stringify(payload)
  }
});
```

**Idempotency by design:**
- Workers implement their own idempotency checks
- Orchestrator doesn't need to track what's been processed
- Can safely re-dispatch work items across runs
- Workers will skip or update existing items

**Failure handling:**
- If a worker dispatch fails, note it but continue
- Worker failures don't block entire campaign
- Report all failures in status update with context
- Humans can intervene if needed

---

## After Worker Orchestration

Once workers have been dispatched (or new workers created and tested), proceed with normal orchestrator steps:

1. **Discovery** - Read state from discovery manifest and project board
2. **Planning** - Determine what needs updating on project board
3. **Project Updates** - Write state changes to project board  
4. **Status Reporting** - Report progress, worker dispatches, failures, next steps

---

## Key Differences from Fusion Approach

**Old fusion approach (REMOVED)**:
- Workers had mixed triggers (schedule + workflow_dispatch)
- Fusion dynamically added workflow_dispatch to existing workflows
- Workers stored in campaign-specific folders
- Ambiguous ownership and trigger precedence

**New first-class worker approach**:
- Workers are dispatch-only (on: workflow_dispatch)
- Standardized input contract (campaign_id, payload)
- Explicit idempotency via deterministic keys
- Clear ownership: workers are orchestrated, not autonomous
- Workers stored with regular workflows (not campaign-specific folders)
- Orchestration policy kept explicit in orchestrator

This eliminates duplicate execution problems and makes orchestration concerns explicit.
---
# ORCHESTRATOR INSTRUCTIONS
---
# Orchestrator Instructions

This orchestrator coordinates a single campaign by discovering worker outputs and making deterministic decisions.

**Scope:** orchestration only (discovery, planning, pacing, reporting).
**Actuation model:** **dispatch-only** — the orchestrator may only act by dispatching allowlisted worker workflows.
**Write authority:** all GitHub writes (Projects, issues/PRs, comments, status updates) must happen in worker workflows.

---

## Traffic and Rate Limits (Required)

- Minimize API calls; avoid full rescans when possible.
- Prefer incremental discovery with deterministic ordering (e.g., by `updatedAt`, tie-break by ID).
- Enforce strict pagination budgets; if a query requires many pages, stop early and continue next run.
- Use a durable cursor/checkpoint so the next run continues without rescanning.
- On throttling (HTTP 429 / rate-limit 403), do not retry aggressively; back off and end the run after reporting what remains.






**Read budget**: max discovery items per run: 100


**Read budget**: max discovery pages per run: 5


---

## Core Principles

1. Workers are immutable and campaign-agnostic
2. The GitHub Project board is the authoritative campaign state
3. Correlation is explicit (tracker-id AND labels)
4. Reads and writes are separate steps (never interleave)
5. Idempotent operation is mandatory (safe to re-run)
6. Orchestrators do not write GitHub state directly

---

## Execution Steps (Required Order)

### Step 1 — Read State (Discovery) [NO WRITES]

**IMPORTANT**: Discovery has been precomputed. Read the discovery manifest instead of performing GitHub-wide searches.

1) Read the precomputed discovery manifest: `./.gh-aw/campaign.discovery.json`

2) Parse discovered items from the manifest:
   - Each item has: url, content_type (issue/pull_request/discussion), number, repo, created_at, updated_at, state
   - Closed items have: closed_at (for issues) or merged_at (for PRs)
   - Items are pre-sorted by updated_at for deterministic processing

3) Check the manifest summary for work counts.

4) Discovery cursor is maintained automatically in repo-memory; do not modify it manually.

### Step 2 — Make Decisions (Planning) [NO WRITES]

5) Determine desired `status` strictly from explicit GitHub state:
- Open → `Todo` (or `In Progress` only if explicitly indicated elsewhere)
- Closed (issue/discussion) → `Done`
- Merged (PR) → `Done`

6) Calculate required date fields (for workers that sync Projects):
- `start_date`: format `created_at` as `YYYY-MM-DD`
- `end_date`:
  - if closed/merged → format `closed_at`/`merged_at` as `YYYY-MM-DD`
  - if open → **today's date** formatted `YYYY-MM-DD`

7) Reads and writes are separate steps (never interleave).

### Step 3 — Dispatch Workers (Execution) [DISPATCH ONLY]

8) For each selected unit of work, dispatch a worker workflow using `dispatch-workflow`.

Constraints:
- Only dispatch allowlisted workflows.
- Keep within the dispatch-workflow max for this run.

### Step 4 — Report (No Writes)

9) Summarize what you dispatched, what remains, and what should run next.

If a status update is required on the GitHub Project, dispatch a dedicated reporting/sync worker to perform that write.

    **Discovered:** 25 items (15 issues, 10 PRs)
    **Processed:** 10 items added to project, 5 updated
    **Completion:** 60% (30/50 total tasks)

    ## Most Important Findings

    1. **Critical accessibility gaps identified**: 3 high-severity accessibility issues discovered in mobile navigation, requiring immediate attention
    2. **Documentation coverage acceleration**: Achieved 5% improvement in one week (best velocity so far)
    3. **Worker efficiency improving**: daily-doc-updater now processing 40% more items per run

    ## What Was Learned

    - Multi-device testing reveals issues that desktop-only testing misses - should be prioritized
    - Documentation updates tied to code changes have higher accuracy and completeness
    - Users report fewer issues when examples include error handling patterns

    ## Campaign Progress

    **Documentation Coverage** (Primary Metric):
    - Baseline: 85% → Current: 88% → Target: 95%
    - Direction: ↑ Increasing (+3% this week, +1% velocity/week)
    - Status: ON TRACK - At current velocity, will reach 95% in 7 weeks

    **Accessibility Score** (Supporting Metric):
    - Baseline: 90% → Current: 91% → Target: 98%
    - Direction: ↑ Increasing (+1% this month)
    - Status: AT RISK - Slower progress than expected, may need dedicated focus

    **User-Reported Issues** (Supporting Metric):
    - Baseline: 15/month → Current: 12/month → Target: 5/month
    - Direction: ↓ Decreasing (-3 this month, -20% velocity)
    - Status: ON TRACK - Trending toward target

    ## Next Steps

    1. Address 3 critical accessibility issues identified this run (high priority)
    2. Continue processing remaining 15 discovered items
    3. Focus on accessibility improvements to accelerate supporting KPI
    4. Maintain current documentation coverage velocity
```

12) Report:
- counts discovered (by type)
- counts processed this run (by action: add/status_update/backfill/noop/failed)
- counts deferred due to budgets
- failures (with reasons)
- completion state (work items only)
- cursor advanced / remaining backlog estimate

---

## Authority

If any instruction in this file conflicts with **Project Update Instructions**, the Project Update Instructions win for all project writes.
---
# PROJECT UPDATE INSTRUCTIONS (AUTHORITATIVE FOR WRITES)
---
# Project Update Instructions (Authoritative Write Contract)

## Project Board Integration

This file defines the ONLY allowed rules for writing to the GitHub Project board.
If any other instructions conflict with this file, THIS FILE TAKES PRECEDENCE for all project writes.

---

## 0) Hard Requirements (Do Not Deviate)

- Orchestrators are dispatch-only and MUST NOT perform project writes directly.
- Worker workflows performing project writes MUST use only the `update-project` safe-output.
- All writes MUST target exactly:
  - **Project URL**: `https://github.com/orgs/githubnext/projects/134`
- Every item MUST include:
  - `campaign_id: "security-alert-burndown"`

## Campaign ID

All campaign tracking MUST key off `campaign_id: "security-alert-burndown"`.

---

## 1) Required Project Fields (Must Already Exist)

| Field | Type | Allowed / Notes |
|---|---|---|
| `status` | single-select | `Todo` / `In Progress` / `Review required` / `Blocked` / `Done` |
| `campaign_id` | text | Must equal `security-alert-burndown` |
| `worker_workflow` | text | workflow ID or `"unknown"` |
| `target_repo` | text | `owner/repo` |
| `priority` | single-select | `High` / `Medium` / `Low` |
| `size` | single-select | `Small` / `Medium` / `Large` |
| `start_date` | date | `YYYY-MM-DD` |
| `end_date` | date | `YYYY-MM-DD` |

Field names are case-sensitive.

---

## 2) Content Identification (Mandatory)

Use **content number** (integer), never the URL as an identifier.

- Issue URL: `.../issues/123` → `content_type: "issue"`, `content_number: 123`
- PR URL: `.../pull/456` → `content_type: "pull_request"`, `content_number: 456`

---

## 3) Deterministic Field Rules (No Inference)

These rules apply to any time you write fields:

- `campaign_id`: always `security-alert-burndown`
- `worker_workflow`: workflow ID if known, else `"unknown"`
- `target_repo`: extract `owner/repo` from the issue/PR URL
- `priority`: default `Medium` unless explicitly known
- `size`: default `Medium` unless explicitly known
- `start_date`: issue/PR `created_at` formatted `YYYY-MM-DD`
- `end_date`:
  - if closed/merged → `closed_at` / `merged_at` formatted `YYYY-MM-DD`
  - if open → **today’s date** formatted `YYYY-MM-DD` (**required for roadmap view; do not leave blank**)

For open items, `end_date` is a UI-required placeholder and does NOT represent actual completion.

---

## 4) Read-Write Separation (Prevents Read/Write Mixing)

1. **READ STEP (no writes)** — validate existence and gather metadata
2. **WRITE STEP (writes only)** — execute `update-project`

Never interleave reads and writes.

---

## 5) Adding an Issue or PR (First Write)

### Adding New Issues

When first adding an item to the project, you MUST write ALL required fields.

```yaml
update-project:
  project: "https://github.com/orgs/githubnext/projects/134"
  campaign_id: "security-alert-burndown"
  content_type: "issue"              # or "pull_request"
  content_number: 123
  fields:
    status: "Todo"                   # "Done" if already closed/merged
    campaign_id: "security-alert-burndown"
    worker_workflow: "unknown"
    target_repo: "owner/repo"
    priority: "Medium"
    size: "Medium"
    start_date: "2025-12-15"
    end_date: "2026-01-03"
```

---

## 6) Updating an Existing Item (Minimal Writes)

### Updating Existing Items

Preferred behavior is minimal, idempotent writes:

- If item exists and `status` is unchanged → **No-op**
- If item exists and `status` differs → **Update `status` only**
- If any required field is missing/empty/invalid → **One-time full backfill** (repair only)

### Status-only Update (Default)

```yaml
update-project:
  project: "https://github.com/orgs/githubnext/projects/134"
  campaign_id: "security-alert-burndown"
  content_type: "issue"              # or "pull_request"
  content_number: 123
  fields:
    status: "Done"
```

### Full Backfill (Repair Only)

```yaml
update-project:
  project: "https://github.com/orgs/githubnext/projects/134"
  campaign_id: "security-alert-burndown"
  content_type: "issue"              # or "pull_request"
  content_number: 123
  fields:
    status: "Done"
    campaign_id: "security-alert-burndown"
    worker_workflow: "WORKFLOW_ID"
    target_repo: "owner/repo"
    priority: "Medium"
    size: "Medium"
    start_date: "2025-12-15"
    end_date: "2026-01-02"
```

---

## 7) Idempotency Rules

- Matching status already set → **No-op**
- Different status → **Status-only update**
- Invalid/deleted/inaccessible URL → **Record failure and continue**

## Write Operation Rules

All writes MUST conform to this file and use `update-project` only.

---

## 8) Logging + Failure Handling (Mandatory)

For every attempted item, record:

- `content_type`, `content_number`, `target_repo`
- action taken: `noop | add | status_update | backfill | failed`
- error details if failed

Failures must not stop processing remaining items.

---

## 9) Worker Workflow Policy

- Workers are campaign-agnostic.
- Orchestrator populates `worker_workflow`.
- If `worker_workflow` cannot be determined, it MUST remain `"unknown"` unless explicitly reclassified by the orchestrator.

---

## 10) Parent / Sub-Issue Rules (Campaign Hierarchy)

- Each project board MUST have exactly **one Epic issue** representing the campaign.
- The Epic issue MUST:
  - Be added to the project board
  - Use the same `campaign_id`
  - Use `worker_workflow: "unknown"`

- All campaign work issues (non-epic) MUST be created as **sub-issues of the Epic**.
- Issues MUST NOT be re-parented based on worker assignment.

- Pull requests cannot be sub-issues:
  - PRs MUST reference their related issue via standard GitHub linking (e.g. “Closes #123”).

- Worker grouping MUST be done via the `worker_workflow` project field, not via parent issues.

- The Epic issue is narrative only.
- The project board is the sole authoritative source of campaign state.

---

## Appendix — Machine Check Checklist (Optional)

This checklist is designed to validate outputs before executing project writes.

### A) Output Structure Checks

- [ ] All writes use `update-project:` blocks (no other write mechanism).
- [ ] Each `update-project` block includes:
  - [ ] `project: "https://github.com/orgs/githubnext/projects/134"`
  - [ ] `campaign_id: "security-alert-burndown"` (top-level)
  - [ ] `content_type` ∈ {`issue`, `pull_request`}
  - [ ] `content_number` is an integer
  - [ ] `fields` object is present

### B) Field Validity Checks

- [ ] `fields.status` ∈ {`Todo`, `In Progress`, `Review required`, `Blocked`, `Done`}
- [ ] `fields.campaign_id` is present on first-add/backfill and equals `security-alert-burndown`
- [ ] `fields.worker_workflow` is present on first-add/backfill and is either a known workflow ID or `"unknown"`
- [ ] `fields.target_repo` matches `owner/repo`
- [ ] `fields.priority` ∈ {`High`, `Medium`, `Low`}
- [ ] `fields.size` ∈ {`Small`, `Medium`, `Large`}
- [ ] `fields.start_date` matches `YYYY-MM-DD`
- [ ] `fields.end_date` matches `YYYY-MM-DD`

### C) Update Semantics Checks

- [ ] For existing items, payload is **status-only** unless explicitly doing a backfill repair.
- [ ] Backfill is used only when required fields are missing/empty/invalid.
- [ ] No payload overwrites `priority`/`size`/`worker_workflow` with defaults during a normal status update.

### D) Read-Write Separation Checks

- [ ] All reads occur before any writes (no read/write interleaving).
- [ ] Writes are batched separately from discovery.

### E) Epic/Hierarchy Checks (Policy-Level)

- [ ] Exactly one Epic exists for the campaign board.
- [ ] Epic is on the board and uses `worker_workflow: "unknown"`.
- [ ] All campaign work issues are sub-issues of the Epic (if supported by environment/tooling).
- [ ] PRs are linked to issues via GitHub linking (e.g. “Closes #123”).

### F) Failure Handling Checks

- [ ] Invalid/deleted/inaccessible items are logged as failures and processing continues.
- [ ] Idempotency is delegated to the `update-project` tool; no pre-filtering by board presence.
---
# CLOSING INSTRUCTIONS (HIGHEST PRIORITY)
---
# Closing Instructions (Highest Priority)

Execute all four steps in strict order:

1. Read State (no writes)
2. Make Decisions (no writes)
3. Dispatch Workers (dispatch-workflow only)
4. Report

The following rules are mandatory and override inferred behavior:

- The GitHub Project board is the single source of truth.
- All project writes MUST comply with the Project Update Instructions (in workers).
- State reads and state writes MUST NOT be interleaved.
- Do NOT infer missing data or invent values.
- Do NOT reorganize hierarchy.
- Do NOT overwrite fields except as explicitly allowed.
- Workers are immutable and campaign-agnostic.

If any instruction conflicts, the Project Update Instructions take precedence for all writes.
