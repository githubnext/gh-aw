# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile
# For more information: https://github.com/githubnext/gh-aw/blob/main/.github/instructions/github-agentic-workflows.instructions.md

name: "dev"
on:
  push:
    branches:
    - copilot/*
    - pelikhan/*
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}-${{ github.ref }}"

run-name: "dev"

jobs:
  task:
    runs-on: ubuntu-latest
    permissions:
      actions: write  # Required for github.rest.actions.cancelWorkflowRun()
    steps:
      - name: Check team membership for workflow
        id: check-team-member
        uses: actions/github-script@v8
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function setCheckPermissionsCancelled(message) {
                try {
                    await github.rest.actions.cancelWorkflowRun({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        run_id: context.runId,
                    });
                    core.info(`Cancellation requested for this workflow run: ${message}`);
                }
                catch (error) {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    core.warning(`Failed to cancel workflow run: ${errorMessage}`);
                    core.setFailed(message);
                }
            }
            async function checkPermissionsMain() {
                const { eventName } = context;
                const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
                if (safeEvents.includes(eventName)) {
                    core.info(`✅ Event ${eventName} does not require validation`);
                    return;
                }
                const actor = context.actor;
                const { owner, repo } = context.repo;
                const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
                const requiredPermissions = requiredPermissionsEnv
                    ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "")
                    : [];
                if (!requiredPermissions || requiredPermissions.length === 0) {
                    core.error("❌ Configuration error: Required permissions not specified. Contact repository administrator.");
                    await setCheckPermissionsCancelled("Configuration error: Required permissions not specified");
                    return;
                }
                try {
                    core.debug(`Checking if user '${actor}' has required permissions for ${owner}/${repo}`);
                    core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                    const repoPermission = await github.rest.repos.getCollaboratorPermissionLevel({
                        owner: owner,
                        repo: repo,
                        username: actor,
                    });
                    const permission = repoPermission.data.permission;
                    core.debug(`Repository permission level: ${permission}`);
                    for (const requiredPerm of requiredPermissions) {
                        if (permission === requiredPerm || (requiredPerm === "maintainer" && permission === "maintain")) {
                            core.info(`✅ User has ${permission} access to repository`);
                            return;
                        }
                    }
                    core.warning(`User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`);
                }
                catch (repoError) {
                    const errorMessage = repoError instanceof Error ? repoError.message : String(repoError);
                    core.warning(`Repository permission check failed: ${errorMessage}`);
                    await setCheckPermissionsCancelled(`Repository permission check failed: ${errorMessage}`);
                    return;
                }
                core.warning(`Access denied: Only authorized users can trigger this workflow. User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`);
                await setCheckPermissionsCancelled(`Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`);
            }
            (async () => {
                await checkPermissionsMain();
            })();

  dev:
    needs: task
    runs-on: ubuntu-latest
    permissions: read-all
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          cache: npm
          cache-dependency-path: docs/package-lock.json
          node-version: "24"
      - name: Install dependencies
        run: npm ci
        working-directory: ./docs
      - env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        name: Build documentation
        run: npm run build
        working-directory: ./docs
      - name: Generate Claude Settings
        run: |
          mkdir -p /tmp/.claude
          cat > /tmp/.claude/settings.json << 'EOF'
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "WebFetch|WebSearch",
                  "hooks": [
                    {
                      "type": "command",
                      "command": ".claude/hooks/network_permissions.py"
                    }
                  ]
                }
              ]
            }
          }
          EOF
      - name: Generate Network Permissions Hook
        run: |
          mkdir -p .claude/hooks
          cat > .claude/hooks/network_permissions.py << 'EOF'
          #!/usr/bin/env python3
          """
          Network permissions validator for Claude Code engine.
          Generated by gh-aw from engine network permissions configuration.
          """
          
          import json
          import sys
          import urllib.parse
          import re
          
          # Domain allow-list (populated during generation)
          ALLOWED_DOMAINS = ["crl3.digicert.com","crl4.digicert.com","ocsp.digicert.com","ts-crl.ws.symantec.com","ts-ocsp.ws.symantec.com","crl.geotrust.com","ocsp.geotrust.com","crl.thawte.com","ocsp.thawte.com","crl.verisign.com","ocsp.verisign.com","crl.globalsign.com","ocsp.globalsign.com","crls.ssl.com","ocsp.ssl.com","crl.identrust.com","ocsp.identrust.com","crl.sectigo.com","ocsp.sectigo.com","crl.usertrust.com","ocsp.usertrust.com","s.symcb.com","s.symcd.com","json-schema.org","json.schemastore.org","archive.ubuntu.com","security.ubuntu.com","ppa.launchpad.net","keyserver.ubuntu.com","azure.archive.ubuntu.com","api.snapcraft.io","packagecloud.io","packages.cloud.google.com","packages.microsoft.com"]
          
          def extract_domain(url_or_query):
              """Extract domain from URL or search query."""
              if not url_or_query:
                  return None
              
              if url_or_query.startswith(('http://', 'https://')):
                  return urllib.parse.urlparse(url_or_query).netloc.lower()
              
              # Check for domain patterns in search queries
              match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
              if match:
                  return match.group(1).lower()
              
              return None
          
          def is_domain_allowed(domain):
              """Check if domain is allowed."""
              if not domain:
                  # If no domain detected, allow only if not under deny-all policy
                  return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
              
              # Empty allowed domains means deny all
              if not ALLOWED_DOMAINS:
                  return False
              
              for pattern in ALLOWED_DOMAINS:
                  regex = pattern.replace('.', r'\.').replace('*', '.*')
                  if re.match(f'^{regex}$', domain):
                      return True
              return False
          
          # Main logic
          try:
              data = json.load(sys.stdin)
              tool_name = data.get('tool_name', '')
              tool_input = data.get('tool_input', {})
              
              if tool_name not in ['WebFetch', 'WebSearch']:
                  sys.exit(0)  # Allow other tools
              
              target = tool_input.get('url') or tool_input.get('query', '')
              domain = extract_domain(target)
              
              # For WebSearch, apply domain restrictions consistently
              # If no domain detected in search query, check if restrictions are in place
              if tool_name == 'WebSearch' and not domain:
                  # Since this hook is only generated when network permissions are configured,
                  # empty ALLOWED_DOMAINS means deny-all policy
                  if not ALLOWED_DOMAINS:  # Empty list means deny all
                      print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
                      print(f"No domains are allowed for WebSearch", file=sys.stderr)
                      sys.exit(2)  # Block under deny-all policy
                  else:
                      print(f"Network access blocked for web-search: no specific domain detected", file=sys.stderr)
                      print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                      sys.exit(2)  # Block general searches when domain allowlist is configured
              
              if not is_domain_allowed(domain):
                  print(f"Network access blocked for domain: {domain}", file=sys.stderr)
                  print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                  sys.exit(2)  # Block with feedback to Claude
              
              sys.exit(0)  # Allow
              
          except Exception as e:
              print(f"Network validation error: {e}", file=sys.stderr)
              sys.exit(2)  # Block on errors
          
          EOF
          chmod +x .claude/hooks/network_permissions.py
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v8
        with:
          script: |
            async function setupAgentOutputMain() {
                const crypto = require("crypto");
                const fs = require("fs");
                const randomSuffix = crypto.randomBytes(8).toString("hex");
                const outputFile = `/tmp/aw_output_${randomSuffix}.txt`;
                fs.mkdirSync("/tmp", { recursive: true });
                core.exportVariable("GITHUB_AW_SAFE_OUTPUTS", outputFile);
                core.setOutput("output_file", outputFile);
            }
            (async () => {
                await setupAgentOutputMain();
            })();
      - name: Setup Safe Outputs Collector MCP
        run: |
          mkdir -p /tmp/safe-outputs
          cat > /tmp/safe-outputs/mcp-server.cjs << 'EOF'
            async function safeOutputsMcpServerMain() {
                const fs = require("fs");
                const path = require("path");
                const crypto = require("crypto");
                const { TextEncoder } = require("util");
                const encoder = new TextEncoder();
                const configEnv = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
                if (!configEnv)
                    throw new Error("GITHUB_AW_SAFE_OUTPUTS_CONFIG not set");
                const safeOutputsConfigRaw = JSON.parse(configEnv);
                const safeOutputsConfig = Object.fromEntries(Object.entries(safeOutputsConfigRaw).map(([k, v]) => [k.replace(/-/g, "_"), v]));
                const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
                if (!outputFile)
                    throw new Error("GITHUB_AW_SAFE_OUTPUTS not set, no output file");
                const SERVER_INFO = { name: "safe-outputs-mcp-server", version: "1.0.0" };
                const debug = (msg) => process.stderr.write(`[${SERVER_INFO.name}] ${msg}\n`);
                function writeMessage(obj) {
                    const json = JSON.stringify(obj);
                    debug(`send: ${json}`);
                    const message = json + "\n";
                    const bytes = encoder.encode(message);
                    fs.writeSync(1, bytes);
                }
                class ReadBuffer {
                    _buffer;
                    append(chunk) {
                        const { Buffer } = require("buffer");
                        this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
                    }
                    readMessage() {
                        if (!this._buffer) {
                            return null;
                        }
                        const index = this._buffer.indexOf("\n");
                        if (index === -1) {
                            return null;
                        }
                        const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
                        this._buffer = this._buffer.subarray(index + 1);
                        if (line.trim() === "") {
                            return this.readMessage();
                        }
                        try {
                            return JSON.parse(line);
                        }
                        catch (error) {
                            throw new Error(`Parse error: ${error instanceof Error ? error.message : String(error)}`);
                        }
                    }
                }
                const readBuffer = new ReadBuffer();
                function onData(chunk) {
                    readBuffer.append(chunk);
                    processReadBuffer();
                }
                function processReadBuffer() {
                    while (true) {
                        try {
                            const message = readBuffer.readMessage();
                            if (!message) {
                                break;
                            }
                            debug(`recv: ${JSON.stringify(message)}`);
                            handleMessage(message);
                        }
                        catch (error) {
                            debug(`Parse error: ${error instanceof Error ? error.message : String(error)}`);
                        }
                    }
                }
                function replyResult(id, result) {
                    if (id === undefined || id === null)
                        return;
                    const res = { jsonrpc: "2.0", id, result };
                    writeMessage(res);
                }
                function replyError(id, code, message, data) {
                    if (id === undefined || id === null) {
                        debug(`Error for notification: ${message}`);
                        return;
                    }
                    const error = { code, message };
                    if (data !== undefined) {
                        error.data = data;
                    }
                    const res = {
                        jsonrpc: "2.0",
                        id,
                        error,
                    };
                    writeMessage(res);
                }
                function appendSafeOutput(entry) {
                    if (!outputFile)
                        throw new Error("No output file configured");
                    entry.type = entry.type.replace(/_/g, "-");
                    const jsonLine = JSON.stringify(entry) + "\n";
                    try {
                        fs.appendFileSync(outputFile, jsonLine);
                    }
                    catch (error) {
                        throw new Error(`Failed to write to output file: ${error instanceof Error ? error.message : String(error)}`);
                    }
                }
                const defaultHandler = (type) => (args) => {
                    const entry = { ...(args || {}), type };
                    appendSafeOutput(entry);
                    return {
                        content: [
                            {
                                type: "text",
                                text: `success`,
                            },
                        ],
                    };
                };
                const uploadAssetHandler = (args) => {
                    const branchName = process.env.GITHUB_AW_ASSETS_BRANCH;
                    if (!branchName)
                        throw new Error("GITHUB_AW_ASSETS_BRANCH not set");
                    const { path: filePath } = args;
                    const absolutePath = path.resolve(filePath);
                    const workspaceDir = process.env.GITHUB_WORKSPACE || process.cwd();
                    const tmpDir = "/tmp";
                    const isInWorkspace = absolutePath.startsWith(path.resolve(workspaceDir));
                    const isInTmp = absolutePath.startsWith(tmpDir);
                    if (!isInWorkspace && !isInTmp) {
                        throw new Error(`File path must be within workspace directory (${workspaceDir}) or /tmp directory. ` +
                            `Provided path: ${filePath} (resolved to: ${absolutePath})`);
                    }
                    if (!fs.existsSync(filePath)) {
                        throw new Error(`File not found: ${filePath}`);
                    }
                    const stats = fs.statSync(filePath);
                    const sizeBytes = stats.size;
                    const sizeKB = Math.ceil(sizeBytes / 1024);
                    const maxSizeKB = process.env.GITHUB_AW_ASSETS_MAX_SIZE_KB
                        ? parseInt(process.env.GITHUB_AW_ASSETS_MAX_SIZE_KB, 10)
                        : 10240;
                    if (sizeKB > maxSizeKB) {
                        throw new Error(`File size ${sizeKB} KB exceeds maximum allowed size ${maxSizeKB} KB`);
                    }
                    const ext = path.extname(filePath).toLowerCase();
                    const allowedExts = process.env.GITHUB_AW_ASSETS_ALLOWED_EXTS
                        ? process.env.GITHUB_AW_ASSETS_ALLOWED_EXTS.split(",").map(ext => ext.trim())
                        : [
                            ".png",
                            ".jpg",
                            ".jpeg",
                        ];
                    if (!allowedExts.includes(ext)) {
                        throw new Error(`File extension '${ext}' is not allowed. Allowed extensions: ${allowedExts.join(", ")}`);
                    }
                    const assetsDir = "/tmp/safe-outputs/assets";
                    if (!fs.existsSync(assetsDir)) {
                        fs.mkdirSync(assetsDir, { recursive: true });
                    }
                    const fileContent = fs.readFileSync(filePath);
                    const sha = crypto.createHash("sha256").update(fileContent).digest("hex");
                    const fileName = path.basename(filePath);
                    const fileExt = path.extname(fileName).toLowerCase();
                    const targetPath = path.join(assetsDir, fileName);
                    fs.copyFileSync(filePath, targetPath);
                    const targetFileName = (sha + fileExt).toLowerCase();
                    const githubServer = process.env.GITHUB_SERVER_URL || "https://github.com";
                    const repo = process.env.GITHUB_REPOSITORY || "owner/repo";
                    const url = `${githubServer.replace("github.com", "raw.githubusercontent.com")}/${repo}/${branchName}/${targetFileName}`;
                    const entry = {
                        type: "upload_asset",
                        path: filePath,
                        fileName: fileName,
                        sha: sha,
                        size: sizeBytes,
                        url: url,
                        targetFileName: targetFileName,
                    };
                    appendSafeOutput(entry);
                    return {
                        content: [
                            {
                                type: "text",
                                text: url,
                            },
                        ],
                    };
                };
                const normTool = (toolName) => (toolName ? toolName.replace(/-/g, "_").toLowerCase() : "");
                const ALL_TOOLS = [
                    {
                        name: "create_issue",
                        description: "Create a new GitHub issue",
                        inputSchema: {
                            type: "object",
                            required: ["title", "body"],
                            properties: {
                                title: { type: "string", description: "Issue title" },
                                body: { type: "string", description: "Issue body/description" },
                                labels: {
                                    type: "array",
                                    items: { type: "string" },
                                    description: "Issue labels",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "create_discussion",
                        description: "Create a new GitHub discussion",
                        inputSchema: {
                            type: "object",
                            required: ["title", "body"],
                            properties: {
                                title: { type: "string", description: "Discussion title" },
                                body: { type: "string", description: "Discussion body/content" },
                                category: { type: "string", description: "Discussion category" },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "add_comment",
                        description: "Add a comment to a GitHub issue or pull request",
                        inputSchema: {
                            type: "object",
                            required: ["body"],
                            properties: {
                                body: { type: "string", description: "Comment body/content" },
                                issue_number: {
                                    type: "number",
                                    description: "Issue or PR number (optional for current context)",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "create_pull-request",
                        description: "Create a new GitHub pull request",
                        inputSchema: {
                            type: "object",
                            required: ["title", "body", "branch"],
                            properties: {
                                title: { type: "string", description: "Pull request title" },
                                body: {
                                    type: "string",
                                    description: "Pull request body/description",
                                },
                                branch: {
                                    type: "string",
                                    description: "Required branch name",
                                },
                                labels: {
                                    type: "array",
                                    items: { type: "string" },
                                    description: "Optional labels to add to the PR",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "create_pull_request_review_comment",
                        description: "Create a review comment on a GitHub pull request",
                        inputSchema: {
                            type: "object",
                            required: ["path", "line", "body"],
                            properties: {
                                path: {
                                    type: "string",
                                    description: "File path for the review comment",
                                },
                                line: {
                                    type: ["number", "string"],
                                    description: "Line number for the comment",
                                },
                                body: { type: "string", description: "Comment body content" },
                                start_line: {
                                    type: ["number", "string"],
                                    description: "Optional start line for multi-line comments",
                                },
                                side: {
                                    type: "string",
                                    enum: ["LEFT", "RIGHT"],
                                    description: "Optional side of the diff: LEFT or RIGHT",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "create_code_scanning_alert",
                        description: "Create a code scanning alert",
                        inputSchema: {
                            type: "object",
                            required: ["file", "line", "severity", "message"],
                            properties: {
                                file: {
                                    type: "string",
                                    description: "File path where the issue was found",
                                },
                                line: {
                                    type: ["number", "string"],
                                    description: "Line number where the issue was found",
                                },
                                severity: {
                                    type: "string",
                                    enum: ["error", "warning", "info", "note"],
                                    description: "Severity level",
                                },
                                message: {
                                    type: "string",
                                    description: "Alert message describing the issue",
                                },
                                column: {
                                    type: ["number", "string"],
                                    description: "Optional column number",
                                },
                                ruleIdSuffix: {
                                    type: "string",
                                    description: "Optional rule ID suffix for uniqueness",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "add_labels",
                        description: "Add labels to a GitHub issue or pull request",
                        inputSchema: {
                            type: "object",
                            required: ["labels"],
                            properties: {
                                labels: {
                                    type: "array",
                                    items: { type: "string" },
                                    description: "Labels to add",
                                },
                                issue_number: {
                                    type: "number",
                                    description: "Issue or PR number (optional for current context)",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "update_issue",
                        description: "Update a GitHub issue",
                        inputSchema: {
                            type: "object",
                            properties: {
                                status: {
                                    type: "string",
                                    enum: ["open", "closed"],
                                    description: "Optional new issue status",
                                },
                                title: { type: "string", description: "Optional new issue title" },
                                body: { type: "string", description: "Optional new issue body" },
                                issue_number: {
                                    type: ["number", "string"],
                                    description: "Optional issue number for target '*'",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "push_to_pr_branch",
                        description: "Push changes to a pull request branch",
                        inputSchema: {
                            type: "object",
                            required: ["branch", "message"],
                            properties: {
                                branch: {
                                    type: "string",
                                    description: "The name of the branch to push to, should be the branch name associated with the pull request",
                                },
                                message: { type: "string", description: "Commit message" },
                                pull_request_number: {
                                    type: ["number", "string"],
                                    description: "Optional pull request number for target '*'",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    {
                        name: "upload_asset",
                        description: "Publish a file as a URL-addressable asset to an orphaned git branch",
                        inputSchema: {
                            type: "object",
                            required: ["path"],
                            properties: {
                                path: {
                                    type: "string",
                                    description: "Path to the file to publish as an asset. Must be a file under the current workspace or /tmp directory. By default, images (.png, .jpg, .jpeg) are allowed, but can be configured via workflow settings.",
                                },
                            },
                            additionalProperties: false,
                        },
                        handler: uploadAssetHandler,
                    },
                    {
                        name: "missing_tool",
                        description: "Report a missing tool or functionality needed to complete tasks",
                        inputSchema: {
                            type: "object",
                            required: ["tool", "reason"],
                            properties: {
                                tool: { type: "string", description: "Name of the missing tool" },
                                reason: { type: "string", description: "Why this tool is needed" },
                                alternatives: {
                                    type: "string",
                                    description: "Possible alternatives or workarounds",
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                ];
                debug(`v${SERVER_INFO.version} ready on stdio`);
                debug(`  output file: ${outputFile}`);
                debug(`  config: ${JSON.stringify(safeOutputsConfig)}`);
                const unknownTools = Object.keys(safeOutputsConfig).filter(name => !ALL_TOOLS.find(t => t.name === normTool(name)));
                if (unknownTools.length)
                    throw new Error(`Unknown tools in configuration: ${unknownTools.join(", ")}`);
                const TOOLS = Object.fromEntries(ALL_TOOLS.filter(({ name }) => Object.keys(safeOutputsConfig).find(config => normTool(config) === name)).map(tool => [
                    tool.name,
                    tool,
                ]));
                debug(`  tools: ${Object.keys(TOOLS).join(", ")}`);
                if (!Object.keys(TOOLS).length)
                    throw new Error("No tools enabled in configuration");
                function handleMessage(req) {
                    if (!req || typeof req !== "object") {
                        debug(`Invalid message: not an object`);
                        return;
                    }
                    if (req.jsonrpc !== "2.0") {
                        debug(`Invalid message: missing or invalid jsonrpc field`);
                        return;
                    }
                    const { id, method, params } = req;
                    if (!method || typeof method !== "string") {
                        replyError(id, -32600, "Invalid Request: method must be a string");
                        return;
                    }
                    try {
                        if (method === "initialize") {
                            const clientInfo = params?.clientInfo ?? {};
                            console.error(`client info:`, clientInfo);
                            const protocolVersion = params?.protocolVersion ?? undefined;
                            const result = {
                                serverInfo: SERVER_INFO,
                                ...(protocolVersion ? { protocolVersion } : {}),
                                capabilities: {
                                    tools: {},
                                },
                            };
                            replyResult(id, result);
                        }
                        else if (method === "tools/list") {
                            const list = [];
                            Object.values(TOOLS).forEach(tool => {
                                list.push({
                                    name: tool.name,
                                    description: tool.description,
                                    inputSchema: tool.inputSchema,
                                });
                            });
                            replyResult(id, { tools: list });
                        }
                        else if (method === "tools/call") {
                            const name = params?.name;
                            const args = params?.arguments ?? {};
                            if (!name || typeof name !== "string") {
                                replyError(id, -32602, "Invalid params: 'name' must be a string");
                                return;
                            }
                            const tool = TOOLS[normTool(name)];
                            if (!tool) {
                                replyError(id, -32601, `Tool not found: ${name} (${normTool(name)})`);
                                return;
                            }
                            const handler = tool.handler || defaultHandler(tool.name);
                            const requiredFields = tool.inputSchema && Array.isArray(tool.inputSchema.required) ? tool.inputSchema.required : [];
                            if (requiredFields.length) {
                                const missing = requiredFields.filter(f => {
                                    const value = args[f];
                                    return value === undefined || value === null || (typeof value === "string" && value.trim() === "");
                                });
                                if (missing.length) {
                                    replyError(id, -32602, `Invalid arguments: missing or empty ${missing.map(m => `'${m}'`).join(", ")}`);
                                    return;
                                }
                            }
                            const result = handler(args);
                            const content = result && result.content ? result.content : [];
                            replyResult(id, { content });
                        }
                        else if (/^notifications\//.test(method)) {
                            debug(`ignore ${method}`);
                        }
                        else {
                            replyError(id, -32601, `Method not found: ${method}`);
                        }
                    }
                    catch (e) {
                        replyError(id, -32603, "Internal error", {
                            message: e instanceof Error ? e.message : String(e),
                        });
                    }
                }
                process.stdin.on("data", onData);
                process.stdin.on("error", err => debug(`stdin error: ${err}`));
                process.stdin.resume();
                debug(`listening...`);
            }
            (async () => {
                await safeOutputsMcpServerMain();
            })();
          EOF
          chmod +x /tmp/safe-outputs/mcp-server.cjs
          
      - name: Setup MCPs
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-issue\":{},\"upload-asset\":{}}"
          GITHUB_AW_ASSETS_BRANCH: "assets/${{ github.workflow }}"
          GITHUB_AW_ASSETS_MAX_SIZE_KB: 10240
          GITHUB_AW_ASSETS_ALLOWED_EXTS: ".png,.jpg,.jpeg"
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-09deac4"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              },
              "playwright": {
                "command": "npx",
                "args": [
                  "@playwright/mcp@latest",
                  "--output-dir",
                  "/tmp/mcp-logs/playwright",
                  "--allowed-origins",
                  "localhost;localhost:*;127.0.0.1;127.0.0.1:*"
                ]
              },
              "safe_outputs": {
                "command": "node",
                "args": ["/tmp/safe-outputs/mcp-server.cjs"],
                "env": {
                  "GITHUB_AW_SAFE_OUTPUTS": "${{ env.GITHUB_AW_SAFE_OUTPUTS }}",
                  "GITHUB_AW_SAFE_OUTPUTS_CONFIG": ${{ toJSON(env.GITHUB_AW_SAFE_OUTPUTS_CONFIG) }},
                  "GITHUB_AW_ASSETS_BRANCH": "${{ env.GITHUB_AW_ASSETS_BRANCH }}",
                  "GITHUB_AW_ASSETS_MAX_SIZE_KB": "${{ env.GITHUB_AW_ASSETS_MAX_SIZE_KB }}",
                  "GITHUB_AW_ASSETS_ALLOWED_EXTS": "${{ env.GITHUB_AW_ASSETS_ALLOWED_EXTS }}"
                }
              }
            }
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Documentation Build and Accessibility Analysis
          
          This workflow compiles the documentation, launches the development server, takes a screenshot, and performs accessibility analysis.
          
          Please follow these steps:
          
          ## Step 2: Build and Launch Documentation Server
          0. Go to the `docs` directory
          1. Start the documentation development server using `npm run dev`
          2. Wait for the server to fully start (it should be accessible on `http://localhost:4321/gh-aw/`)
          3. Verify the server is running by making a curl request to test accessibility
          
          ## Step 3: Take Screenshot with Playwright
          1. Use Playwright to navigate to `http://localhost:4321/gh-aw/`
          2. Wait for the page to fully load
          3. Take a full-page screenshot of the documentation homepage
          4. Save the screenshot to a file (e.g., `/tmp/docs-screenshot.png`)
          
          ## Step 4: Upload Screenshot
          1. Use the `upload asset` tool from safe-outputs to upload the screenshot file
          2. The tool will return a URL for the uploaded screenshot that can be included in the issue
          
          ## Step 5: Accessibility Analysis
          1. Analyze the screenshot **image** for accessibility issues. DO NOT ANALYZE THE HTML. Focusing on:
             - Color contrast ratios (WCAG 2.1 AA requirements: 4.5:1 for normal text, 3:1 for large text)
             - Text readability against background colors
             - Navigation elements visibility
             - Button and link contrast
             - Code block readability
             - Overall visual hierarchy and accessibility
          
          ## Step 6: Create Issue with Results
          1. Use the `safe-outputs create-issue` functionality to create a GitHub issue
          2. Include in the issue:
             - The uploaded screenshot URL from step 4
             - Detailed accessibility analysis results
             - Any recommendations for improvements
          
          Focus on providing a comprehensive accessibility analysis that would be useful for improving the documentation's usability for all users.
          
          
          ---
          
          ## Creating an IssueUploading Assets, Reporting Missing Tools or Functionality
          
          **IMPORTANT**: To do the actions mentioned in the header of this section, use the **safe-outputs** tools, do NOT attempt to use `gh`, do NOT attempt to use the GitHub API. You don't have write access to the GitHub repo.
          
          **Creating an Issue**
          
          To create an issue, use the create-issue tool from the safe-outputs MCP
          
          **Uploading Assets**
          
          To upload files as URL-addressable assets:
          1. Use the `upload asset` tool from the safe-outputs MCP
          2. Provide the path to the file you want to upload
          3. The tool will copy the file to a staging area and return a GitHub raw content URL
          4. Assets are uploaded to an orphaned git branch after workflow completion
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "claude",
              engine_name: "Claude Code",
              model: "",
              version: "",
              workflow_name: "dev",
              experimental: false,
              supports_tools_allowlist: true,
              supports_http_transport: true,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: true,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
            
            // Add agentic workflow run information to step summary
            core.summary
              .addRaw('## Agentic Run Information\n\n')
              .addRaw('```json\n')
              .addRaw(JSON.stringify(awInfo, null, 2))
              .addRaw('\n```\n')
              .write();
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Execute Claude Code CLI
        id: agentic_execution
        # Allowed tools (sorted):
        # - Bash(cd *)
        # - Bash(cp *)
        # - Bash(curl *)
        # - Bash(kill *)
        # - Bash(mkdir *)
        # - Bash(mv *)
        # - Bash(node *)
        # - Bash(npm *)
        # - Bash(ps *)
        # - Bash(sleep *)
        # - BashOutput
        # - ExitPlanMode
        # - Glob
        # - Grep
        # - KillBash
        # - LS
        # - NotebookRead
        # - Read
        # - Task
        # - TodoWrite
        # - Write
        # - mcp__github__download_workflow_run_artifact
        # - mcp__github__get_code_scanning_alert
        # - mcp__github__get_commit
        # - mcp__github__get_dependabot_alert
        # - mcp__github__get_discussion
        # - mcp__github__get_discussion_comments
        # - mcp__github__get_file_contents
        # - mcp__github__get_issue
        # - mcp__github__get_issue_comments
        # - mcp__github__get_job_logs
        # - mcp__github__get_me
        # - mcp__github__get_notification_details
        # - mcp__github__get_pull_request
        # - mcp__github__get_pull_request_comments
        # - mcp__github__get_pull_request_diff
        # - mcp__github__get_pull_request_files
        # - mcp__github__get_pull_request_reviews
        # - mcp__github__get_pull_request_status
        # - mcp__github__get_secret_scanning_alert
        # - mcp__github__get_tag
        # - mcp__github__get_workflow_run
        # - mcp__github__get_workflow_run_logs
        # - mcp__github__get_workflow_run_usage
        # - mcp__github__list_branches
        # - mcp__github__list_code_scanning_alerts
        # - mcp__github__list_commits
        # - mcp__github__list_dependabot_alerts
        # - mcp__github__list_discussion_categories
        # - mcp__github__list_discussions
        # - mcp__github__list_issues
        # - mcp__github__list_notifications
        # - mcp__github__list_pull_requests
        # - mcp__github__list_secret_scanning_alerts
        # - mcp__github__list_tags
        # - mcp__github__list_workflow_jobs
        # - mcp__github__list_workflow_run_artifacts
        # - mcp__github__list_workflow_runs
        # - mcp__github__list_workflows
        # - mcp__github__search_code
        # - mcp__github__search_issues
        # - mcp__github__search_orgs
        # - mcp__github__search_pull_requests
        # - mcp__github__search_repositories
        # - mcp__github__search_users
        # - mcp__playwright__browser_click
        # - mcp__playwright__browser_close
        # - mcp__playwright__browser_console_messages
        # - mcp__playwright__browser_drag
        # - mcp__playwright__browser_evaluate
        # - mcp__playwright__browser_file_upload
        # - mcp__playwright__browser_fill_form
        # - mcp__playwright__browser_handle_dialog
        # - mcp__playwright__browser_hover
        # - mcp__playwright__browser_install
        # - mcp__playwright__browser_navigate
        # - mcp__playwright__browser_navigate_back
        # - mcp__playwright__browser_network_requests
        # - mcp__playwright__browser_press_key
        # - mcp__playwright__browser_resize
        # - mcp__playwright__browser_select_option
        # - mcp__playwright__browser_snapshot
        # - mcp__playwright__browser_tabs
        # - mcp__playwright__browser_take_screenshot
        # - mcp__playwright__browser_type
        # - mcp__playwright__browser_wait_for
        timeout-minutes: 5
        run: |
          set -o pipefail
          # Execute Claude Code CLI with prompt from file
          npx @anthropic-ai/claude-code@latest --print --max-turns 50 --mcp-config /tmp/mcp-config/mcp-servers.json --allowed-tools "Bash(cd *),Bash(cp *),Bash(curl *),Bash(kill *),Bash(mkdir *),Bash(mv *),Bash(node *),Bash(npm *),Bash(ps *),Bash(sleep *),BashOutput,ExitPlanMode,Glob,Grep,KillBash,LS,NotebookRead,Read,Task,TodoWrite,Write,mcp__github__download_workflow_run_artifact,mcp__github__get_code_scanning_alert,mcp__github__get_commit,mcp__github__get_dependabot_alert,mcp__github__get_discussion,mcp__github__get_discussion_comments,mcp__github__get_file_contents,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__get_job_logs,mcp__github__get_me,mcp__github__get_notification_details,mcp__github__get_pull_request,mcp__github__get_pull_request_comments,mcp__github__get_pull_request_diff,mcp__github__get_pull_request_files,mcp__github__get_pull_request_reviews,mcp__github__get_pull_request_status,mcp__github__get_secret_scanning_alert,mcp__github__get_tag,mcp__github__get_workflow_run,mcp__github__get_workflow_run_logs,mcp__github__get_workflow_run_usage,mcp__github__list_branches,mcp__github__list_code_scanning_alerts,mcp__github__list_commits,mcp__github__list_dependabot_alerts,mcp__github__list_discussion_categories,mcp__github__list_discussions,mcp__github__list_issues,mcp__github__list_notifications,mcp__github__list_pull_requests,mcp__github__list_secret_scanning_alerts,mcp__github__list_tags,mcp__github__list_workflow_jobs,mcp__github__list_workflow_run_artifacts,mcp__github__list_workflow_runs,mcp__github__list_workflows,mcp__github__search_code,mcp__github__search_issues,mcp__github__search_orgs,mcp__github__search_pull_requests,mcp__github__search_repositories,mcp__github__search_users,mcp__playwright__browser_click,mcp__playwright__browser_close,mcp__playwright__browser_console_messages,mcp__playwright__browser_drag,mcp__playwright__browser_evaluate,mcp__playwright__browser_file_upload,mcp__playwright__browser_fill_form,mcp__playwright__browser_handle_dialog,mcp__playwright__browser_hover,mcp__playwright__browser_install,mcp__playwright__browser_navigate,mcp__playwright__browser_navigate_back,mcp__playwright__browser_network_requests,mcp__playwright__browser_press_key,mcp__playwright__browser_resize,mcp__playwright__browser_select_option,mcp__playwright__browser_snapshot,mcp__playwright__browser_tabs,mcp__playwright__browser_take_screenshot,mcp__playwright__browser_type,mcp__playwright__browser_wait_for" --debug --verbose --permission-mode bypassPermissions --output-format json --settings /tmp/.claude/settings.json "$(cat /tmp/aw-prompts/prompt.txt)" 2>&1 | tee /tmp/dev.log
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          DISABLE_TELEMETRY: "1"
          DISABLE_ERROR_REPORTING: "1"
          DISABLE_BUG_COMMAND: "1"
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_MCP_CONFIG: /tmp/mcp-config/mcp-servers.json
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
          GITHUB_AW_ASSETS_BRANCH: "assets/${{ github.workflow }}"
          GITHUB_AW_ASSETS_MAX_SIZE_KB: 10240
          GITHUB_AW_ASSETS_ALLOWED_EXTS: ".png,.jpg,.jpeg"
          GITHUB_AW_MAX_TURNS: 50
      - name: Ensure log file exists
        if: always()
        run: |
          # Ensure log file exists
          touch /tmp/dev.log
          # Show last few lines for debugging
          echo "=== Last 10 lines of Claude execution log ==="
          tail -10 /tmp/dev.log || echo "No log content available"
      - name: Print Agent output
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Agent Output (JSONL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          if [ -f ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ]; then
            cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
            # Ensure there's a newline after the file content if it doesn't end with one
            if [ -s ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ] && [ "$(tail -c1 ${{ env.GITHUB_AW_SAFE_OUTPUTS }})" != "" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No agent output file found" >> $GITHUB_STEP_SUMMARY
          fi
          echo '``````' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      - name: Upload agentic output file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe_output.jsonl
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Ingest agent output
        id: collect_output
        uses: actions/github-script@v8
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-issue\":{},\"upload-asset\":{}}"
        with:
          script: |
            async function collectNdjsonOutputMain() {
                const fs = require("fs");
                function sanitizeContent(content) {
                    if (!content || typeof content !== "string") {
                        return "";
                    }
                    const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
                    const defaultAllowedDomains = [
                        "github.com",
                        "github.io",
                        "githubusercontent.com",
                        "githubassets.com",
                        "github.dev",
                        "codespaces.new",
                    ];
                    const allowedDomains = allowedDomainsEnv
                        ? allowedDomainsEnv
                            .split(",")
                            .map(d => d.trim())
                            .filter(d => d)
                        : defaultAllowedDomains;
                    let sanitized = content;
                    sanitized = neutralizeMentions(sanitized);
                    sanitized = removeXmlComments(sanitized);
                    sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
                    sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
                    sanitized = sanitizeUrlProtocols(sanitized);
                    sanitized = sanitizeUrlDomains(sanitized);
                    const maxLength = 524288;
                    if (sanitized.length > maxLength) {
                        sanitized = sanitized.substring(0, maxLength) + "\n[Content truncated due to length]";
                    }
                    const lines = sanitized.split("\n");
                    const maxLines = 65000;
                    if (lines.length > maxLines) {
                        sanitized = lines.slice(0, maxLines).join("\n") + "\n[Content truncated due to line count]";
                    }
                    sanitized = neutralizeBotTriggers(sanitized);
                    return sanitized.trim();
                    function sanitizeUrlDomains(s) {
                        return s.replace(/\bhttps:\/\/[^\s\])}'"<>&\x00-\x1f,;]+/gi, match => {
                            const urlAfterProtocol = match.slice(8);
                            const hostname = urlAfterProtocol.split(/[\/:\?#]/)[0].toLowerCase();
                            const isAllowed = allowedDomains.some(allowedDomain => {
                                const normalizedAllowed = allowedDomain.toLowerCase();
                                return hostname === normalizedAllowed || hostname.endsWith("." + normalizedAllowed);
                            });
                            return isAllowed ? match : "(redacted)";
                        });
                    }
                    function sanitizeUrlProtocols(s) {
                        return s.replace(/\b(?!https:\/\/)[a-z][a-z0-9+.-]*:\/\/[^\s\])}'"<>&\x00-\x1f,;]+/gi, "(redacted)");
                    }
                    function neutralizeMentions(s) {
                        return s.replace(/(?<!`)@([a-zA-Z0-9_-]+)(?!`)/g, "`@$1`");
                    }
                    function removeXmlComments(s) {
                        return s.replace(/<!--[\s\S]*?-->/g, "");
                    }
                    function neutralizeBotTriggers(s) {
                        const botTriggers = [
                            /(?<!`)\b(fixes?|closes?|resolves?)\s+#(\d+)(?!`)/gi,
                            /(?<!`)\b(re-?open|reopen)\s+#(\d+)(?!`)/gi,
                            /(?<!`)\/\w+(?!`)/g,
                        ];
                        let result = s;
                        for (const trigger of botTriggers) {
                            result = result.replace(trigger, "`$&`");
                        }
                        return result;
                    }
                }
                function repairJson(jsonStr) {
                    let repaired = jsonStr.trim();
                    const _ctrl = { 8: "\\b", 9: "\\t", 10: "\\n", 12: "\\f", 13: "\\r" };
                    repaired = repaired.replace(/[\u0000-\u001F]/g, ch => {
                        const c = ch.charCodeAt(0);
                        return _ctrl[c] || "\\u" + c.toString(16).padStart(4, "0");
                    });
                    repaired = repaired.replace(/'/g, '"');
                    repaired = repaired.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":');
                    repaired = repaired.replace(/"([^"\\]*)"/g, (match, content) => {
                        if (content.includes("\n") || content.includes("\r") || content.includes("\t")) {
                            const escaped = content
                                .replace(/\\/g, "\\\\")
                                .replace(/\n/g, "\\n")
                                .replace(/\r/g, "\\r")
                                .replace(/\t/g, "\\t");
                            return `"${escaped}"`;
                        }
                        return match;
                    });
                    repaired = repaired.replace(/"([^"]*)"([^":,}\]]*)"([^"]*)"(\s*[,:}\]])/g, (match, p1, p2, p3, p4) => `"${p1}\\"${p2}\\"${p3}"${p4}`);
                    repaired = repaired.replace(/(\[\s*(?:"[^"]*"(?:\s*,\s*"[^"]*")*\s*),?)\s*}/g, "$1]");
                    const openBraces = (repaired.match(/\{/g) || []).length;
                    const closeBraces = (repaired.match(/\}/g) || []).length;
                    if (openBraces > closeBraces) {
                        repaired += "}".repeat(openBraces - closeBraces);
                    }
                    else if (closeBraces > openBraces) {
                        repaired = "{".repeat(closeBraces - openBraces) + repaired;
                    }
                    const openBrackets = (repaired.match(/\[/g) || []).length;
                    const closeBrackets = (repaired.match(/\]/g) || []).length;
                    if (openBrackets > closeBrackets) {
                        repaired += "]".repeat(openBrackets - closeBrackets);
                    }
                    else if (closeBrackets > openBrackets) {
                        repaired = "[".repeat(closeBrackets - openBrackets) + repaired;
                    }
                    repaired = repaired.replace(/,(\s*[}\]])/g, "$1");
                    return repaired;
                }
                function validatePositiveInteger(value, fieldName, lineNum) {
                    if (value === undefined || value === null) {
                        if (fieldName.includes("create-code-scanning-alert 'line'")) {
                            return {
                                isValid: false,
                                error: `Line ${lineNum}: create-code-scanning-alert requires a 'line' field (number or string)`,
                            };
                        }
                        if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                            return {
                                isValid: false,
                                error: `Line ${lineNum}: create-pull-request-review-comment requires a 'line' number`,
                            };
                        }
                        return {
                            isValid: false,
                            error: `Line ${lineNum}: ${fieldName} is required`,
                        };
                    }
                    if (typeof value !== "number" && typeof value !== "string") {
                        if (fieldName.includes("create-code-scanning-alert 'line'")) {
                            return {
                                isValid: false,
                                error: `Line ${lineNum}: create-code-scanning-alert requires a 'line' field (number or string)`,
                            };
                        }
                        if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                            return {
                                isValid: false,
                                error: `Line ${lineNum}: create-pull-request-review-comment requires a 'line' number`,
                            };
                        }
                        return {
                            isValid: false,
                            error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                        };
                    }
                    let numValue;
                    if (typeof value === "string") {
                        const parsed = parseInt(value, 10);
                        if (isNaN(parsed)) {
                            return {
                                isValid: false,
                                error: `Line ${lineNum}: ${fieldName} must be a valid number`,
                            };
                        }
                        numValue = parsed;
                    }
                    else {
                        numValue = value;
                    }
                    if (!Number.isInteger(numValue) || numValue <= 0) {
                        return {
                            isValid: false,
                            error: `Line ${lineNum}: ${fieldName} must be a positive integer`,
                        };
                    }
                    return { isValid: true, normalizedValue: numValue };
                }
                function validateOptionalPositiveInteger(value, fieldName, lineNum) {
                    if (value === undefined || value === null) {
                        return { isValid: true };
                    }
                    if (typeof value !== "number" && typeof value !== "string") {
                        return {
                            isValid: false,
                            error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                        };
                    }
                    return { isValid: true };
                }
                function validateIssueOrPRNumber(value, fieldName, lineNum) {
                    if (value === undefined || value === null) {
                        return { isValid: true };
                    }
                    if (typeof value !== "number" && typeof value !== "string") {
                        return {
                            isValid: false,
                            error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                        };
                    }
                    return { isValid: true };
                }
                function parseJsonWithRepair(jsonStr) {
                    try {
                        return JSON.parse(jsonStr);
                    }
                    catch (originalError) {
                        try {
                            const repairedJson = repairJson(jsonStr);
                            return JSON.parse(repairedJson);
                        }
                        catch (repairError) {
                            core.info(`invalid input json: ${jsonStr}`);
                            const originalMsg = originalError instanceof Error ? originalError.message : String(originalError);
                            const repairMsg = repairError instanceof Error ? repairError.message : String(repairError);
                            throw new Error(`JSON parsing failed. Original: ${originalMsg}. After attempted repair: ${repairMsg}`);
                        }
                    }
                }
                const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
                const safeOutputsConfig = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
                if (!outputFile) {
                    core.info("GITHUB_AW_SAFE_OUTPUTS not set, no output to collect");
                    core.setOutput("output", "");
                    return;
                }
                if (!fs.existsSync(outputFile)) {
                    core.info(`Output file does not exist: ${outputFile}`);
                    core.setOutput("output", "");
                    return;
                }
                const outputContent = fs.readFileSync(outputFile, "utf8");
                if (outputContent.trim() === "") {
                    core.info("Output file is empty");
                    core.setOutput("output", "");
                    return;
                }
                core.info(`Raw output content length: ${outputContent.length}`);
                let expectedOutputTypes = {};
                if (safeOutputsConfig) {
                    try {
                        expectedOutputTypes = JSON.parse(safeOutputsConfig);
                        core.info(`Expected output types: ${JSON.stringify(Object.keys(expectedOutputTypes))}`);
                    }
                    catch (error) {
                        const errorMsg = error instanceof Error ? error.message : String(error);
                        core.info(`Warning: Could not parse safe-outputs config: ${errorMsg}`);
                    }
                }
                const lines = outputContent.trim().split("\n");
                const parsedItems = [];
                const errors = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line === "")
                        continue;
                    try {
                        const item = parseJsonWithRepair(line);
                        if (item === undefined) {
                            errors.push(`Line ${i + 1}: Invalid JSON - JSON parsing failed`);
                            continue;
                        }
                        if (!item.type) {
                            errors.push(`Line ${i + 1}: Missing required 'type' field`);
                            continue;
                        }
                        const itemType = item.type;
                        if (!expectedOutputTypes[itemType]) {
                            errors.push(`Line ${i + 1}: Unexpected output type '${itemType}'. Expected one of: ${Object.keys(expectedOutputTypes).join(", ")}`);
                            continue;
                        }
                        switch (itemType) {
                            case "create-issue":
                                if (!item.title || typeof item.title !== "string") {
                                    errors.push(`Line ${i + 1}: create-issue requires a 'title' string field`);
                                    continue;
                                }
                                if (!item.body || typeof item.body !== "string") {
                                    errors.push(`Line ${i + 1}: create-issue requires a 'body' string field`);
                                    continue;
                                }
                                item.title = sanitizeContent(item.title);
                                item.body = sanitizeContent(item.body);
                                if (item.labels !== undefined) {
                                    if (!Array.isArray(item.labels)) {
                                        errors.push(`Line ${i + 1}: create-issue 'labels' must be an array`);
                                        continue;
                                    }
                                    for (let j = 0; j < item.labels.length; j++) {
                                        if (typeof item.labels[j] !== "string") {
                                            errors.push(`Line ${i + 1}: create-issue label at index ${j} must be a string`);
                                            continue;
                                        }
                                        item.labels[j] = sanitizeContent(item.labels[j]);
                                    }
                                }
                                break;
                            case "create-discussion":
                                if (!item.title || typeof item.title !== "string") {
                                    errors.push(`Line ${i + 1}: create-discussion requires a 'title' string field`);
                                    continue;
                                }
                                if (!item.body || typeof item.body !== "string") {
                                    errors.push(`Line ${i + 1}: create-discussion requires a 'body' string field`);
                                    continue;
                                }
                                item.title = sanitizeContent(item.title);
                                item.body = sanitizeContent(item.body);
                                if (item.category !== undefined && typeof item.category !== "string") {
                                    errors.push(`Line ${i + 1}: create-discussion 'category' must be a string`);
                                    continue;
                                }
                                if (item.category) {
                                    item.category = sanitizeContent(item.category);
                                }
                                break;
                            case "add-comment":
                                if (!item.body || typeof item.body !== "string") {
                                    errors.push(`Line ${i + 1}: add-comment requires a 'body' string field`);
                                    continue;
                                }
                                item.body = sanitizeContent(item.body);
                                const addCommentIssueNumValidation = validateIssueOrPRNumber(item.issue_number, "add-comment 'issue_number'", i + 1);
                                if (!addCommentIssueNumValidation.isValid) {
                                    errors.push(addCommentIssueNumValidation.error);
                                    continue;
                                }
                                break;
                            case "create-pull-request":
                                if (!item.title || typeof item.title !== "string") {
                                    errors.push(`Line ${i + 1}: create-pull-request requires a 'title' string field`);
                                    continue;
                                }
                                if (!item.body || typeof item.body !== "string") {
                                    errors.push(`Line ${i + 1}: create-pull-request requires a 'body' string field`);
                                    continue;
                                }
                                if (!item.branch || typeof item.branch !== "string") {
                                    errors.push(`Line ${i + 1}: create-pull-request requires a 'branch' string field`);
                                    continue;
                                }
                                item.title = sanitizeContent(item.title);
                                item.body = sanitizeContent(item.body);
                                item.branch = sanitizeContent(item.branch);
                                if (item.labels !== undefined) {
                                    if (!Array.isArray(item.labels)) {
                                        errors.push(`Line ${i + 1}: create-pull-request 'labels' must be an array`);
                                        continue;
                                    }
                                    for (let j = 0; j < item.labels.length; j++) {
                                        if (typeof item.labels[j] !== "string") {
                                            errors.push(`Line ${i + 1}: create-pull-request label at index ${j} must be a string`);
                                            continue;
                                        }
                                        item.labels[j] = sanitizeContent(item.labels[j]);
                                    }
                                }
                                break;
                            case "create-code-scanning-alert":
                                if (!item.file || typeof item.file !== "string") {
                                    errors.push(`Line ${i + 1}: create-code-scanning-alert requires a 'file' string field`);
                                    continue;
                                }
                                const codeAlertLineValidation = validatePositiveInteger(item.line, "create-code-scanning-alert 'line'", i + 1);
                                if (!codeAlertLineValidation.isValid) {
                                    errors.push(codeAlertLineValidation.error);
                                    continue;
                                }
                                if (!item.severity || typeof item.severity !== "string") {
                                    errors.push(`Line ${i + 1}: create-code-scanning-alert requires a 'severity' string field`);
                                    continue;
                                }
                                const validSeverities = ["error", "warning", "info", "note"];
                                if (!validSeverities.includes(item.severity)) {
                                    errors.push(`Line ${i + 1}: create-code-scanning-alert 'severity' must be one of: ${validSeverities.join(", ")}`);
                                    continue;
                                }
                                if (!item.message || typeof item.message !== "string") {
                                    errors.push(`Line ${i + 1}: create-code-scanning-alert requires a 'message' string field`);
                                    continue;
                                }
                                item.file = sanitizeContent(item.file);
                                item.message = sanitizeContent(item.message);
                                const columnValidation = validateOptionalPositiveInteger(item.column, "create-code-scanning-alert 'column'", i + 1);
                                if (!columnValidation.isValid) {
                                    errors.push(columnValidation.error);
                                    continue;
                                }
                                if (item.ruleIdSuffix !== undefined && typeof item.ruleIdSuffix !== "string") {
                                    errors.push(`Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must be a string`);
                                    continue;
                                }
                                if (item.ruleIdSuffix) {
                                    item.ruleIdSuffix = sanitizeContent(item.ruleIdSuffix);
                                }
                                break;
                            case "add-labels":
                                if (!item.labels || !Array.isArray(item.labels)) {
                                    errors.push(`Line ${i + 1}: add-labels requires a 'labels' array field`);
                                    continue;
                                }
                                if (item.labels.length === 0) {
                                    errors.push(`Line ${i + 1}: add-labels 'labels' array cannot be empty`);
                                    continue;
                                }
                                for (let j = 0; j < item.labels.length; j++) {
                                    if (typeof item.labels[j] !== "string") {
                                        errors.push(`Line ${i + 1}: add-labels label at index ${j} must be a string`);
                                        continue;
                                    }
                                    item.labels[j] = sanitizeContent(item.labels[j]);
                                }
                                const addLabelsIssueNumValidation = validateIssueOrPRNumber(item.issue_number, "add-labels 'issue_number'", i + 1);
                                if (!addLabelsIssueNumValidation.isValid) {
                                    errors.push(addLabelsIssueNumValidation.error);
                                    continue;
                                }
                                break;
                            case "update-issue":
                                const hasValidField = item.status !== undefined || item.title !== undefined || item.body !== undefined;
                                if (!hasValidField) {
                                    errors.push(`Line ${i + 1}: update_issue requires at least one of: 'status', 'title', or 'body' fields`);
                                    continue;
                                }
                                if (item.status !== undefined) {
                                    if (typeof item.status !== "string" || (item.status !== "open" && item.status !== "closed")) {
                                        errors.push(`Line ${i + 1}: update_issue 'status' must be 'open' or 'closed'`);
                                        continue;
                                    }
                                }
                                if (item.title !== undefined) {
                                    if (typeof item.title !== "string") {
                                        errors.push(`Line ${i + 1}: update-issue 'title' must be a string`);
                                        continue;
                                    }
                                    item.title = sanitizeContent(item.title);
                                }
                                if (item.body !== undefined) {
                                    if (typeof item.body !== "string") {
                                        errors.push(`Line ${i + 1}: update-issue 'body' must be a string`);
                                        continue;
                                    }
                                    item.body = sanitizeContent(item.body);
                                }
                                const updateIssueNumValidation = validateIssueOrPRNumber(item.issue_number, "update-issue 'issue_number'", i + 1);
                                if (!updateIssueNumValidation.isValid) {
                                    errors.push(updateIssueNumValidation.error);
                                    continue;
                                }
                                break;
                            case "push-to-pr-branch":
                                if (!item.branch || typeof item.branch !== "string") {
                                    errors.push(`Line ${i + 1}: push_to_pr_branch requires a 'branch' string field`);
                                    continue;
                                }
                                if (!item.message || typeof item.message !== "string") {
                                    errors.push(`Line ${i + 1}: push_to_pr_branch requires a 'message' string field`);
                                    continue;
                                }
                                item.branch = sanitizeContent(item.branch);
                                item.message = sanitizeContent(item.message);
                                const pushPRNumValidation = validateIssueOrPRNumber(item.pull_request_number, "push-to-pr-branch 'pull_request_number'", i + 1);
                                if (!pushPRNumValidation.isValid) {
                                    errors.push(pushPRNumValidation.error);
                                    continue;
                                }
                                break;
                            case "create-pull-request-review-comment":
                                if (!item.path || typeof item.path !== "string") {
                                    errors.push(`Line ${i + 1}: create-pull-request-review-comment requires a 'path' string field`);
                                    continue;
                                }
                                const lineValidation = validatePositiveInteger(item.line, "create-pull-request-review-comment 'line'", i + 1);
                                if (!lineValidation.isValid) {
                                    errors.push(lineValidation.error);
                                    continue;
                                }
                                const lineNumber = lineValidation.normalizedValue;
                                if (!item.body || typeof item.body !== "string") {
                                    errors.push(`Line ${i + 1}: create-pull-request-review-comment requires a 'body' string field`);
                                    continue;
                                }
                                item.body = sanitizeContent(item.body);
                                const startLineValidation = validateOptionalPositiveInteger(item.start_line, "create-pull-request-review-comment 'start_line'", i + 1);
                                if (!startLineValidation.isValid) {
                                    errors.push(startLineValidation.error);
                                    continue;
                                }
                                if (startLineValidation.normalizedValue !== undefined &&
                                    lineNumber !== undefined &&
                                    startLineValidation.normalizedValue > lineNumber) {
                                    errors.push(`Line ${i + 1}: create-pull-request-review-comment 'start_line' must be less than or equal to 'line'`);
                                    continue;
                                }
                                if (item.side !== undefined) {
                                    if (typeof item.side !== "string" || (item.side !== "LEFT" && item.side !== "RIGHT")) {
                                        errors.push(`Line ${i + 1}: create-pull-request-review-comment 'side' must be 'LEFT' or 'RIGHT'`);
                                        continue;
                                    }
                                }
                                break;
                            case "missing-tool":
                                if (!item.tool || typeof item.tool !== "string") {
                                    errors.push(`Line ${i + 1}: missing-tool requires a 'tool' string field`);
                                    continue;
                                }
                                if (!item.reason || typeof item.reason !== "string") {
                                    errors.push(`Line ${i + 1}: missing-tool requires a 'reason' string field`);
                                    continue;
                                }
                                item.tool = sanitizeContent(item.tool);
                                item.reason = sanitizeContent(item.reason);
                                if (item.alternatives !== undefined && typeof item.alternatives !== "string") {
                                    errors.push(`Line ${i + 1}: missing-tool 'alternatives' must be a string`);
                                    continue;
                                }
                                if (item.alternatives) {
                                    item.alternatives = sanitizeContent(item.alternatives);
                                }
                                break;
                            case "upload-asset":
                                if (!item.path || typeof item.path !== "string") {
                                    errors.push(`Line ${i + 1}: upload-asset requires a 'path' string field`);
                                    continue;
                                }
                                if (item.fileName !== undefined && typeof item.fileName !== "string") {
                                    errors.push(`Line ${i + 1}: upload-asset 'fileName' must be a string`);
                                    continue;
                                }
                                if (item.sha !== undefined && typeof item.sha !== "string") {
                                    errors.push(`Line ${i + 1}: upload-asset 'sha' must be a string`);
                                    continue;
                                }
                                if (item.size !== undefined && typeof item.size !== "number") {
                                    errors.push(`Line ${i + 1}: upload-asset 'size' must be a number`);
                                    continue;
                                }
                                if (item.url !== undefined && typeof item.url !== "string") {
                                    errors.push(`Line ${i + 1}: upload-asset 'url' must be a string`);
                                    continue;
                                }
                                if (item.targetFileName !== undefined && typeof item.targetFileName !== "string") {
                                    errors.push(`Line ${i + 1}: upload-asset 'targetFileName' must be a string`);
                                    continue;
                                }
                                item.path = sanitizeContent(item.path);
                                if (item.fileName)
                                    item.fileName = sanitizeContent(item.fileName);
                                if (item.url)
                                    item.url = sanitizeContent(item.url);
                                if (item.targetFileName)
                                    item.targetFileName = sanitizeContent(item.targetFileName);
                                break;
                            default:
                                errors.push(`Line ${i + 1}: Unknown output type '${itemType}'`);
                                continue;
                        }
                        parsedItems.push(item);
                    }
                    catch (error) {
                        const errorMsg = error instanceof Error ? error.message : String(error);
                        errors.push(`Line ${i + 1}: ${errorMsg}`);
                    }
                }
                if (errors.length > 0) {
                    core.warning(`Found ${errors.length} validation errors:`);
                    errors.forEach(error => core.warning(`  ${error}`));
                    if (errors.length > 0) {
                        core.setFailed(errors.map(e => `  - ${e}`).join("\n"));
                        return;
                    }
                }
                core.info(`Successfully parsed ${parsedItems.length} valid output items`);
                const validatedOutput = {
                    items: parsedItems,
                    errors: errors,
                };
                const agentOutputFile = "/tmp/agent_output.json";
                const validatedOutputJson = JSON.stringify(validatedOutput);
                try {
                    fs.mkdirSync("/tmp", { recursive: true });
                    fs.writeFileSync(agentOutputFile, validatedOutputJson, "utf8");
                    core.info(`Stored validated output to: ${agentOutputFile}`);
                    core.exportVariable("GITHUB_AW_AGENT_OUTPUT", agentOutputFile);
                }
                catch (error) {
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    core.error(`Failed to write agent output file: ${errorMsg}`);
                }
                core.setOutput("output", JSON.stringify(validatedOutput));
                core.setOutput("raw_output", outputContent);
                try {
                    await core.summary
                        .addRaw("## Processed Output\n\n")
                        .addRaw("```json\n")
                        .addRaw(JSON.stringify(validatedOutput))
                        .addRaw("\n```\n")
                        .write();
                    core.info("Successfully wrote processed output to step summary");
                }
                catch (error) {
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    core.warning(`Failed to write to step summary: ${errorMsg}`);
                }
            }
            (async () => {
                await collectNdjsonOutputMain();
            })();
      - name: Upload sanitized agent output
        if: always() && env.GITHUB_AW_AGENT_OUTPUT
        uses: actions/upload-artifact@v4
        with:
          name: agent_output.json
          path: ${{ env.GITHUB_AW_AGENT_OUTPUT }}
          if-no-files-found: warn
      - name: Upload MCP logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mcp-logs
          path: /tmp/mcp-logs/
          if-no-files-found: ignore
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/dev.log
        with:
          script: |
            function parseClaudeLogMain() {
                const fs = require("fs");
                try {
                    const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                    if (!logFile) {
                        core.info("No agent log file specified");
                        return;
                    }
                    if (!fs.existsSync(logFile)) {
                        core.info(`Log file not found: ${logFile}`);
                        return;
                    }
                    const logContent = fs.readFileSync(logFile, "utf8");
                    const result = parseClaudeLog(logContent);
                    core.summary.addRaw(result.markdown).write();
                    if (result.mcpFailures && result.mcpFailures.length > 0) {
                        const failedServers = result.mcpFailures.join(", ");
                        core.setFailed(`MCP server(s) failed to launch: ${failedServers}`);
                    }
                }
                catch (error) {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    core.setFailed(errorMessage);
                }
            }
            function parseClaudeLog(logContent) {
                try {
                    let logEntries;
                    try {
                        logEntries = JSON.parse(logContent);
                        if (!Array.isArray(logEntries)) {
                            throw new Error("Not a JSON array");
                        }
                    }
                    catch (jsonArrayError) {
                        logEntries = [];
                        const lines = logContent.split("\n");
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            if (trimmedLine === "") {
                                continue;
                            }
                            try {
                                const entry = JSON.parse(trimmedLine);
                                if (typeof entry === "object" && entry !== null) {
                                    logEntries.push(entry);
                                }
                            }
                            catch (jsonError) {
                                if (trimmedLine.includes("level=") ||
                                    trimmedLine.includes("msg=") ||
                                    trimmedLine.includes("time=")) {
                                    const entry = {};
                                    const parts = trimmedLine.split(/\s+/);
                                    for (const part of parts) {
                                        const [key, ...valueParts] = part.split("=");
                                        if (valueParts.length > 0) {
                                            const value = valueParts.join("=").replace(/^"(.*)"$/, "$1");
                                            entry[key] = value;
                                        }
                                    }
                                    logEntries.push(entry);
                                }
                                else {
                                    logEntries.push({
                                        level: "debug",
                                        msg: trimmedLine,
                                        time: new Date().toISOString(),
                                    });
                                }
                            }
                        }
                    }
                    let markdown = "## 🤖 Claude Agent Execution Log\n\n";
                    const mcpFailures = [];
                    const toolCalls = {};
                    const errorMessages = [];
                    const mcpServers = [];
                    for (const entry of logEntries) {
                        const msg = entry.msg || "";
                        const level = entry.level || "info";
                        if (msg.includes("launching MCP server") || msg.includes("MCP server started")) {
                            const serverMatch = msg.match(/server[:\s]+([^\s,]+)/i);
                            if (serverMatch && !mcpServers.includes(serverMatch[1])) {
                                mcpServers.push(serverMatch[1]);
                            }
                        }
                        if (level === "error" &&
                            (msg.includes("MCP server") || msg.includes("MCP") || msg.includes("failed to launch"))) {
                            const serverMatch = msg.match(/server[:\s]+([^\s,]+)/i);
                            if (serverMatch) {
                                mcpFailures.push(serverMatch[1]);
                            }
                            else {
                                mcpFailures.push("unknown server");
                            }
                        }
                        if (msg.includes("calling tool") || msg.includes("tool call")) {
                            const toolMatch = msg.match(/tool[:\s]+([^\s,()]+)/i);
                            if (toolMatch) {
                                const tool = toolMatch[1];
                                toolCalls[tool] = (toolCalls[tool] || 0) + 1;
                            }
                        }
                        if (level === "error" && !errorMessages.includes(msg)) {
                            errorMessages.push(msg);
                        }
                    }
                    if (mcpServers.length > 0) {
                        markdown += "### 🔧 MCP Servers\n\n";
                        for (const server of mcpServers) {
                            const status = mcpFailures.includes(server) ? "❌ Failed" : "✅ Running";
                            markdown += `- **${server}**: ${status}\n`;
                        }
                        markdown += "\n";
                    }
                    if (Object.keys(toolCalls).length > 0) {
                        markdown += "### 🛠️ Tool Usage Summary\n\n";
                        const sortedTools = Object.entries(toolCalls).sort((a, b) => b[1] - a[1]);
                        for (const [tool, count] of sortedTools) {
                            markdown += `- **${tool}**: ${count} call${count !== 1 ? 's' : ''}\n`;
                        }
                        markdown += "\n";
                    }
                    if (errorMessages.length > 0) {
                        markdown += "### ❌ Errors\n\n";
                        for (const error of errorMessages) {
                            markdown += `- ${error}\n`;
                        }
                        markdown += "\n";
                    }
                    markdown += "### 📋 Execution Details\n\n";
                    let currentSection = "";
                    let sectionCount = 0;
                    for (let i = 0; i < logEntries.length; i++) {
                        const entry = logEntries[i];
                        const msg = entry.msg || "";
                        const level = entry.level || "info";
                        const time = entry.time || "";
                        if (msg.includes("calling tool") || msg.includes("tool call")) {
                            const toolMatch = msg.match(/tool[:\s]+([^\s,()]+)/i);
                            if (toolMatch) {
                                const tool = toolMatch[1];
                                if (currentSection !== tool) {
                                    currentSection = tool;
                                    sectionCount++;
                                    markdown += `#### ${sectionCount}. 🔧 Tool: ${tool}\n\n`;
                                }
                            }
                        }
                        else if (msg.includes("executing") || msg.includes("running")) {
                            if (currentSection !== "execution") {
                                currentSection = "execution";
                                sectionCount++;
                                markdown += `#### ${sectionCount}. ⚡ Execution\n\n`;
                            }
                        }
                        const levelEmoji = getLevelEmoji(level);
                        const timeStr = time ? ` \`${time}\`` : "";
                        if (level === "error") {
                            markdown += `${levelEmoji}${timeStr} **ERROR**: ${msg}\n\n`;
                        }
                        else if (level === "warn") {
                            markdown += `${levelEmoji}${timeStr} **WARNING**: ${msg}\n\n`;
                        }
                        else if (msg.length > 200) {
                            markdown += `${levelEmoji}${timeStr} ${msg.substring(0, 200)}...\n\n`;
                        }
                        else {
                            markdown += `${levelEmoji}${timeStr} ${msg}\n\n`;
                        }
                    }
                    markdown += "---\n";
                    markdown += `*Log parsed at ${new Date().toISOString()}*\n`;
                    markdown += `*Total entries: ${logEntries.length}*\n`;
                    return {
                        markdown,
                        mcpFailures,
                    };
                }
                catch (error) {
                    core.error(`Error parsing log: ${error instanceof Error ? error.message : String(error)}`);
                    return {
                        markdown: `## ❌ Log Parsing Error\n\nFailed to parse Claude log: ${error instanceof Error ? error.message : String(error)}\n`,
                        mcpFailures: [],
                    };
                }
            }
            function getLevelEmoji(level) {
                switch (level.toLowerCase()) {
                    case "error":
                        return "❌ ";
                    case "warn":
                    case "warning":
                        return "⚠️ ";
                    case "info":
                        return "ℹ️ ";
                    case "debug":
                        return "🔍 ";
                    default:
                        return "📝 ";
                }
            }
            if (typeof module !== "undefined" && module.exports) {
                module.exports = {
                    parseClaudeLog,
                    getLevelEmoji,
                };
            }
            (async () => {
                parseClaudeLogMain();
            })();
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dev.log
          path: /tmp/dev.log
          if-no-files-found: warn
      - name: Upload safe outputs assets
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe-outputs-assets
          path: /tmp/safe-outputs/assets/
          if-no-files-found: ignore

  create_issue:
    needs: dev
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    timeout-minutes: 10
    outputs:
      issue_number: ${{ steps.create_issue.outputs.issue_number }}
      issue_url: ${{ steps.create_issue.outputs.issue_url }}
    steps:
      - name: Create Output Issue
        id: create_issue
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.dev.outputs.output }}
          GITHUB_AW_ISSUE_TITLE_PREFIX: "[docs] "
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
        with:
          script: |
            async function main() {
                const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
                const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!outputContent) {
                    core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                    return;
                }
                if (outputContent.trim() === "") {
                    core.info("Agent output content is empty");
                    return;
                }
                core.info(`Agent output content length: ${outputContent.length}`);
                let validatedOutput;
                try {
                    validatedOutput = JSON.parse(outputContent);
                }
                catch (error) {
                    core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                    return;
                }
                if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                    core.info("No valid items found in agent output");
                    return;
                }
                const createIssueItems = validatedOutput.items.filter(item => item.type === "create-issue");
                if (createIssueItems.length === 0) {
                    core.info("No create-issue items found in agent output");
                    return;
                }
                core.info(`Found ${createIssueItems.length} create-issue item(s)`);
                if (isStaged) {
                    let summaryContent = "## 🎭 Staged Mode: Create Issues Preview\n\n";
                    summaryContent += "The following issues would be created if staged mode was disabled:\n\n";
                    for (let i = 0; i < createIssueItems.length; i++) {
                        const item = createIssueItems[i];
                        summaryContent += `### Issue ${i + 1}\n`;
                        summaryContent += `**Title:** ${item.title || "No title provided"}\n\n`;
                        if (item.body) {
                            summaryContent += `**Body:**\n${item.body}\n\n`;
                        }
                        if (item.labels && item.labels.length > 0) {
                            summaryContent += `**Labels:** ${item.labels.join(", ")}\n\n`;
                        }
                        summaryContent += "---\n\n";
                    }
                    await core.summary.addRaw(summaryContent).write();
                    core.info("📝 Issue creation preview written to step summary");
                    return;
                }
                const parentIssueNumber = context.payload?.issue?.number;
                const labelsEnv = process.env.GITHUB_AW_ISSUE_LABELS;
                let envLabels = labelsEnv
                    ? labelsEnv
                        .split(",")
                        .map((label) => label.trim())
                        .filter((label) => label)
                    : [];
                const createdIssues = [];
                for (let i = 0; i < createIssueItems.length; i++) {
                    const createIssueItem = createIssueItems[i];
                    core.info(`Processing create-issue item ${i + 1}/${createIssueItems.length}: title=${createIssueItem.title}, bodyLength=${createIssueItem.body.length}`);
                    let labels = [...envLabels];
                    if (createIssueItem.labels && Array.isArray(createIssueItem.labels)) {
                        labels = [...labels, ...createIssueItem.labels].filter(Boolean);
                    }
                    let title = createIssueItem.title ? createIssueItem.title.trim() : "";
                    let bodyLines = createIssueItem.body.split("\n");
                    if (!title) {
                        title = createIssueItem.body || "Agent Output";
                    }
                    const titlePrefix = process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;
                    if (titlePrefix && !title.startsWith(titlePrefix)) {
                        title = titlePrefix + title;
                    }
                    if (parentIssueNumber) {
                        core.info("Detected issue context, parent issue #" + parentIssueNumber);
                        bodyLines.push(`Related to #${parentIssueNumber}`);
                    }
                    const runId = context.runId;
                    const runUrl = context.payload.repository
                        ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                        : `https://github.com/actions/runs/${runId}`;
                    bodyLines.push(``, ``, `> Generated by Agentic Workflow [Run](${runUrl})`, "");
                    const body = bodyLines.join("\n").trim();
                    core.info(`Creating issue with title: ${title}`);
                    core.info(`Labels: ${labels}`);
                    core.info(`Body length: ${body.length}`);
                    try {
                        const { data: issue } = await github.rest.issues.create({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            title: title,
                            body: body,
                            labels: labels,
                        });
                        core.info("Created issue #" + issue.number + ": " + issue.html_url);
                        createdIssues.push(issue);
                        if (parentIssueNumber) {
                            try {
                                await github.rest.issues.createComment({
                                    owner: context.repo.owner,
                                    repo: context.repo.repo,
                                    issue_number: parentIssueNumber,
                                    body: `Created related issue: #${issue.number}`,
                                });
                                core.info("Added comment to parent issue #" + parentIssueNumber);
                            }
                            catch (error) {
                                core.info(`Warning: Could not add comment to parent issue: ${error instanceof Error ? error.message : String(error)}`);
                            }
                        }
                        if (i === createIssueItems.length - 1) {
                            core.setOutput("issue_number", issue.number);
                            core.setOutput("issue_url", issue.html_url);
                        }
                    }
                    catch (error) {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        if (errorMessage.includes("Issues has been disabled in this repository")) {
                            core.info(`⚠ Cannot create issue "${title}": Issues are disabled for this repository`);
                            core.info("Consider enabling issues in repository settings if you want to create issues automatically");
                            continue;
                        }
                        core.error(`✗ Failed to create issue "${title}": ${errorMessage}`);
                        throw error;
                    }
                }
                if (createdIssues.length > 0) {
                    let summaryContent = "\n\n## GitHub Issues\n";
                    for (const issue of createdIssues) {
                        summaryContent += `- Issue #${issue.number}: [${issue.title}](${issue.html_url})\n`;
                    }
                    await core.summary.addRaw(summaryContent).write();
                }
                core.info(`Successfully created ${createdIssues.length} issue(s)`);
            }
            (async () => {
                await main();
            })();

  upload_assets:
    needs: dev
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for creating orphaned branch and pushing assets
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.upload_assets.outputs.branch_name }}
      published_count: ${{ steps.upload_assets.outputs.published_count }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Download assets
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: safe-outputs-assets
          path: /tmp/safe-outputs/assets/
      - name: List downloaded asset files
        continue-on-error: true
        run: |
          echo "Downloaded asset files:"
          ls -la /tmp/safe-outputs/assets/
      - name: Upload Assets to Orphaned Branch
        id: upload_assets
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.dev.outputs.output }}
          GITHUB_AW_ASSETS_BRANCH: "assets/${{ github.workflow }}"
          GITHUB_AW_ASSETS_MAX_SIZE_KB: 10240
          GITHUB_AW_ASSETS_ALLOWED_EXTS: ".png,.jpg,.jpeg"
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
        with:
          script: |
            async function uploadAssetsMain() {
                const fs = require("fs");
                const path = require("path");
                const crypto = require("crypto");
                const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
                const branchName = process.env.GITHUB_AW_ASSETS_BRANCH;
                if (!branchName || typeof branchName !== "string") {
                    core.setFailed("GITHUB_AW_ASSETS_BRANCH environment variable is required but not set");
                    return;
                }
                core.info(`Using assets branch: ${branchName}`);
                const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!outputContent) {
                    core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                    core.setOutput("upload_count", "0");
                    core.setOutput("branch_name", branchName);
                    return;
                }
                if (outputContent.trim() === "") {
                    core.info("Agent output content is empty");
                    core.setOutput("upload_count", "0");
                    core.setOutput("branch_name", branchName);
                    return;
                }
                core.info(`Agent output content length: ${outputContent.length}`);
                let validatedOutput;
                try {
                    validatedOutput = JSON.parse(outputContent);
                }
                catch (error) {
                    core.setFailed(`Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`);
                    return;
                }
                if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                    core.info("No valid items found in agent output");
                    core.setOutput("upload_count", "0");
                    core.setOutput("branch_name", branchName);
                    return;
                }
                const uploadAssetItems = validatedOutput.items.filter(item => item.type === "upload-asset");
                if (uploadAssetItems.length === 0) {
                    core.info("No upload-asset items found in agent output");
                    core.setOutput("upload_count", "0");
                    core.setOutput("branch_name", branchName);
                    return;
                }
                core.info(`Found ${uploadAssetItems.length} upload-asset item(s)`);
                let uploadCount = 0;
                let hasChanges = false;
                try {
                    try {
                        await exec.exec(`git rev-parse --verify origin/${branchName}`);
                        await exec.exec(`git checkout -B ${branchName} origin/${branchName}`);
                        core.info(`Checked out existing branch from origin: ${branchName}`);
                    }
                    catch (originError) {
                        core.info(`Creating new orphaned branch: ${branchName}`);
                        await exec.exec(`git checkout --orphan ${branchName}`);
                        await exec.exec(`git rm -rf .`);
                        await exec.exec(`git clean -fdx`);
                    }
                    for (const asset of uploadAssetItems) {
                        try {
                            const { fileName, sha, size, targetFileName } = asset;
                            if (!fileName || !sha || !targetFileName) {
                                core.error(`Invalid asset entry missing required fields: ${JSON.stringify(asset)}`);
                                continue;
                            }
                            const assetSourcePath = path.join("/tmp/safe-outputs/assets", fileName);
                            if (!fs.existsSync(assetSourcePath)) {
                                core.warning(`Asset file not found: ${assetSourcePath}`);
                                continue;
                            }
                            const fileContent = fs.readFileSync(assetSourcePath);
                            const computedSha = crypto.createHash("sha256").update(fileContent).digest("hex");
                            if (computedSha !== sha) {
                                core.warning(`SHA mismatch for ${fileName}: expected ${sha}, got ${computedSha}`);
                                continue;
                            }
                            if (fs.existsSync(targetFileName)) {
                                core.info(`Asset ${targetFileName} already exists, skipping`);
                                continue;
                            }
                            fs.copyFileSync(assetSourcePath, targetFileName);
                            await exec.exec(`git add "${targetFileName}"`);
                            uploadCount++;
                            hasChanges = true;
                            core.info(`Added asset: ${targetFileName} (${size} bytes)`);
                        }
                        catch (error) {
                            core.warning(`Failed to process asset ${asset.fileName}: ${error instanceof Error ? error.message : String(error)}`);
                        }
                    }
                    if (hasChanges) {
                        const commitMessage = `[skip-ci] Add ${uploadCount} asset(s)`;
                        await exec.exec(`git`, [`commit`, `-m`, `"${commitMessage}"`]);
                        if (isStaged) {
                            core.summary.addRaw("## Staged Asset Publication");
                        }
                        else {
                            await exec.exec(`git push origin ${branchName}`);
                            core.summary
                                .addRaw("## Assets")
                                .addRaw(`Successfully uploaded **${uploadCount}** assets to branch \`${branchName}\``)
                                .addRaw("");
                            core.info(`Successfully uploaded ${uploadCount} assets to branch ${branchName}`);
                        }
                        for (const asset of uploadAssetItems) {
                            if (asset.fileName && asset.sha && asset.size && asset.url) {
                                core.summary.addRaw(`- [\`${asset.fileName}\`](${asset.url}) → \`${asset.targetFileName}\` (${asset.size} bytes)`);
                            }
                        }
                        core.summary.write();
                    }
                    else {
                        core.info("No new assets to upload");
                    }
                }
                catch (error) {
                    core.setFailed(`Failed to upload assets: ${error instanceof Error ? error.message : String(error)}`);
                    return;
                }
                core.setOutput("upload_count", uploadCount.toString());
                core.setOutput("branch_name", branchName);
            }
            (async () => {
                await uploadAssetsMain();
            })();

