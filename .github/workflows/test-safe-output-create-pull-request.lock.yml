# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Test Safe Output - Create Pull Request"
on:
  push:
    branches:
    - main
    - develop
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}"

run-name: "Test Safe Output - Create Pull Request"

jobs:
  task:
    runs-on: ubuntu-latest
    permissions:
      actions: write  # Required for github.rest.actions.cancelWorkflowRun()
    steps:
      - name: Check team membership for workflow
        id: check-team-member
        uses: actions/github-script@v7
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function setCancelled(message) {
              try {
                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId,
                });
                core.info(`Cancellation requested for this workflow run: ${message}`);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to cancel workflow run: ${errorMessage}`);
                core.setFailed(message); // Fallback if API call fails
              }
            }
            async function main() {
              const { eventName } = context;
              // skip check for safe events
              const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
              if (safeEvents.includes(eventName)) {
                core.info(`✅ Event ${eventName} does not require validation`);
                return;
              }
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
              const requiredPermissions = requiredPermissionsEnv
                ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "")
                : [];
              if (!requiredPermissions || requiredPermissions.length === 0) {
                core.error(
                  "❌ Configuration error: Required permissions not specified. Contact repository administrator."
                );
                await setCancelled(
                  "Configuration error: Required permissions not specified"
                );
                return;
              }
              // Check if the actor has the required repository permissions
              try {
                core.debug(
                  `Checking if user '${actor}' has required permissions for ${owner}/${repo}`
                );
                core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                const repoPermission =
                  await github.rest.repos.getCollaboratorPermissionLevel({
                    owner: owner,
                    repo: repo,
                    username: actor,
                  });
                const permission = repoPermission.data.permission;
                core.debug(`Repository permission level: ${permission}`);
                // Check if user has one of the required permission levels
                for (const requiredPerm of requiredPermissions) {
                  if (
                    permission === requiredPerm ||
                    (requiredPerm === "maintainer" && permission === "maintain")
                  ) {
                    core.info(`✅ User has ${permission} access to repository`);
                    return;
                  }
                }
                core.warning(
                  `User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`
                );
              } catch (repoError) {
                const errorMessage =
                  repoError instanceof Error ? repoError.message : String(repoError);
                core.error(`Repository permission check failed: ${errorMessage}`);
                await setCancelled(`Repository permission check failed: ${errorMessage}`);
                return;
              }
              // Cancel the workflow when permission check fails
              core.warning(
                `❌ Access denied: Only authorized users can trigger this workflow. User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
              await setCancelled(
                `Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
            }
            await main();

  test-safe-output-create-pull-request:
    needs: task
    runs-on: ubuntu-latest
    permissions: read-all
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v7
        with:
          script: |
            function main() {
              const fs = require("fs");
              const crypto = require("crypto");
              // Generate a random filename for the output file
              const randomId = crypto.randomBytes(8).toString("hex");
              const outputFile = `/tmp/aw_output_${randomId}.txt`;
              // Ensure the /tmp directory exists
              fs.mkdirSync("/tmp", { recursive: true });
              // We don't create the file, as the name is sufficiently random
              // and some engines (Claude) fails first Write to the file
              // if it exists and has not been read.
              // Set the environment variable for subsequent steps
              core.exportVariable("GITHUB_AW_SAFE_OUTPUTS", outputFile);
              // Also set as step output for reference
              core.setOutput("output_file", outputFile);
            }
            main();
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          
          # Write safe-outputs MCP server
          cat > /tmp/safe-outputs-mcp-server.cjs << 'EOF'
            /* Safe-Outputs MCP Tools-only server over stdio
               - No external deps (zero dependencies)
               - JSON-RPC 2.0 + Content-Length framing (LSP-style)
               - Implements: initialize, tools/list, tools/call
               - Each safe-output type is exposed as a tool
               - Tool calls append to GITHUB_AW_SAFE_OUTPUTS file
               - Controlled by GITHUB_AW_SAFE_OUTPUTS_CONFIG environment variable
               - Node 18+ recommended
            */
            const fs = require("fs");
            const path = require("path");
            // --------- Basic types ---------
            /* 
            type JSONValue = null | boolean | number | string | JSONValue[] | { [k: string]: JSONValue };
            type JSONRPCRequest = {
              jsonrpc: "2.0";
              id?: number | string;
              method: string;
              params?: any;
            };
            type JSONRPCResponse = {
              jsonrpc: "2.0";
              id: number | string | null;
              result?: any;
              error?: { code: number; message: string; data?: any };
            };
            */
            // --------- Basic message framing (Content-Length) ----------
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();
            function writeMessage(obj) {
              const json = JSON.stringify(obj);
              const bytes = encoder.encode(json);
              const header = `Content-Length: ${bytes.byteLength}\r\n\r\n`;
              const headerBytes = encoder.encode(header);
              // Write headers then body to stdout (synchronously to preserve order)
              fs.writeSync(1, headerBytes);
              fs.writeSync(1, bytes);
            }
            let buffer = Buffer.alloc(0);
            function onData(chunk) {
              buffer = Buffer.concat([buffer, chunk]);
              // Parse multiple framed messages if present
              while (true) {
                const sep = buffer.indexOf("\r\n\r\n");
                if (sep === -1) break;
                const headerPart = buffer.slice(0, sep).toString("utf8");
                const match = headerPart.match(/Content-Length:\s*(\d+)/i);
                if (!match) {
                  // Malformed header; drop this chunk
                  buffer = buffer.slice(sep + 4);
                  continue;
                }
                const length = parseInt(match[1], 10);
                const total = sep + 4 + length;
                if (buffer.length < total) break; // wait for full body
                const body = buffer.slice(sep + 4, total);
                buffer = buffer.slice(total);
                try {
                  const msg = JSON.parse(body.toString("utf8"));
                  handleMessage(msg);
                } catch (e) {
                  // If we can't parse, there's no id to reply to reliably
                  const err = {
                    jsonrpc: "2.0",
                    id: null,
                    error: { code: -32700, message: "Parse error", data: String(e) },
                  };
                  writeMessage(err);
                }
              }
            }
            process.stdin.on("data", onData);
            process.stdin.on("error", () => {
              // Non-fatal
            });
            process.stdin.resume();
            // ---------- Utilities ----------
            function replyResult(id, result) {
              if (id === undefined || id === null) return; // notification
              const res = { jsonrpc: "2.0", id, result };
              writeMessage(res);
            }
            function replyError(id, code, message, data) {
              const res = {
                jsonrpc: "2.0",
                id: id ?? null,
                error: { code, message, data },
              };
              writeMessage(res);
            }
            // ---------- Safe-outputs configuration ----------
            let safeOutputsConfig = {};
            let outputFile = null;
            // Parse configuration from environment
            function initializeSafeOutputsConfig() {
              // Get safe-outputs configuration
              const configEnv = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
              if (configEnv) {
                try {
                  safeOutputsConfig = JSON.parse(configEnv);
                } catch (e) {
                  // Log error to stderr (not part of protocol)
                  process.stderr.write(
                    `[safe-outputs-mcp] Error parsing config: ${e.message}\n`
                  );
                  safeOutputsConfig = {};
                }
              }
              // Get output file path
              outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              if (!outputFile) {
                process.stderr.write(
                  `[safe-outputs-mcp] Warning: GITHUB_AW_SAFE_OUTPUTS not set\n`
                );
              }
            }
            // Check if a safe-output type is enabled
            function isToolEnabled(toolType) {
              return safeOutputsConfig[toolType] && safeOutputsConfig[toolType].enabled;
            }
            // Get max limit for a tool type
            function getToolMaxLimit(toolType) {
              const config = safeOutputsConfig[toolType];
              return config && config.max ? config.max : 0; // 0 means unlimited
            }
            // Append safe output entry to file
            function appendSafeOutput(entry) {
              if (!outputFile) {
                throw new Error("No output file configured");
              }
              // Ensure the entry is a complete JSON object
              const jsonLine = JSON.stringify(entry) + "\n";
              try {
                fs.appendFileSync(outputFile, jsonLine);
              } catch (error) {
                throw new Error(`Failed to write to output file: ${error.message}`);
              }
            }
            // ---------- Tool registry ----------
            const TOOLS = Object.create(null);
            // Create-issue tool
            TOOLS["create_issue"] = {
              name: "create_issue",
              description: "Create a new GitHub issue",
              inputSchema: {
                type: "object",
                required: ["title", "body"],
                properties: {
                  title: { type: "string", description: "Issue title" },
                  body: { type: "string", description: "Issue body/description" },
                  labels: {
                    type: "array",
                    items: { type: "string" },
                    description: "Issue labels",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("create-issue")) {
                  throw new Error("create-issue safe-output is not enabled");
                }
                const entry = {
                  type: "create-issue",
                  title: args.title,
                  body: args.body,
                };
                if (args.labels && Array.isArray(args.labels)) {
                  entry.labels = args.labels;
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: `Issue creation queued: "${args.title}"`,
                    },
                  ],
                };
              },
            };
            // Create-discussion tool
            TOOLS["create_discussion"] = {
              name: "create_discussion",
              description: "Create a new GitHub discussion",
              inputSchema: {
                type: "object",
                required: ["title", "body"],
                properties: {
                  title: { type: "string", description: "Discussion title" },
                  body: { type: "string", description: "Discussion body/content" },
                  category: { type: "string", description: "Discussion category" },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("create-discussion")) {
                  throw new Error("create-discussion safe-output is not enabled");
                }
                const entry = {
                  type: "create-discussion",
                  title: args.title,
                  body: args.body,
                };
                if (args.category) {
                  entry.category = args.category;
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: `Discussion creation queued: "${args.title}"`,
                    },
                  ],
                };
              },
            };
            // Add-issue-comment tool
            TOOLS["add_issue_comment"] = {
              name: "add_issue_comment",
              description: "Add a comment to a GitHub issue or pull request",
              inputSchema: {
                type: "object",
                required: ["body"],
                properties: {
                  body: { type: "string", description: "Comment body/content" },
                  issue_number: {
                    type: "number",
                    description: "Issue or PR number (optional for current context)",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("add-issue-comment")) {
                  throw new Error("add-issue-comment safe-output is not enabled");
                }
                const entry = {
                  type: "add-issue-comment",
                  body: args.body,
                };
                if (args.issue_number) {
                  entry.issue_number = args.issue_number;
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: "Comment creation queued",
                    },
                  ],
                };
              },
            };
            // Create-pull-request tool
            TOOLS["create_pull_request"] = {
              name: "create_pull_request",
              description: "Create a new GitHub pull request",
              inputSchema: {
                type: "object",
                required: ["title", "body"],
                properties: {
                  title: { type: "string", description: "Pull request title" },
                  body: { type: "string", description: "Pull request body/description" },
                  branch: {
                    type: "string",
                    description:
                      "Optional branch name (will be auto-generated if not provided)",
                  },
                  labels: {
                    type: "array",
                    items: { type: "string" },
                    description: "Optional labels to add to the PR",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("create-pull-request")) {
                  throw new Error("create-pull-request safe-output is not enabled");
                }
                const entry = {
                  type: "create-pull-request",
                  title: args.title,
                  body: args.body,
                };
                if (args.branch) entry.branch = args.branch;
                if (args.labels && Array.isArray(args.labels)) {
                  entry.labels = args.labels;
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: `Pull request creation queued: "${args.title}"`,
                    },
                  ],
                };
              },
            };
            // Create-pull-request-review-comment tool
            TOOLS["create_pull_request_review_comment"] = {
              name: "create_pull_request_review_comment",
              description: "Create a review comment on a GitHub pull request",
              inputSchema: {
                type: "object",
                required: ["path", "line", "body"],
                properties: {
                  path: { type: "string", description: "File path for the review comment" },
                  line: {
                    type: ["number", "string"],
                    description: "Line number for the comment",
                  },
                  body: { type: "string", description: "Comment body content" },
                  start_line: {
                    type: ["number", "string"],
                    description: "Optional start line for multi-line comments",
                  },
                  side: {
                    type: "string",
                    enum: ["LEFT", "RIGHT"],
                    description: "Optional side of the diff: LEFT or RIGHT",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("create-pull-request-review-comment")) {
                  throw new Error(
                    "create-pull-request-review-comment safe-output is not enabled"
                  );
                }
                const entry = {
                  type: "create-pull-request-review-comment",
                  path: args.path,
                  line: args.line,
                  body: args.body,
                };
                if (args.start_line !== undefined) entry.start_line = args.start_line;
                if (args.side) entry.side = args.side;
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: "PR review comment creation queued",
                    },
                  ],
                };
              },
            };
            // Create-code-scanning-alert tool
            TOOLS["create_code_scanning_alert"] = {
              name: "create_code_scanning_alert",
              description: "Create a code scanning alert",
              inputSchema: {
                type: "object",
                required: ["file", "line", "severity", "message"],
                properties: {
                  file: {
                    type: "string",
                    description: "File path where the issue was found",
                  },
                  line: {
                    type: ["number", "string"],
                    description: "Line number where the issue was found",
                  },
                  severity: {
                    type: "string",
                    enum: ["error", "warning", "info", "note"],
                    description: "Severity level",
                  },
                  message: {
                    type: "string",
                    description: "Alert message describing the issue",
                  },
                  column: {
                    type: ["number", "string"],
                    description: "Optional column number",
                  },
                  ruleIdSuffix: {
                    type: "string",
                    description: "Optional rule ID suffix for uniqueness",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("create-code-scanning-alert")) {
                  throw new Error("create-code-scanning-alert safe-output is not enabled");
                }
                const entry = {
                  type: "create-code-scanning-alert",
                  file: args.file,
                  line: args.line,
                  severity: args.severity,
                  message: args.message,
                };
                if (args.column !== undefined) entry.column = args.column;
                if (args.ruleIdSuffix) entry.ruleIdSuffix = args.ruleIdSuffix;
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: `Code scanning alert creation queued: "${args.message}"`,
                    },
                  ],
                };
              },
            };
            // Add-issue-label tool
            TOOLS["add_issue_label"] = {
              name: "add_issue_label",
              description: "Add labels to a GitHub issue or pull request",
              inputSchema: {
                type: "object",
                required: ["labels"],
                properties: {
                  labels: {
                    type: "array",
                    items: { type: "string" },
                    description: "Labels to add",
                  },
                  issue_number: {
                    type: "number",
                    description: "Issue or PR number (optional for current context)",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("add-issue-label")) {
                  throw new Error("add-issue-label safe-output is not enabled");
                }
                const entry = {
                  type: "add-issue-label",
                  labels: args.labels,
                };
                if (args.issue_number) {
                  entry.issue_number = args.issue_number;
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: `Labels queued for addition: ${args.labels.join(", ")}`,
                    },
                  ],
                };
              },
            };
            // Update-issue tool
            TOOLS["update_issue"] = {
              name: "update_issue",
              description: "Update a GitHub issue",
              inputSchema: {
                type: "object",
                properties: {
                  status: {
                    type: "string",
                    enum: ["open", "closed"],
                    description: "Optional new issue status",
                  },
                  title: { type: "string", description: "Optional new issue title" },
                  body: { type: "string", description: "Optional new issue body" },
                  issue_number: {
                    type: ["number", "string"],
                    description: "Optional issue number for target '*'",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("update-issue")) {
                  throw new Error("update-issue safe-output is not enabled");
                }
                const entry = {
                  type: "update-issue",
                };
                if (args.status) entry.status = args.status;
                if (args.title) entry.title = args.title;
                if (args.body) entry.body = args.body;
                if (args.issue_number !== undefined) entry.issue_number = args.issue_number;
                // Must have at least one field to update
                if (!args.status && !args.title && !args.body) {
                  throw new Error(
                    "Must specify at least one field to update (status, title, or body)"
                  );
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: "Issue update queued",
                    },
                  ],
                };
              },
            };
            // Push-to-pr-branch tool
            TOOLS["push_to_pr_branch"] = {
              name: "push_to_pr_branch",
              description: "Push changes to a pull request branch",
              inputSchema: {
                type: "object",
                properties: {
                  message: { type: "string", description: "Optional commit message" },
                  pull_request_number: {
                    type: ["number", "string"],
                    description: "Optional pull request number for target '*'",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("push-to-pr-branch")) {
                  throw new Error("push-to-pr-branch safe-output is not enabled");
                }
                const entry = {
                  type: "push-to-pr-branch",
                };
                if (args.message) entry.message = args.message;
                if (args.pull_request_number !== undefined)
                  entry.pull_request_number = args.pull_request_number;
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: "Branch push queued",
                    },
                  ],
                };
              },
            };
            // Missing-tool tool
            TOOLS["missing_tool"] = {
              name: "missing_tool",
              description:
                "Report a missing tool or functionality needed to complete tasks",
              inputSchema: {
                type: "object",
                required: ["tool", "reason"],
                properties: {
                  tool: { type: "string", description: "Name of the missing tool" },
                  reason: { type: "string", description: "Why this tool is needed" },
                  alternatives: {
                    type: "string",
                    description: "Possible alternatives or workarounds",
                  },
                },
                additionalProperties: false,
              },
              async handler(args) {
                if (!isToolEnabled("missing-tool")) {
                  throw new Error("missing-tool safe-output is not enabled");
                }
                const entry = {
                  type: "missing-tool",
                  tool: args.tool,
                  reason: args.reason,
                };
                if (args.alternatives) {
                  entry.alternatives = args.alternatives;
                }
                appendSafeOutput(entry);
                return {
                  content: [
                    {
                      type: "text",
                      text: `Missing tool reported: ${args.tool}`,
                    },
                  ],
                };
              },
            };
            // ---------- MCP handlers ----------
            const SERVER_INFO = { name: "safe-outputs-mcp-server", version: "1.0.0" };
            function handleMessage(req) {
              const { id, method, params } = req;
              try {
                if (method === "initialize") {
                  // Initialize configuration on first connection
                  initializeSafeOutputsConfig();
                  const clientInfo = params?.clientInfo ?? {};
                  const protocolVersion = params?.protocolVersion ?? undefined;
                  // Advertise that we only support tools (list + call)
                  const result = {
                    serverInfo: SERVER_INFO,
                    // If the client sent a protocolVersion, echo it back for transparency.
                    ...(protocolVersion ? { protocolVersion } : {}),
                    capabilities: {
                      tools: {}, // minimal placeholder object; clients usually just gate on presence
                    },
                  };
                  replyResult(id, result);
                  return;
                }
                if (method === "tools/list") {
                  const list = [];
                  // Only expose tools that are enabled in the configuration
                  Object.values(TOOLS).forEach(tool => {
                    const toolType = tool.name.replace(/_/g, "-"); // Convert to kebab-case
                    if (isToolEnabled(toolType)) {
                      list.push({
                        name: tool.name,
                        description: tool.description,
                        inputSchema: tool.inputSchema,
                      });
                    }
                  });
                  replyResult(id, { tools: list });
                  return;
                }
                if (method === "tools/call") {
                  const name = params?.name;
                  const args = params?.arguments ?? {};
                  if (!name || typeof name !== "string") {
                    replyError(id, -32602, "Invalid params: 'name' must be a string");
                    return;
                  }
                  const tool = TOOLS[name];
                  if (!tool) {
                    replyError(id, -32601, `Tool not found: ${name}`);
                    return;
                  }
                  (async () => {
                    try {
                      const result = await tool.handler(args);
                      // Result shape expected by typical MCP clients for tool calls
                      replyResult(id, { content: result.content });
                    } catch (e) {
                      replyError(id, -32000, `Tool '${name}' failed`, {
                        message: String(e?.message ?? e),
                      });
                    }
                  })();
                  return;
                }
                // Unknown method
                replyError(id, -32601, `Method not found: ${method}`);
              } catch (e) {
                replyError(id, -32603, "Internal error", {
                  message: String(e?.message ?? e),
                });
              }
            }
            // Optional: log a startup banner to stderr for debugging (not part of the protocol)
            process.stderr.write(
              `[${SERVER_INFO.name}] v${SERVER_INFO.version} ready on stdio\n`
            );
          EOF
          chmod +x /tmp/safe-outputs-mcp-server.cjs
          
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "safe_outputs": {
                "command": "node",
                "args": ["/tmp/safe-outputs-mcp-server.cjs"]
              },
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-09deac4"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              }
            }
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Test Safe Output - Create Pull Request
          
          This workflow tests the `create-pull-request` safe output functionality using a custom engine that creates file changes and writes to the safe output file.
          
          ## Purpose
          
          This workflow validates the create-pull-request safe output type by:
          - Creating actual file changes to include in the PR
          - Generating a JSON entry with the `create-pull-request` type
          - Including all required fields: title, body, labels, draft status
          - Using staged mode to prevent actual GitHub interactions
          - Demonstrating custom engine safe output writing for PR creation
          
          ## Trigger Events
          
          - **workflow_dispatch**: Manual execution for testing
          - **push**: Responds to pushes on main and develop branches
          
          ## Safe Output Configuration
          
          - **staged: true**: Prevents real GitHub interactions
          - **title-prefix**: Adds "[Test] " prefix to PR titles
          - **labels**: Automatically adds test-safe-output and automation labels
          - **draft: true**: Creates PR as draft
          - **if-no-changes: "warn"**: Warns but succeeds if no changes are detected
          
          ## Custom Engine Implementation
          
          The workflow uses a custom engine with GitHub Actions steps to:
          1. Create test file changes to include in the PR
          2. Generate the appropriate create-pull-request JSON output
          3. Include comprehensive PR description with test information
          4. Append it to the $GITHUB_AW_SAFE_OUTPUTS file
          5. Verify both the output and created files
          
          This demonstrates how custom engines can leverage the safe output system for pull request creation with actual file changes.
          
          
          ---
          
          ## Creating a Pull RequestReporting Missing Tools or Functionality
          
          **IMPORTANT**: To do the actions mentioned in the header of this section, do NOT attempt to use MCP tools, do NOT attempt to use `gh`, do NOT attempt to use the GitHub API. You don't have write access to the GitHub repo. Instead write JSON objects to the file "${{ env.GITHUB_AW_SAFE_OUTPUTS }}". Each line should contain a single JSON object (JSONL format). You can write them one by one as you do them.
          
          **Format**: Write one JSON object per line. Each object must have a `type` field specifying the action type.
          
          ### Available Output Types:
          
          **Creating a Pull Request**
          
          To create a pull request:
          1. Make any file changes directly in the working directory
          2. If you haven't done so already, create a local branch using an appropriate unique name
          3. Add and commit your changes to the branch. Be careful to add exactly the files you intend, and check there are no extra files left un-added. Check you haven't deleted or changed any files you didn't intend to.
          4. Do not push your changes. That will be done later. Instead append the PR specification to the file "${{ env.GITHUB_AW_SAFE_OUTPUTS }}":
          ```json
          {"type": "create-pull-request", "branch": "branch-name", "title": "PR title", "body": "PR body in markdown", "labels": ["optional", "labels"]}
          ```
          5. After you write to that file, read it as JSONL and check it is valid. If it isn't, make any necessary corrections to it to fix it up
          
          **Example JSONL file content:**
          ```
          {"type": "create-pull-request", "title": "Fix typo", "body": "Corrected spelling mistake in documentation"}
          ```
          
          **Important Notes:**
          - Do NOT attempt to use MCP tools, `gh`, or the GitHub API for these actions
          - Each JSON object must be on its own line
          - Only include output types that are configured for this workflow
          - The content of this file will be automatically processed and executed
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "custom",
              engine_name: "Custom Steps",
              model: "",
              version: "",
              workflow_name: "Test Safe Output - Create Pull Request",
              experimental: false,
              supports_tools_whitelist: false,
              supports_http_transport: false,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: true,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Create Test File Changes
        run: |
          # Create a test file to demonstrate PR creation
          echo "# Test file created by safe output test" > test-pr-creation-$(date +%Y%m%d-%H%M%S).md
          echo "This file was created to test the create-pull-request safe output." >> test-pr-creation-$(date +%Y%m%d-%H%M%S).md
          echo "Generated at: $(date)" >> test-pr-creation-$(date +%Y%m%d-%H%M%S).md
          echo "Event: ${{ github.event_name }}" >> test-pr-creation-$(date +%Y%m%d-%H%M%S).md
          echo "Repository: ${{ github.repository }}" >> test-pr-creation-$(date +%Y%m%d-%H%M%S).md
          echo "Run ID: ${{ github.run_id }}" >> test-pr-creation-$(date +%Y%m%d-%H%M%S).md
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
      - name: Generate Create Pull Request Safe Output
        run: |
          echo '{"type": "create-pull-request", "title": "Test Pull Request - Safe Output Validation", "body": "# Test Pull Request - create-pull-request Safe Output\n\nThis pull request was automatically created by the test-safe-output-create-pull-request workflow to validate the create-pull-request safe output functionality.\n\n## Changes Made\n- Created test file with timestamp\n- Demonstrates custom engine file creation capabilities\n- Tests safe output PR creation functionality\n\n## Test Information\n- Safe Output Type: create-pull-request\n- Engine: Custom (GitHub Actions steps)\n- Workflow: test-safe-output-create-pull-request\n- Trigger Event: ${{ github.event_name }}\n- Run ID: ${{ github.run_id }}\n- Staged Mode: true\n\nThis PR should not create actual GitHub interactions due to staged mode.\n\n## Validation\n- ✅ File changes created\n- ✅ JSON output generated\n- ✅ Safe output functionality tested\n\nThis PR can be closed after verification of the safe output functionality.", "labels": ["test-safe-output", "automation"], "draft": true}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
      - name: Verify Safe Output File
        run: |
          echo "Generated safe output entries:"
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            cat "$GITHUB_AW_SAFE_OUTPUTS"
          else
            echo "No safe outputs file found"
          fi

          echo "Test files created:"
          ls -la *.md 2>/dev/null || echo "No .md files found"
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
      - name: Ensure log file exists
        run: |
          echo "Custom steps execution completed" >> /tmp/test-safe-output-create-pull-request.log
          touch /tmp/test-safe-output-create-pull-request.log
      - name: Print Agent output
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Agent Output (JSONL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
          # Ensure there's a newline after the file content if it doesn't end with one
          if [ -s ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ] && [ "$(tail -c1 ${{ env.GITHUB_AW_SAFE_OUTPUTS }})" != "" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo '``````' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      - name: Upload agentic output file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe_output.jsonl
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Ingest agent output
        id: collect_output
        uses: actions/github-script@v7
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-pull-request\":true}"
        with:
          script: |
            async function main() {
              const fs = require("fs");
              /**
               * Sanitizes content for safe output in GitHub Actions
               * @param {string} content - The content to sanitize
               * @returns {string} The sanitized content
               */
              function sanitizeContent(content) {
                if (!content || typeof content !== "string") {
                  return "";
                }
                // Read allowed domains from environment variable
                const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
                const defaultAllowedDomains = [
                  "github.com",
                  "github.io",
                  "githubusercontent.com",
                  "githubassets.com",
                  "github.dev",
                  "codespaces.new",
                ];
                const allowedDomains = allowedDomainsEnv
                  ? allowedDomainsEnv
                      .split(",")
                      .map(d => d.trim())
                      .filter(d => d)
                  : defaultAllowedDomains;
                let sanitized = content;
                // Neutralize @mentions to prevent unintended notifications
                sanitized = neutralizeMentions(sanitized);
                // Remove control characters (except newlines and tabs)
                sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
                // XML character escaping
                sanitized = sanitized
                  .replace(/&/g, "&amp;") // Must be first to avoid double-escaping
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&apos;");
                // URI filtering - replace non-https protocols with "(redacted)"
                sanitized = sanitizeUrlProtocols(sanitized);
                // Domain filtering for HTTPS URIs
                sanitized = sanitizeUrlDomains(sanitized);
                // Limit total length to prevent DoS (0.5MB max)
                const maxLength = 524288;
                if (sanitized.length > maxLength) {
                  sanitized =
                    sanitized.substring(0, maxLength) +
                    "\n[Content truncated due to length]";
                }
                // Limit number of lines to prevent log flooding (65k max)
                const lines = sanitized.split("\n");
                const maxLines = 65000;
                if (lines.length > maxLines) {
                  sanitized =
                    lines.slice(0, maxLines).join("\n") +
                    "\n[Content truncated due to line count]";
                }
                // Remove ANSI escape sequences
                sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
                // Neutralize common bot trigger phrases
                sanitized = neutralizeBotTriggers(sanitized);
                // Trim excessive whitespace
                return sanitized.trim();
                /**
                 * Remove unknown domains
                 * @param {string} s - The string to process
                 * @returns {string} The string with unknown domains redacted
                 */
                function sanitizeUrlDomains(s) {
                  return s.replace(
                    /\bhttps:\/\/([^\/\s\])}'"<>&\x00-\x1f]+)/gi,
                    (match, domain) => {
                      // Extract the hostname part (before first slash, colon, or other delimiter)
                      const hostname = domain.split(/[\/:\?#]/)[0].toLowerCase();
                      // Check if this domain or any parent domain is in the allowlist
                      const isAllowed = allowedDomains.some(allowedDomain => {
                        const normalizedAllowed = allowedDomain.toLowerCase();
                        return (
                          hostname === normalizedAllowed ||
                          hostname.endsWith("." + normalizedAllowed)
                        );
                      });
                      return isAllowed ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Remove unknown protocols except https
                 * @param {string} s - The string to process
                 * @returns {string} The string with non-https protocols redacted
                 */
                function sanitizeUrlProtocols(s) {
                  // Match both protocol:// and protocol: patterns
                  return s.replace(
                    /\b(\w+):(?:\/\/)?[^\s\])}'"<>&\x00-\x1f]+/gi,
                    (match, protocol) => {
                      // Allow https (case insensitive), redact everything else
                      return protocol.toLowerCase() === "https" ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Neutralizes @mentions by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized mentions
                 */
                function neutralizeMentions(s) {
                  // Replace @name or @org/team outside code with `@name`
                  return s.replace(
                    /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                    (_m, p1, p2) => `${p1}\`@${p2}\``
                  );
                }
                /**
                 * Neutralizes bot trigger phrases by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized bot triggers
                 */
                function neutralizeBotTriggers(s) {
                  // Neutralize common bot trigger phrases like "fixes #123", "closes #asdfs", etc.
                  return s.replace(
                    /\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi,
                    (match, action, ref) => `\`${action} #${ref}\``
                  );
                }
              }
              /**
               * Gets the maximum allowed count for a given output type
               * @param {string} itemType - The output item type
               * @param {any} config - The safe-outputs configuration
               * @returns {number} The maximum allowed count
               */
              function getMaxAllowedForType(itemType, config) {
                // Check if max is explicitly specified in config
                if (
                  config &&
                  config[itemType] &&
                  typeof config[itemType] === "object" &&
                  config[itemType].max
                ) {
                  return config[itemType].max;
                }
                // Use default limits for plural-supported types
                switch (itemType) {
                  case "create-issue":
                    return 1; // Only one issue allowed
                  case "add-issue-comment":
                    return 1; // Only one comment allowed
                  case "create-pull-request":
                    return 1; // Only one pull request allowed
                  case "create-pull-request-review-comment":
                    return 10; // Default to 10 review comments allowed
                  case "add-issue-label":
                    return 5; // Only one labels operation allowed
                  case "update-issue":
                    return 1; // Only one issue update allowed
                  case "push-to-pr-branch":
                    return 1; // Only one push to branch allowed
                  case "create-discussion":
                    return 1; // Only one discussion allowed
                  case "missing-tool":
                    return 1000; // Allow many missing tool reports (default: unlimited)
                  case "create-code-scanning-alert":
                    return 1000; // Allow many repository security advisories (default: unlimited)
                  default:
                    return 1; // Default to single item for unknown types
                }
              }
              /**
               * Attempts to repair common JSON syntax issues in LLM-generated content
               * @param {string} jsonStr - The potentially malformed JSON string
               * @returns {string} The repaired JSON string
               */
              function repairJson(jsonStr) {
                let repaired = jsonStr.trim();
                // remove invalid control characters like
                // U+0014 (DC4) — represented here as "\u0014"
                // Escape control characters not allowed in JSON strings (U+0000 through U+001F)
                // Preserve common JSON escapes for \b, \f, \n, \r, \t and use \uXXXX for the rest.
                /** @type {Record<number, string>} */
                const _ctrl = { 8: "\\b", 9: "\\t", 10: "\\n", 12: "\\f", 13: "\\r" };
                repaired = repaired.replace(/[\u0000-\u001F]/g, ch => {
                  const c = ch.charCodeAt(0);
                  return _ctrl[c] || "\\u" + c.toString(16).padStart(4, "0");
                });
                // Fix single quotes to double quotes (must be done first)
                repaired = repaired.replace(/'/g, '"');
                // Fix missing quotes around object keys
                repaired = repaired.replace(
                  /([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g,
                  '$1"$2":'
                );
                // Fix newlines and tabs inside strings by escaping them
                repaired = repaired.replace(/"([^"\\]*)"/g, (match, content) => {
                  if (
                    content.includes("\n") ||
                    content.includes("\r") ||
                    content.includes("\t")
                  ) {
                    const escaped = content
                      .replace(/\\/g, "\\\\")
                      .replace(/\n/g, "\\n")
                      .replace(/\r/g, "\\r")
                      .replace(/\t/g, "\\t");
                    return `"${escaped}"`;
                  }
                  return match;
                });
                // Fix unescaped quotes inside string values
                repaired = repaired.replace(
                  /"([^"]*)"([^":,}\]]*)"([^"]*)"(\s*[,:}\]])/g,
                  (match, p1, p2, p3, p4) => `"${p1}\\"${p2}\\"${p3}"${p4}`
                );
                // Fix wrong bracket/brace types - arrays should end with ] not }
                repaired = repaired.replace(
                  /(\[\s*(?:"[^"]*"(?:\s*,\s*"[^"]*")*\s*),?)\s*}/g,
                  "$1]"
                );
                // Fix missing closing braces/brackets
                const openBraces = (repaired.match(/\{/g) || []).length;
                const closeBraces = (repaired.match(/\}/g) || []).length;
                if (openBraces > closeBraces) {
                  repaired += "}".repeat(openBraces - closeBraces);
                } else if (closeBraces > openBraces) {
                  repaired = "{".repeat(closeBraces - openBraces) + repaired;
                }
                // Fix missing closing brackets for arrays
                const openBrackets = (repaired.match(/\[/g) || []).length;
                const closeBrackets = (repaired.match(/\]/g) || []).length;
                if (openBrackets > closeBrackets) {
                  repaired += "]".repeat(openBrackets - closeBrackets);
                } else if (closeBrackets > openBrackets) {
                  repaired = "[".repeat(closeBrackets - openBrackets) + repaired;
                }
                // Fix trailing commas in objects and arrays (AFTER fixing brackets/braces)
                repaired = repaired.replace(/,(\s*[}\]])/g, "$1");
                return repaired;
              }
              /**
               * Attempts to parse JSON with repair fallback
               * @param {string} jsonStr - The JSON string to parse
               * @returns {Object|undefined} The parsed JSON object, or undefined if parsing fails
               */
              function parseJsonWithRepair(jsonStr) {
                try {
                  // First, try normal JSON.parse
                  return JSON.parse(jsonStr);
                } catch (originalError) {
                  try {
                    // If that fails, try repairing and parsing again
                    const repairedJson = repairJson(jsonStr);
                    return JSON.parse(repairedJson);
                  } catch (repairError) {
                    // If repair also fails, throw the error
                    core.info(`invalid input json: ${jsonStr}`);
                    const originalMsg =
                      originalError instanceof Error
                        ? originalError.message
                        : String(originalError);
                    const repairMsg =
                      repairError instanceof Error
                        ? repairError.message
                        : String(repairError);
                    throw new Error(
                      `JSON parsing failed. Original: ${originalMsg}. After attempted repair: ${repairMsg}`
                    );
                  }
                }
              }
              const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              const safeOutputsConfig = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
              if (!outputFile) {
                core.info("GITHUB_AW_SAFE_OUTPUTS not set, no output to collect");
                core.setOutput("output", "");
                return;
              }
              if (!fs.existsSync(outputFile)) {
                core.info(`Output file does not exist: ${outputFile}`);
                core.setOutput("output", "");
                return;
              }
              const outputContent = fs.readFileSync(outputFile, "utf8");
              if (outputContent.trim() === "") {
                core.info("Output file is empty");
                core.setOutput("output", "");
                return;
              }
              core.info(`Raw output content length: ${outputContent.length}`);
              // Parse the safe-outputs configuration
              /** @type {any} */
              let expectedOutputTypes = {};
              if (safeOutputsConfig) {
                try {
                  expectedOutputTypes = JSON.parse(safeOutputsConfig);
                  core.info(
                    `Expected output types: ${JSON.stringify(Object.keys(expectedOutputTypes))}`
                  );
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  core.info(`Warning: Could not parse safe-outputs config: ${errorMsg}`);
                }
              }
              // Parse JSONL content
              const lines = outputContent.trim().split("\n");
              const parsedItems = [];
              const errors = [];
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue; // Skip empty lines
                try {
                  /** @type {any} */
                  const item = parseJsonWithRepair(line);
                  // If item is undefined (failed to parse), add error and process next line
                  if (item === undefined) {
                    errors.push(`Line ${i + 1}: Invalid JSON - JSON parsing failed`);
                    continue;
                  }
                  // Validate that the item has a 'type' field
                  if (!item.type) {
                    errors.push(`Line ${i + 1}: Missing required 'type' field`);
                    continue;
                  }
                  // Validate against expected output types
                  const itemType = item.type;
                  if (!expectedOutputTypes[itemType]) {
                    errors.push(
                      `Line ${i + 1}: Unexpected output type '${itemType}'. Expected one of: ${Object.keys(expectedOutputTypes).join(", ")}`
                    );
                    continue;
                  }
                  // Check for too many items of the same type
                  const typeCount = parsedItems.filter(
                    existing => existing.type === itemType
                  ).length;
                  const maxAllowed = getMaxAllowedForType(itemType, expectedOutputTypes);
                  if (typeCount >= maxAllowed) {
                    errors.push(
                      `Line ${i + 1}: Too many items of type '${itemType}'. Maximum allowed: ${maxAllowed}.`
                    );
                    continue;
                  }
                  // Basic validation based on type
                  switch (itemType) {
                    case "create-issue":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-issue-comment":
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: add-issue-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.body = sanitizeContent(item.body);
                      break;
                    case "create-pull-request":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize branch name if present
                      if (item.branch && typeof item.branch === "string") {
                        item.branch = sanitizeContent(item.branch);
                      }
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-issue-label":
                      if (!item.labels || !Array.isArray(item.labels)) {
                        errors.push(
                          `Line ${i + 1}: add-issue-label requires a 'labels' array field`
                        );
                        continue;
                      }
                      if (
                        item.labels.some(
                          /** @param {any} label */ label => typeof label !== "string"
                        )
                      ) {
                        errors.push(
                          `Line ${i + 1}: add-issue-label labels array must contain only strings`
                        );
                        continue;
                      }
                      // Sanitize label strings
                      item.labels = item.labels.map(
                        /** @param {any} label */ label => sanitizeContent(label)
                      );
                      break;
                    case "update-issue":
                      // Check that at least one updateable field is provided
                      const hasValidField =
                        item.status !== undefined ||
                        item.title !== undefined ||
                        item.body !== undefined;
                      if (!hasValidField) {
                        errors.push(
                          `Line ${i + 1}: update-issue requires at least one of: 'status', 'title', or 'body' fields`
                        );
                        continue;
                      }
                      // Validate status if provided
                      if (item.status !== undefined) {
                        if (
                          typeof item.status !== "string" ||
                          (item.status !== "open" && item.status !== "closed")
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'status' must be 'open' or 'closed'`
                          );
                          continue;
                        }
                      }
                      // Validate title if provided
                      if (item.title !== undefined) {
                        if (typeof item.title !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'title' must be a string`
                          );
                          continue;
                        }
                        item.title = sanitizeContent(item.title);
                      }
                      // Validate body if provided
                      if (item.body !== undefined) {
                        if (typeof item.body !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'body' must be a string`
                          );
                          continue;
                        }
                        item.body = sanitizeContent(item.body);
                      }
                      // Validate issue_number if provided (for target "*")
                      if (item.issue_number !== undefined) {
                        if (
                          typeof item.issue_number !== "number" &&
                          typeof item.issue_number !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'issue_number' must be a number or string`
                          );
                          continue;
                        }
                      }
                      break;
                    case "push-to-pr-branch":
                      // Validate message if provided (optional)
                      if (item.message !== undefined) {
                        if (typeof item.message !== "string") {
                          errors.push(
                            `Line ${i + 1}: push-to-pr-branch 'message' must be a string`
                          );
                          continue;
                        }
                        item.message = sanitizeContent(item.message);
                      }
                      // Validate pull_request_number if provided (for target "*")
                      if (item.pull_request_number !== undefined) {
                        if (
                          typeof item.pull_request_number !== "number" &&
                          typeof item.pull_request_number !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: push-to-pr-branch 'pull_request_number' must be a number or string`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-pull-request-review-comment":
                      // Validate required path field
                      if (!item.path || typeof item.path !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'path' string field`
                        );
                        continue;
                      }
                      // Validate required line field
                      if (
                        item.line === undefined ||
                        (typeof item.line !== "number" && typeof item.line !== "string")
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'line' number or string field`
                        );
                        continue;
                      }
                      // Validate line is a positive integer
                      const lineNumber =
                        typeof item.line === "string" ? parseInt(item.line, 10) : item.line;
                      if (
                        isNaN(lineNumber) ||
                        lineNumber <= 0 ||
                        !Number.isInteger(lineNumber)
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment 'line' must be a positive integer`
                        );
                        continue;
                      }
                      // Validate required body field
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize required text content
                      item.body = sanitizeContent(item.body);
                      // Validate optional start_line field
                      if (item.start_line !== undefined) {
                        if (
                          typeof item.start_line !== "number" &&
                          typeof item.start_line !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be a number or string`
                          );
                          continue;
                        }
                        const startLineNumber =
                          typeof item.start_line === "string"
                            ? parseInt(item.start_line, 10)
                            : item.start_line;
                        if (
                          isNaN(startLineNumber) ||
                          startLineNumber <= 0 ||
                          !Number.isInteger(startLineNumber)
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be a positive integer`
                          );
                          continue;
                        }
                        if (startLineNumber > lineNumber) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be less than or equal to 'line'`
                          );
                          continue;
                        }
                      }
                      // Validate optional side field
                      if (item.side !== undefined) {
                        if (
                          typeof item.side !== "string" ||
                          (item.side !== "LEFT" && item.side !== "RIGHT")
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'side' must be 'LEFT' or 'RIGHT'`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-discussion":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      break;
                    case "missing-tool":
                      // Validate required tool field
                      if (!item.tool || typeof item.tool !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'tool' string field`
                        );
                        continue;
                      }
                      // Validate required reason field
                      if (!item.reason || typeof item.reason !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'reason' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.tool = sanitizeContent(item.tool);
                      item.reason = sanitizeContent(item.reason);
                      // Validate optional alternatives field
                      if (item.alternatives !== undefined) {
                        if (typeof item.alternatives !== "string") {
                          errors.push(
                            `Line ${i + 1}: missing-tool 'alternatives' must be a string`
                          );
                          continue;
                        }
                        item.alternatives = sanitizeContent(item.alternatives);
                      }
                      break;
                    case "create-code-scanning-alert":
                      // Validate required fields
                      if (!item.file || typeof item.file !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'file' field (string)`
                        );
                        continue;
                      }
                      if (
                        item.line === undefined ||
                        item.line === null ||
                        (typeof item.line !== "number" && typeof item.line !== "string")
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'line' field (number or string)`
                        );
                        continue;
                      }
                      // Additional validation: line must be parseable as a positive integer
                      const parsedLine = parseInt(item.line, 10);
                      if (isNaN(parsedLine) || parsedLine <= 0) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'line' must be a valid positive integer (got: ${item.line})`
                        );
                        continue;
                      }
                      if (!item.severity || typeof item.severity !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'severity' field (string)`
                        );
                        continue;
                      }
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'message' field (string)`
                        );
                        continue;
                      }
                      // Validate severity level
                      const allowedSeverities = ["error", "warning", "info", "note"];
                      if (!allowedSeverities.includes(item.severity.toLowerCase())) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'severity' must be one of: ${allowedSeverities.join(", ")}`
                        );
                        continue;
                      }
                      // Validate optional column field
                      if (item.column !== undefined) {
                        if (
                          typeof item.column !== "number" &&
                          typeof item.column !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'column' must be a number or string`
                          );
                          continue;
                        }
                        // Additional validation: must be parseable as a positive integer
                        const parsedColumn = parseInt(item.column, 10);
                        if (isNaN(parsedColumn) || parsedColumn <= 0) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'column' must be a valid positive integer (got: ${item.column})`
                          );
                          continue;
                        }
                      }
                      // Validate optional ruleIdSuffix field
                      if (item.ruleIdSuffix !== undefined) {
                        if (typeof item.ruleIdSuffix !== "string") {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must be a string`
                          );
                          continue;
                        }
                        if (!/^[a-zA-Z0-9_-]+$/.test(item.ruleIdSuffix.trim())) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must contain only alphanumeric characters, hyphens, and underscores`
                          );
                          continue;
                        }
                      }
                      // Normalize severity to lowercase and sanitize string fields
                      item.severity = item.severity.toLowerCase();
                      item.file = sanitizeContent(item.file);
                      item.severity = sanitizeContent(item.severity);
                      item.message = sanitizeContent(item.message);
                      if (item.ruleIdSuffix) {
                        item.ruleIdSuffix = sanitizeContent(item.ruleIdSuffix);
                      }
                      break;
                    default:
                      errors.push(`Line ${i + 1}: Unknown output type '${itemType}'`);
                      continue;
                  }
                  core.info(`Line ${i + 1}: Valid ${itemType} item`);
                  parsedItems.push(item);
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  errors.push(`Line ${i + 1}: Invalid JSON - ${errorMsg}`);
                }
              }
              // Report validation results
              if (errors.length > 0) {
                core.warning("Validation errors found:");
                errors.forEach(error => core.warning(`  - ${error}`));
                if (parsedItems.length === 0) {
                  core.setFailed(errors.map(e => `  - ${e}`).join("\n"));
                  return;
                }
                // For now, we'll continue with valid items but log the errors
                // In the future, we might want to fail the workflow for invalid items
              }
              core.info(`Successfully parsed ${parsedItems.length} valid output items`);
              // Set the parsed and validated items as output
              const validatedOutput = {
                items: parsedItems,
                errors: errors,
              };
              // Store validatedOutput JSON in "agent_output.json" file
              const agentOutputFile = "/tmp/agent_output.json";
              const validatedOutputJson = JSON.stringify(validatedOutput);
              try {
                // Ensure the /tmp directory exists
                fs.mkdirSync("/tmp", { recursive: true });
                fs.writeFileSync(agentOutputFile, validatedOutputJson, "utf8");
                core.info(`Stored validated output to: ${agentOutputFile}`);
                // Set the environment variable GITHUB_AW_AGENT_OUTPUT to the file path
                core.exportVariable("GITHUB_AW_AGENT_OUTPUT", agentOutputFile);
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.error(`Failed to write agent output file: ${errorMsg}`);
              }
              core.setOutput("output", JSON.stringify(validatedOutput));
              core.setOutput("raw_output", outputContent);
            }
            // Call the main function
            await main();
      - name: Print sanitized agent output
        run: |
          echo "## Processed Output" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.collect_output.outputs.output }}' >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Upload sanitized agent output
        if: always() && env.GITHUB_AW_AGENT_OUTPUT
        uses: actions/upload-artifact@v4
        with:
          name: agent_output.json
          path: ${{ env.GITHUB_AW_AGENT_OUTPUT }}
          if-no-files-found: warn
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-safe-output-create-pull-request.log
          path: /tmp/test-safe-output-create-pull-request.log
          if-no-files-found: warn
      - name: Generate git patch
        if: always()
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          # Check current git status
          echo "Current git status:"
          git status
          
          # Extract branch name from JSONL output
          BRANCH_NAME=""
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            echo "Checking for branch name in JSONL output..."
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                # Extract branch from create-pull-request line using simple grep and sed
                if echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"create-pull-request"'; then
                  echo "Found create-pull-request line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from create-pull-request: $BRANCH_NAME"
                    break
                  fi
                # Extract branch from push-to-pr-branch line using simple grep and sed
                elif echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"push-to-pr-branch"'; then
                  echo "Found push-to-pr-branch line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from create-pull-request: $BRANCH_NAME"
                    break
                  fi
                fi
              fi
            done < "$GITHUB_AW_SAFE_OUTPUTS"
          fi
          
          # Get the initial commit SHA from the base branch of the pull request
          if [ "$GITHUB_EVENT_NAME" = "pull_request" ] || [ "$GITHUB_EVENT_NAME" = "pull_request_review_comment" ]; then
            INITIAL_SHA="$GITHUB_BASE_REF"
          else
            INITIAL_SHA="$GITHUB_SHA"
          fi
          echo "Base commit SHA: $INITIAL_SHA"
          
          # If we have a branch name, check if that branch exists and get its diff
          if [ -n "$BRANCH_NAME" ]; then
            echo "Looking for branch: $BRANCH_NAME"
            # Check if the branch exists
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
              echo "Branch $BRANCH_NAME exists, generating patch from branch changes"
              # Generate patch from the base to the branch
              git format-patch "$INITIAL_SHA".."$BRANCH_NAME" --stdout > /tmp/aw.patch || echo "Failed to generate patch from branch" > /tmp/aw.patch
              echo "Patch file created from branch: $BRANCH_NAME"
            else
              echo "Branch $BRANCH_NAME does not exist, falling back to current HEAD"
              BRANCH_NAME=""
            fi
          fi
          
          # If no branch or branch doesn't exist, use the existing logic
          if [ -z "$BRANCH_NAME" ]; then
            echo "Using current HEAD for patch generation"
            # Stage any unstaged files
            git add -A || true
            # Check if there are staged files to commit
            if ! git diff --cached --quiet; then
              echo "Staged files found, committing them..."
              git commit -m "[agent] staged files" || true
              echo "Staged files committed"
            else
              echo "No staged files to commit"
            fi
            # Check updated git status
            echo "Updated git status after committing staged files:"
            git status
            # Show compact diff information between initial commit and HEAD (committed changes only)
            echo '## Git diff' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            git diff --name-only "$INITIAL_SHA"..HEAD >> $GITHUB_STEP_SUMMARY || true
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            # Check if there are any committed changes since the initial commit
            if git diff --quiet "$INITIAL_SHA" HEAD; then
              echo "No committed changes detected since initial commit"
              echo "Skipping patch generation - no committed changes to create patch from"
            else
              echo "Committed changes detected, generating patch..."
              # Generate patch from initial commit to HEAD (committed changes only)
              git format-patch "$INITIAL_SHA"..HEAD --stdout > /tmp/aw.patch || echo "Failed to generate patch" > /tmp/aw.patch
              echo "Patch file created at /tmp/aw.patch"
            fi
          fi
          
          # Show patch info if it exists
          if [ -f /tmp/aw.patch ]; then
            ls -la /tmp/aw.patch
            # Show the first 50 lines of the patch for review
            echo '## Git Patch' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```diff' >> $GITHUB_STEP_SUMMARY
            head -500 /tmp/aw.patch >> $GITHUB_STEP_SUMMARY || echo "Could not display patch contents" >> $GITHUB_STEP_SUMMARY
            echo '...' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload git patch
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw.patch
          path: /tmp/aw.patch
          if-no-files-found: ignore

  create_pull_request:
    needs: test-safe-output-create-pull-request
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.create_pull_request.outputs.branch_name }}
      pull_request_number: ${{ steps.create_pull_request.outputs.pull_request_number }}
      pull_request_url: ${{ steps.create_pull_request.outputs.pull_request_url }}
    steps:
      - name: Download patch artifact
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: aw.patch
          path: /tmp/
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Create Pull Request
        id: create_pull_request
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-output-create-pull-request.outputs.output }}
          GITHUB_AW_WORKFLOW_ID: "test-safe-output-create-pull-request"
          GITHUB_AW_BASE_BRANCH: ${{ github.ref_name }}
          GITHUB_AW_PR_TITLE_PREFIX: "[Test] "
          GITHUB_AW_PR_LABELS: "test-safe-output,automation"
          GITHUB_AW_PR_DRAFT: "true"
          GITHUB_AW_PR_IF_NO_CHANGES: "warn"
          GITHUB_AW_SAFE_OUTPUTS_STAGED: "true"
        with:
          script: |
            /** @type {typeof import("fs")} */
            const fs = require("fs");
            /** @type {typeof import("crypto")} */
            const crypto = require("crypto");
            const { execSync } = require("child_process");
            async function main() {
              // Check if we're in staged mode
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              // Environment validation - fail early if required variables are missing
              const workflowId = process.env.GITHUB_AW_WORKFLOW_ID;
              if (!workflowId) {
                throw new Error("GITHUB_AW_WORKFLOW_ID environment variable is required");
              }
              const baseBranch = process.env.GITHUB_AW_BASE_BRANCH;
              if (!baseBranch) {
                throw new Error("GITHUB_AW_BASE_BRANCH environment variable is required");
              }
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
              }
              const ifNoChanges = process.env.GITHUB_AW_PR_IF_NO_CHANGES || "warn";
              // Check if patch file exists and has valid content
              if (!fs.existsSync("/tmp/aw.patch")) {
                const message =
                  "No patch file found - cannot create pull request without changes";
                // If in staged mode, still show preview
                if (isStaged) {
                  let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent +=
                    "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** ⚠️ No patch file found\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  // Write to step summary
                  await core.summary.addRaw(summaryContent).write();
                  core.info(
                    "📝 Pull request creation preview written to step summary (no patch file)"
                  );
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
              // Check for actual error conditions (but allow empty patches as valid noop)
              if (patchContent.includes("Failed to generate patch")) {
                const message =
                  "Patch file contains error message - cannot create pull request without changes";
                // If in staged mode, still show preview
                if (isStaged) {
                  let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent +=
                    "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** ⚠️ Patch file contains error\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  // Write to step summary
                  await core.summary.addRaw(summaryContent).write();
                  core.info(
                    "📝 Pull request creation preview written to step summary (patch error)"
                  );
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              // Empty patch is valid - behavior depends on if-no-changes configuration
              const isEmpty = !patchContent || !patchContent.trim();
              if (isEmpty && !isStaged) {
                const message =
                  "Patch file is empty - no changes to apply (noop operation)";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(
                      "No changes to push - failing as configured by if-no-changes: error"
                    );
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              if (!isEmpty) {
                core.info("Patch content validation passed");
              } else {
                core.info("Patch file is empty - processing noop operation");
              }
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              // Find the create-pull-request item
              const pullRequestItem = validatedOutput.items.find(
                /** @param {any} item */ item => item.type === "create-pull-request"
              );
              if (!pullRequestItem) {
                core.warning("No create-pull-request item found in agent output");
                return;
              }
              core.debug(
                `Found create-pull-request item: title="${pullRequestItem.title}", bodyLength=${pullRequestItem.body.length}`
              );
              // If in staged mode, emit step summary instead of creating PR
              if (isStaged) {
                let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                summaryContent +=
                  "The following pull request would be created if staged mode was disabled:\n\n";
                summaryContent += `**Title:** ${pullRequestItem.title || "No title provided"}\n\n`;
                summaryContent += `**Branch:** ${pullRequestItem.branch || "auto-generated"}\n\n`;
                summaryContent += `**Base:** ${baseBranch}\n\n`;
                if (pullRequestItem.body) {
                  summaryContent += `**Body:**\n${pullRequestItem.body}\n\n`;
                }
                if (fs.existsSync("/tmp/aw.patch")) {
                  const patchStats = fs.readFileSync("/tmp/aw.patch", "utf8");
                  if (patchStats.trim()) {
                    summaryContent += `**Changes:** Patch file exists with ${patchStats.split("\n").length} lines\n\n`;
                    summaryContent += `<details><summary>Show patch preview</summary>\n\n\`\`\`diff\n${patchStats.slice(0, 2000)}${patchStats.length > 2000 ? "\n... (truncated)" : ""}\n\`\`\`\n\n</details>\n\n`;
                  } else {
                    summaryContent += `**Changes:** No changes (empty patch)\n\n`;
                  }
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Pull request creation preview written to step summary");
                return;
              }
              // Extract title, body, and branch from the JSON item
              let title = pullRequestItem.title.trim();
              let bodyLines = pullRequestItem.body.split("\n");
              let branchName = pullRequestItem.branch
                ? pullRequestItem.branch.trim()
                : null;
              // If no title was found, use a default
              if (!title) {
                title = "Agent Output";
              }
              // Apply title prefix if provided via environment variable
              const titlePrefix = process.env.GITHUB_AW_PR_TITLE_PREFIX;
              if (titlePrefix && !title.startsWith(titlePrefix)) {
                title = titlePrefix + title;
              }
              // Add AI disclaimer with run id, run htmlurl
              const runId = context.runId;
              const runUrl = context.payload.repository
                ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                : `https://github.com/actions/runs/${runId}`;
              bodyLines.push(
                ``,
                ``,
                `> Generated by Agentic Workflow [Run](${runUrl})`,
                ""
              );
              // Prepare the body content
              const body = bodyLines.join("\n").trim();
              // Parse labels from environment variable (comma-separated string)
              const labelsEnv = process.env.GITHUB_AW_PR_LABELS;
              const labels = labelsEnv
                ? labelsEnv
                    .split(",")
                    .map(/** @param {string} label */ label => label.trim())
                    .filter(/** @param {string} label */ label => label)
                : [];
              // Parse draft setting from environment variable (defaults to true)
              const draftEnv = process.env.GITHUB_AW_PR_DRAFT;
              const draft = draftEnv ? draftEnv.toLowerCase() === "true" : true;
              core.info(`Creating pull request with title: ${title}`);
              core.debug(`Labels: ${JSON.stringify(labels)}`);
              core.debug(`Draft: ${draft}`);
              core.debug(`Body length: ${body.length}`);
              const randomHex = crypto.randomBytes(8).toString("hex");
              // Use branch name from JSONL if provided, otherwise generate unique branch name
              if (!branchName) {
                core.debug(
                  "No branch name provided in JSONL, generating unique branch name"
                );
                // Generate unique branch name using cryptographic random hex
                branchName = `${workflowId}-${randomHex}`;
              } else {
                branchName = `${branchName}-${randomHex}`;
                core.debug(`Using branch name from JSONL with added salt: ${branchName}`);
              }
              core.info(`Generated branch name: ${branchName}`);
              core.debug(`Base branch: ${baseBranch}`);
              // Create a new branch using git CLI, ensuring it's based on the correct base branch
              // First, fetch latest changes and checkout the base branch
              core.debug(
                `Fetching latest changes and checking out base branch: ${baseBranch}`
              );
              execSync("git fetch origin", { stdio: "inherit" });
              execSync(`git checkout ${baseBranch}`, { stdio: "inherit" });
              // Handle branch creation/checkout
              core.debug(
                `Branch should not exist locally, creating new branch from base: ${branchName}`
              );
              execSync(`git checkout -b ${branchName}`, { stdio: "inherit" });
              core.info(`Created new branch from base: ${branchName}`);
              // Apply the patch using git CLI (skip if empty)
              if (!isEmpty) {
                core.info("Applying patch...");
                // Patches are created with git format-patch, so use git am to apply them
                execSync("git am /tmp/aw.patch", { stdio: "inherit" });
                core.info("Patch applied successfully");
                // Push the applied commits to the branch
                execSync(`git push origin ${branchName}`, { stdio: "inherit" });
                core.info("Changes pushed to branch");
              } else {
                core.info("Skipping patch application (empty patch)");
                // For empty patches, handle if-no-changes configuration
                const message =
                  "No changes to apply - noop operation completed successfully";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(
                      "No changes to apply - failing as configured by if-no-changes: error"
                    );
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              // Create the pull request
              const { data: pullRequest } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                head: branchName,
                base: baseBranch,
                draft: draft,
              });
              core.info(
                `Created pull request #${pullRequest.number}: ${pullRequest.html_url}`
              );
              // Add labels if specified
              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pullRequest.number,
                  labels: labels,
                });
                core.info(`Added labels to pull request: ${JSON.stringify(labels)}`);
              }
              // Set output for other jobs to use
              core.setOutput("pull_request_number", pullRequest.number);
              core.setOutput("pull_request_url", pullRequest.html_url);
              core.setOutput("branch_name", branchName);
              // Write summary to GitHub Actions summary
              await core.summary
                .addRaw(
                  `
            ## Pull Request
            - **Pull Request**: [#${pullRequest.number}](${pullRequest.html_url})
            - **Branch**: \`${branchName}\`
            - **Base Branch**: \`${baseBranch}\`
            `
                )
                .write();
            }
            await main();

