name: Agentics Maintenance

on:
  schedule:
    - cron: "0 0 * * *"  # Daily at midnight UTC
  workflow_dispatch:

permissions:
  contents: read
  discussions: write

jobs:
  close-expired-discussions:
    runs-on: ubuntu-latest
    steps:
      - name: Close expired discussions
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const MAX_UPDATES_PER_RUN = 100;
            const GRAPHQL_DELAY_MS = 500;
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }
            async function searchDiscussionsWithExpiration(github, owner, repo) {
              const discussions = [];
              let hasNextPage = true;
              let cursor = null;
              while (hasNextPage) {
                const query = `
                  query($owner: String!, $repo: String!, $cursor: String) {
                    repository(owner: $owner, name: $repo) {
                      discussions(first: 100, after: $cursor, states: [OPEN]) {
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                        nodes {
                          id
                          number
                          title
                          url
                          body
                          createdAt
                        }
                      }
                    }
                  }
                `;
                const result = await github.graphql(query, {
                  owner: owner,
                  repo: repo,
                  cursor: cursor,
                });
                if (!result || !result.repository || !result.repository.discussions) {
                  break;
                }
                const nodes = result.repository.discussions.nodes || [];
                for (const discussion of nodes) {
                  const agenticPattern = /^> AI generated by/m;
                  const isAgenticWorkflow = discussion.body && agenticPattern.test(discussion.body);
                  if (!isAgenticWorkflow) {
                    continue;
                  }
                  const expirationPattern = /<!-- gh-aw-expires: ([^>]+) -->/;
                  const match = discussion.body ? discussion.body.match(expirationPattern) : null;
                  if (match) {
                    discussions.push(discussion);
                  }
                }
                hasNextPage = result.repository.discussions.pageInfo.hasNextPage;
                cursor = result.repository.discussions.pageInfo.endCursor;
              }
              return discussions;
            }
            function extractExpirationDate(body) {
              const expirationPattern = /<!-- gh-aw-expires: ([^>]+) -->/;
              const match = body.match(expirationPattern);
              if (!match) {
                return null;
              }
              const expirationISO = match[1].trim();
              const expirationDate = new Date(expirationISO);
              if (isNaN(expirationDate.getTime())) {
                return null;
              }
              return expirationDate;
            }
            function validateCreationDate(createdAt) {
              const creationDate = new Date(createdAt);
              return !isNaN(creationDate.getTime());
            }
            async function addDiscussionComment(github, discussionId, message) {
              const result = await github.graphql(
                `
                mutation($dId: ID!, $body: String!) {
                  addDiscussionComment(input: { discussionId: $dId, body: $body }) {
                    comment { 
                      id 
                      url
                    }
                  }
                }`,
                { dId: discussionId, body: message }
              );
              return result.addDiscussionComment.comment;
            }
            async function closeDiscussionAsOutdated(github, discussionId) {
              const result = await github.graphql(
                `
                mutation($dId: ID!) {
                  closeDiscussion(input: { discussionId: $dId, reason: OUTDATED }) {
                    discussion { 
                      id
                      url
                    }
                  }
                }`,
                { dId: discussionId }
              );
              return result.closeDiscussion.discussion;
            }
            async function main() {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              core.info(`Searching for expired discussions in ${owner}/${repo}`);
              const discussionsWithExpiration = await searchDiscussionsWithExpiration(github, owner, repo);
              if (discussionsWithExpiration.length === 0) {
                core.info("No discussions with expiration markers found");
                return;
              }
              core.info(`Found ${discussionsWithExpiration.length} discussion(s) with expiration markers`);
              const now = new Date();
              const expiredDiscussions = [];
              for (const discussion of discussionsWithExpiration) {
                if (!validateCreationDate(discussion.createdAt)) {
                  core.warning(`Discussion #${discussion.number} has invalid creation date, skipping`);
                  continue;
                }
                const expirationDate = extractExpirationDate(discussion.body);
                if (!expirationDate) {
                  core.warning(`Discussion #${discussion.number} has invalid expiration date, skipping`);
                  continue;
                }
                if (now >= expirationDate) {
                  expiredDiscussions.push({
                    ...discussion,
                    expirationDate: expirationDate,
                  });
                }
              }
              if (expiredDiscussions.length === 0) {
                core.info("No expired discussions found");
                return;
              }
              core.info(`Found ${expiredDiscussions.length} expired discussion(s)`);
              const discussionsToClose = expiredDiscussions.slice(0, MAX_UPDATES_PER_RUN);
              if (expiredDiscussions.length > MAX_UPDATES_PER_RUN) {
                core.warning(`Found ${expiredDiscussions.length} expired discussions, but only closing the first ${MAX_UPDATES_PER_RUN}`);
              }
              let closedCount = 0;
              const closedDiscussions = [];
              for (let i = 0; i < discussionsToClose.length; i++) {
                const discussion = discussionsToClose[i];
                try {
                  const closingMessage = `This discussion was automatically closed because it expired on ${discussion.expirationDate.toISOString()}.`;
                  core.info(`Adding closing comment to discussion #${discussion.number}`);
                  await addDiscussionComment(github, discussion.id, closingMessage);
                  core.info(`Closing discussion #${discussion.number} as outdated`);
                  await closeDiscussionAsOutdated(github, discussion.id);
                  closedDiscussions.push({
                    number: discussion.number,
                    url: discussion.url,
                    title: discussion.title,
                  });
                  closedCount++;
                  core.info(`✓ Closed discussion #${discussion.number}: ${discussion.url}`);
                } catch (error) {
                  core.error(`✗ Failed to close discussion #${discussion.number}: ${error instanceof Error ? error.message : String(error)}`);
                }
                if (i < discussionsToClose.length - 1) {
                  await delay(GRAPHQL_DELAY_MS);
                }
              }
              if (closedCount > 0) {
                let summaryContent = `## Closed Expired Discussions\n\n`;
                summaryContent += `Closed **${closedCount}** expired discussion(s):\n\n`;
                for (const closed of closedDiscussions) {
                  summaryContent += `- Discussion #${closed.number}: [${closed.title}](${closed.url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully closed ${closedCount} expired discussion(s)`);
            }
            (async () => {
              await main();
            })();
