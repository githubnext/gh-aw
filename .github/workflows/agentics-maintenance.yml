#
#    ___                   _   _      
#   / _ \                 | | (_)     
#  | |_| | __ _  ___ _ __ | |_ _  ___ 
#  |  _  |/ _` |/ _ \ '_ \| __| |/ __|
#  | | | | (_| |  __/ | | | |_| | (__ 
#  \_| |_/\__, |\___|_| |_|\__|_|\___|
#          __/ |
#  _    _ |___/ 
# | |  | |                / _| |
# | |  | | ___ _ __ _  __| |_| | _____      ____
# | |/\| |/ _ \ '__| |/ /|  _| |/ _ \ \ /\ / / ___|
# \  /\  / (_) | | | | ( | | | | (_) \ V  V /\__ \
#  \/  \/ \___/|_| |_|\_\|_| |_|\___/ \_/\_/ |___/
#
# This file was automatically generated by pkg/workflow/maintenance_workflow.go. DO NOT EDIT.
#
# To regenerate this workflow, run:
#   gh aw compile
# For more information: https://github.com/githubnext/gh-aw/blob/main/.github/aw/github-agentic-workflows.md
#
# Alternative regeneration methods:
# make recompile
# 
# Or use the gh-aw CLI directly:
# ./gh-aw compile --validate --verbose
# 
# The workflow is generated when any workflow uses the 'expires' field
# in create-discussions or create-issues safe-outputs configuration.
#
name: Agentics Maintenance

on:
  schedule:
    - cron: "0 0 * * *"  # Daily at midnight UTC
  workflow_dispatch:

permissions: {}

jobs:
  close-expired-discussions:
    runs-on: ubuntu-latest
    permissions:
      discussions: write
    steps:
      - name: Close expired discussions
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const MAX_UPDATES_PER_RUN = 100;
            const GRAPHQL_DELAY_MS = 500;
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }
            async function searchDiscussionsWithExpiration(github, owner, repo) {
              const discussions = [];
              let hasNextPage = true;
              let cursor = null;
              while (hasNextPage) {
                const query = `
                  query($owner: String!, $repo: String!, $cursor: String) {
                    repository(owner: $owner, name: $repo) {
                      discussions(first: 100, after: $cursor, states: [OPEN]) {
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                        nodes {
                          id
                          number
                          title
                          url
                          body
                          createdAt
                        }
                      }
                    }
                  }
                `;
                const result = await github.graphql(query, {
                  owner: owner,
                  repo: repo,
                  cursor: cursor,
                });
                if (!result || !result.repository || !result.repository.discussions) {
                  break;
                }
                const nodes = result.repository.discussions.nodes || [];
                for (const discussion of nodes) {
                  const agenticPattern = /^> AI generated by/m;
                  const isAgenticWorkflow = discussion.body && agenticPattern.test(discussion.body);
                  if (!isAgenticWorkflow) {
                    continue;
                  }
                  const expirationPattern = /<!-- gh-aw-expires: ([^>]+) -->/;
                  const match = discussion.body ? discussion.body.match(expirationPattern) : null;
                  if (match) {
                    discussions.push(discussion);
                  }
                }
                hasNextPage = result.repository.discussions.pageInfo.hasNextPage;
                cursor = result.repository.discussions.pageInfo.endCursor;
              }
              return discussions;
            }
            function extractExpirationDate(body) {
              const expirationPattern = /<!-- gh-aw-expires: ([^>]+) -->/;
              const match = body.match(expirationPattern);
              if (!match) {
                return null;
              }
              const expirationISO = match[1].trim();
              const expirationDate = new Date(expirationISO);
              if (isNaN(expirationDate.getTime())) {
                return null;
              }
              return expirationDate;
            }
            function validateCreationDate(createdAt) {
              const creationDate = new Date(createdAt);
              return !isNaN(creationDate.getTime());
            }
            async function addDiscussionComment(github, discussionId, message) {
              const result = await github.graphql(
                `
                mutation($dId: ID!, $body: String!) {
                  addDiscussionComment(input: { discussionId: $dId, body: $body }) {
                    comment { 
                      id 
                      url
                    }
                  }
                }`,
                { dId: discussionId, body: message }
              );
              return result.addDiscussionComment.comment;
            }
            async function closeDiscussionAsOutdated(github, discussionId) {
              const result = await github.graphql(
                `
                mutation($dId: ID!) {
                  closeDiscussion(input: { discussionId: $dId, reason: OUTDATED }) {
                    discussion { 
                      id
                      url
                    }
                  }
                }`,
                { dId: discussionId }
              );
              return result.closeDiscussion.discussion;
            }
            async function main() {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              core.info(`Searching for expired discussions in ${owner}/${repo}`);
              const discussionsWithExpiration = await searchDiscussionsWithExpiration(github, owner, repo);
              if (discussionsWithExpiration.length === 0) {
                core.info("No discussions with expiration markers found");
                return;
              }
              core.info(`Found ${discussionsWithExpiration.length} discussion(s) with expiration markers`);
              const now = new Date();
              const expiredDiscussions = [];
              for (const discussion of discussionsWithExpiration) {
                if (!validateCreationDate(discussion.createdAt)) {
                  core.warning(`Discussion #${discussion.number} has invalid creation date, skipping`);
                  continue;
                }
                const expirationDate = extractExpirationDate(discussion.body);
                if (!expirationDate) {
                  core.warning(`Discussion #${discussion.number} has invalid expiration date, skipping`);
                  continue;
                }
                if (now >= expirationDate) {
                  expiredDiscussions.push({
                    ...discussion,
                    expirationDate: expirationDate,
                  });
                }
              }
              if (expiredDiscussions.length === 0) {
                core.info("No expired discussions found");
                return;
              }
              core.info(`Found ${expiredDiscussions.length} expired discussion(s)`);
              const discussionsToClose = expiredDiscussions.slice(0, MAX_UPDATES_PER_RUN);
              if (expiredDiscussions.length > MAX_UPDATES_PER_RUN) {
                core.warning(`Found ${expiredDiscussions.length} expired discussions, but only closing the first ${MAX_UPDATES_PER_RUN}`);
              }
              let closedCount = 0;
              const closedDiscussions = [];
              for (let i = 0; i < discussionsToClose.length; i++) {
                const discussion = discussionsToClose[i];
                try {
                  const closingMessage = `This discussion was automatically closed because it expired on ${discussion.expirationDate.toISOString()}.`;
                  core.info(`Adding closing comment to discussion #${discussion.number}`);
                  await addDiscussionComment(github, discussion.id, closingMessage);
                  core.info(`Closing discussion #${discussion.number} as outdated`);
                  await closeDiscussionAsOutdated(github, discussion.id);
                  closedDiscussions.push({
                    number: discussion.number,
                    url: discussion.url,
                    title: discussion.title,
                  });
                  closedCount++;
                  core.info(`✓ Closed discussion #${discussion.number}: ${discussion.url}`);
                } catch (error) {
                  core.error(`✗ Failed to close discussion #${discussion.number}: ${error instanceof Error ? error.message : String(error)}`);
                }
                if (i < discussionsToClose.length - 1) {
                  await delay(GRAPHQL_DELAY_MS);
                }
              }
              if (closedCount > 0) {
                let summaryContent = `## Closed Expired Discussions\n\n`;
                summaryContent += `Closed **${closedCount}** expired discussion(s):\n\n`;
                for (const closed of closedDiscussions) {
                  summaryContent += `- Discussion #${closed.number}: [${closed.title}](${closed.url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully closed ${closedCount} expired discussion(s)`);
            }
            await main();

  close-expired-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Close expired issues
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const MAX_UPDATES_PER_RUN = 100;
            const GRAPHQL_DELAY_MS = 500;
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }
            async function searchIssuesWithExpiration(github, owner, repo) {
              const issues = [];
              let hasNextPage = true;
              let cursor = null;
              while (hasNextPage) {
                const query = `
                  query($owner: String!, $repo: String!, $cursor: String) {
                    repository(owner: $owner, name: $repo) {
                      issues(first: 100, after: $cursor, states: [OPEN]) {
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                        nodes {
                          id
                          number
                          title
                          url
                          body
                          createdAt
                        }
                      }
                    }
                  }
                `;
                const result = await github.graphql(query, {
                  owner: owner,
                  repo: repo,
                  cursor: cursor,
                });
                if (!result || !result.repository || !result.repository.issues) {
                  break;
                }
                const nodes = result.repository.issues.nodes || [];
                for (const issue of nodes) {
                  const agenticPattern = /^> AI generated by/m;
                  const isAgenticWorkflow = issue.body && agenticPattern.test(issue.body);
                  if (!isAgenticWorkflow) {
                    continue;
                  }
                  const expirationPattern = /<!-- gh-aw-expires: ([^>]+) -->/;
                  const match = issue.body ? issue.body.match(expirationPattern) : null;
                  if (match) {
                    issues.push(issue);
                  }
                }
                hasNextPage = result.repository.issues.pageInfo.hasNextPage;
                cursor = result.repository.issues.pageInfo.endCursor;
              }
              return issues;
            }
            function extractExpirationDate(body) {
              const expirationPattern = /<!-- gh-aw-expires: ([^>]+) -->/;
              const match = body.match(expirationPattern);
              if (!match) {
                return null;
              }
              const expirationISO = match[1].trim();
              const expirationDate = new Date(expirationISO);
              if (isNaN(expirationDate.getTime())) {
                return null;
              }
              return expirationDate;
            }
            function validateCreationDate(createdAt) {
              const creationDate = new Date(createdAt);
              return !isNaN(creationDate.getTime());
            }
            async function addIssueComment(github, owner, repo, issueNumber, message) {
              const result = await github.rest.issues.createComment({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                body: message,
              });
              return result.data;
            }
            async function closeIssue(github, owner, repo, issueNumber) {
              const result = await github.rest.issues.update({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                state: "closed",
                state_reason: "not_planned",
              });
              return result.data;
            }
            async function main() {
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              core.info(`Searching for expired issues in ${owner}/${repo}`);
              const issuesWithExpiration = await searchIssuesWithExpiration(github, owner, repo);
              if (issuesWithExpiration.length === 0) {
                core.info("No issues with expiration markers found");
                return;
              }
              core.info(`Found ${issuesWithExpiration.length} issue(s) with expiration markers`);
              const now = new Date();
              const expiredIssues = [];
              for (const issue of issuesWithExpiration) {
                if (!validateCreationDate(issue.createdAt)) {
                  core.warning(`Issue #${issue.number} has invalid creation date, skipping`);
                  continue;
                }
                const expirationDate = extractExpirationDate(issue.body);
                if (!expirationDate) {
                  core.warning(`Issue #${issue.number} has invalid expiration date, skipping`);
                  continue;
                }
                if (now >= expirationDate) {
                  expiredIssues.push({
                    ...issue,
                    expirationDate: expirationDate,
                  });
                }
              }
              if (expiredIssues.length === 0) {
                core.info("No expired issues found");
                return;
              }
              core.info(`Found ${expiredIssues.length} expired issue(s)`);
              const issuesToClose = expiredIssues.slice(0, MAX_UPDATES_PER_RUN);
              if (expiredIssues.length > MAX_UPDATES_PER_RUN) {
                core.warning(`Found ${expiredIssues.length} expired issues, but only closing the first ${MAX_UPDATES_PER_RUN}`);
              }
              let closedCount = 0;
              const closedIssues = [];
              for (let i = 0; i < issuesToClose.length; i++) {
                const issue = issuesToClose[i];
                try {
                  const closingMessage = `This issue was automatically closed because it expired on ${issue.expirationDate.toISOString()}.`;
                  core.info(`Adding closing comment to issue #${issue.number}`);
                  await addIssueComment(github, owner, repo, issue.number, closingMessage);
                  core.info(`Closing issue #${issue.number} as not planned`);
                  await closeIssue(github, owner, repo, issue.number);
                  closedIssues.push({
                    number: issue.number,
                    url: issue.url,
                    title: issue.title,
                  });
                  closedCount++;
                  core.info(`✓ Closed issue #${issue.number}: ${issue.url}`);
                } catch (error) {
                  core.error(`✗ Failed to close issue #${issue.number}: ${error instanceof Error ? error.message : String(error)}`);
                }
                if (i < issuesToClose.length - 1) {
                  await delay(GRAPHQL_DELAY_MS);
                }
              }
              if (closedCount > 0) {
                let summaryContent = `## Closed Expired Issues\n\n`;
                summaryContent += `Closed **${closedCount}** expired issue(s):\n\n`;
                for (const closed of closedIssues) {
                  summaryContent += `- Issue #${closed.number}: [${closed.title}](${closed.url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully closed ${closedCount} expired issue(s)`);
            }
            await main();

  compile-workflows:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup Go
        uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
        with:
          go-version-file: go.mod
          cache: true

      - name: Build gh-aw
        run: make build

      - name: Compile workflows
        run: |
          ./gh-aw compile --validate --verbose
          echo "✓ All workflows compiled successfully"

      - name: Check for out-of-sync workflows
        run: |
          if git diff --exit-code .github/workflows/*.lock.yml; then
            echo "✓ All workflow lock files are up to date"
          else
            echo "::error::Some workflow lock files are out of sync. Run 'make recompile' locally."
            echo "::group::Diff of out-of-sync files"
            git diff .github/workflows/*.lock.yml
            echo "::endgroup::"
            exit 1
          fi

  zizmor-scan:
    runs-on: ubuntu-latest
    needs: compile-workflows
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup Go
        uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
        with:
          go-version-file: go.mod
          cache: true

      - name: Build gh-aw
        run: make build

      - name: Run zizmor security scanner
        run: |
          ./gh-aw compile --zizmor --verbose
          echo "✓ Zizmor security scan completed"
