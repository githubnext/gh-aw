# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Tech Debt Collector"
on:
    schedule:
        - cron: 0 10 * * *
    workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}"

run-name: "Tech Debt Collector"

# Cache configuration from frontmatter was processed and added to the main job steps

jobs:
  task:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: .github
          fetch-depth: 1

  tech-debt-collector:
    needs: task
    runs-on: ubuntu-latest
    permissions:
        actions: read
        checks: read
        contents: write
        issues: read
        models: read
        pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Cache configuration from frontmatter processed below
      - name: Cache (tech-debt-memory-${{ github.repository_owner }}-${{ github.event.repository.name }})
        uses: actions/cache@v3
        with:
          key: tech-debt-memory-${{ github.repository_owner }}-${{ github.event.repository.name }}
          path: |
            .tech-debt-memory/
            .tech-debt-progress/
          restore-keys: |
            tech-debt-memory-${{ github.repository_owner }}-
            tech-debt-memory-
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-45e90ae"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              }
            }
          }
          EOF
      - name: Create prompt
        run: |
          mkdir -p /tmp/aw-prompts
          cat > /tmp/aw-prompts/prompt.txt << 'EOF'
          # Tech Debt Collector
          
          You are the **Tech Debt Collector**, an autonomous code quality improvement agent for the `${{ github.repository }}` repository. Your mission is to systematically identify and address technical debt through small, incremental improvements while maintaining code stability and test coverage.
          
          ## Your Mission
          
          Collect technical debt and increase code quality over time by making small, focused improvements to the codebase. You run daily to allow human reviewers time to evaluate and integrate your proposed changes.
          
          ## Memory and Progress Tracking
          
          Use the cached directories to maintain state:
          - `.tech-debt-memory/`: Store analysis results, patterns found, and lessons learned
          - `.tech-debt-progress/`: Track which files/areas have been worked on recently
          
          Create these directories if they don't exist and maintain files like:
          - `recent-analysis.json`: Record of recent tech debt analysis
          - `processed-files.log`: Files that have been recently improved
          - `open-prs.log`: Track your active tech debt PRs
          - `patterns.md`: Document common tech debt patterns found
          
          ## Step-by-Step Process
          
          ### 1. Initialize Memory System
          - Create/read memory directories
          - Load previous analysis and progress data
          - Check for any open tech debt PRs you've created previously
          
          ### 2. Identify Tech Debt Candidates
          Focus on recently changed code as it's most likely to benefit from improvements:
          
          - Use `git log` and GitHub API to find files modified in the last 1-2 weeks
          - Prioritize Go files (`.go`) in the main codebase (`pkg/`, `cmd/`)
          - Look for files with complexity indicators:
            - Large functions (>50 lines)
            - High cyclomatic complexity
            - Repeated code patterns
            - Poor variable naming
            - Lack of comments in complex logic
            - Missing error handling
            - Inefficient loops or algorithms
          
          ### 3. Check for Existing Work
          Before proceeding with any file:
          - Search for open pull requests that might be working on the same files
          - Check your memory logs to avoid recently processed files
          - Look for existing tech debt issues or PRs targeting the same code
          
          ### 4. Validate Test Coverage
          For any candidate file:
          - Verify corresponding test files exist (`*_test.go`)
          - Check if tests are comprehensive for the functions you plan to modify
          - If no tests exist, prioritize adding tests as the improvement
          
          ### 5. Generate Small Improvements
          Select ONE focused improvement per run. Examples:
          - **Clarity**: Rename variables to be more descriptive
          - **Complexity**: Break down large functions into smaller, focused ones
          - **Performance**: Replace inefficient loops or algorithms
          - **Maintainability**: Add clear comments explaining complex logic
          - **Robustness**: Add missing error handling
          - **Testing**: Add test cases for edge cases or uncovered code paths
          
          ### 6. Validate Changes
          Before creating a PR:
          - Run `make fmt` to ensure proper formatting
          - Run `make lint` to check for style issues
          - Run `make test` to ensure all tests pass
          - Manually review the diff to ensure changes are minimal and focused
          
          ### 7. Create Pull Request
          - Create a descriptive branch name like `tech-debt/improve-{area}-{date}`
          - Write a clear PR title: "Tech Debt: [Brief description of improvement]"
          - Include in PR description:
            - What specific tech debt was addressed
            - Why this improvement matters
            - How the change improves code quality
            - Confirmation that tests pass
          
          ### 8. Update Memory
          Record your work:
          - Add processed files to memory logs
          - Update analysis results
          - Note patterns discovered
          - Save PR information for tracking
          
          ## Quality Guidelines
          
          ### Code Changes Must Be:
          - **Small**: Single focused improvement per PR
          - **Safe**: No functional changes, only quality improvements
          - **Tested**: All existing tests must continue to pass
          - **Documented**: Changes should improve code clarity
          - **Reversible**: Changes should be easy to understand and revert if needed
          
          ### Prioritization Rules:
          1. Recently changed files (last 1-2 weeks)
          2. Core business logic in `pkg/` directories
          3. Files without recent tech debt improvements
          4. Code with clear, measurable improvements available
          5. Files with good test coverage
          
          ## Important Constraints
          
          - **One improvement per day**: Focus on quality over quantity
          - **No breaking changes**: Only improve code quality, never change functionality
          - **Test requirements**: All tests must pass before and after changes
          - **Human review required**: Create PRs for human review, don't merge automatically
          - **Memory persistence**: Always update progress tracking to avoid duplicate work
          - **Scope limitation**: Avoid files currently being worked on by other PRs
          
          ## Error Handling
          
          If you encounter issues:
          - Document the problem in memory files
          - Skip problematic files and try alternatives
          - If no suitable candidates are found, document why and suggest manual review areas
          - Always explain your reasoning and next steps
          
          ## Output Format
          
          Provide a clear summary at the end including:
          - Files analyzed and selection criteria used
          - Specific improvement made (if any)
          - Test results and validation steps
          - PR created (with link if successful)
          - Updated memory/progress information
          - Recommendations for next run
          
          Remember: Your goal is consistent, incremental improvement over time, not dramatic changes. Quality and safety are more important than quantity of changes.
          
          > NOTE: If you are refused permission to run an MCP tool or particular 'bash' commands, or need to request access to other tools or resources, then please include a request for access in the output, explaining the exact name of the tool and/or the exact prefix of bash commands needed, or other resources you need access to.
          
          > NOTE: Include a footer link like this at the end of each new issue, issue comment or pull request you create. Do this in addition to any other footers you are instructed to include.
          
          ```markdown
          > AI-generated content by [${{ github.workflow }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) may contain mistakes.
          ```
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat /tmp/aw-prompts/prompt.txt >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "claude",
              engine_name: "Claude Code",
              model: "",
              version: "",
              workflow_name: "Tech Debt Collector",
              experimental: false,
              supports_tools_whitelist: true,
              supports_http_transport: true,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Execute Claude Code Action
        id: agentic_execution
        uses: anthropics/claude-code-base-action@v0.0.56
        with:
          # Allowed tools (sorted):
          # - Bash(find . -name '*.go' -type f)
          # - Bash(find . -name '*_test.go' -type f)
          # - Bash(git diff --name-only HEAD~7..HEAD)
          # - Bash(git log --oneline -n 20)
          # - Bash(git status)
          # - Bash(go test ./...)
          # - Bash(make build)
          # - Bash(make deps)
          # - Bash(make fmt)
          # - Bash(make lint)
          # - Bash(make recompile)
          # - Bash(make test)
          # - Edit
          # - Glob
          # - Grep
          # - LS
          # - MultiEdit
          # - NotebookRead
          # - Read
          # - Task
          # - Write
          # - mcp__github__download_workflow_run_artifact
          # - mcp__github__get_code_scanning_alert
          # - mcp__github__get_commit
          # - mcp__github__get_dependabot_alert
          # - mcp__github__get_discussion
          # - mcp__github__get_discussion_comments
          # - mcp__github__get_file_contents
          # - mcp__github__get_issue
          # - mcp__github__get_issue_comments
          # - mcp__github__get_job_logs
          # - mcp__github__get_me
          # - mcp__github__get_notification_details
          # - mcp__github__get_pull_request
          # - mcp__github__get_pull_request_comments
          # - mcp__github__get_pull_request_diff
          # - mcp__github__get_pull_request_files
          # - mcp__github__get_pull_request_reviews
          # - mcp__github__get_pull_request_status
          # - mcp__github__get_repository
          # - mcp__github__get_secret_scanning_alert
          # - mcp__github__get_tag
          # - mcp__github__get_workflow_run
          # - mcp__github__get_workflow_run_logs
          # - mcp__github__get_workflow_run_usage
          # - mcp__github__list_branches
          # - mcp__github__list_code_scanning_alerts
          # - mcp__github__list_commits
          # - mcp__github__list_dependabot_alerts
          # - mcp__github__list_discussion_categories
          # - mcp__github__list_discussions
          # - mcp__github__list_issues
          # - mcp__github__list_notifications
          # - mcp__github__list_pull_requests
          # - mcp__github__list_secret_scanning_alerts
          # - mcp__github__list_tags
          # - mcp__github__list_workflow_jobs
          # - mcp__github__list_workflow_run_artifacts
          # - mcp__github__list_workflow_runs
          # - mcp__github__list_workflows
          # - mcp__github__search_code
          # - mcp__github__search_issues
          # - mcp__github__search_orgs
          # - mcp__github__search_pull_requests
          # - mcp__github__search_repositories
          # - mcp__github__search_users
          allowed_tools: "Bash(find . -name '*.go' -type f),Bash(find . -name '*_test.go' -type f),Bash(git diff --name-only HEAD~7..HEAD),Bash(git log --oneline -n 20),Bash(git status),Bash(go test ./...),Bash(make build),Bash(make deps),Bash(make fmt),Bash(make lint),Bash(make recompile),Bash(make test),Edit,Glob,Grep,LS,MultiEdit,NotebookRead,Read,Task,Write,mcp__github__download_workflow_run_artifact,mcp__github__get_code_scanning_alert,mcp__github__get_commit,mcp__github__get_dependabot_alert,mcp__github__get_discussion,mcp__github__get_discussion_comments,mcp__github__get_file_contents,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__get_job_logs,mcp__github__get_me,mcp__github__get_notification_details,mcp__github__get_pull_request,mcp__github__get_pull_request_comments,mcp__github__get_pull_request_diff,mcp__github__get_pull_request_files,mcp__github__get_pull_request_reviews,mcp__github__get_pull_request_status,mcp__github__get_repository,mcp__github__get_secret_scanning_alert,mcp__github__get_tag,mcp__github__get_workflow_run,mcp__github__get_workflow_run_logs,mcp__github__get_workflow_run_usage,mcp__github__list_branches,mcp__github__list_code_scanning_alerts,mcp__github__list_commits,mcp__github__list_dependabot_alerts,mcp__github__list_discussion_categories,mcp__github__list_discussions,mcp__github__list_issues,mcp__github__list_notifications,mcp__github__list_pull_requests,mcp__github__list_secret_scanning_alerts,mcp__github__list_tags,mcp__github__list_workflow_jobs,mcp__github__list_workflow_run_artifacts,mcp__github__list_workflow_runs,mcp__github__list_workflows,mcp__github__search_code,mcp__github__search_issues,mcp__github__search_orgs,mcp__github__search_pull_requests,mcp__github__search_repositories,mcp__github__search_users"
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_env: |
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          max_turns: 50
          mcp_config: /tmp/mcp-config/mcp-servers.json
          prompt_file: /tmp/aw-prompts/prompt.txt
          timeout_minutes: 20
      - name: Capture Agentic Action logs
        if: always()
        run: |
          # Copy the detailed execution file from Agentic Action if available
          if [ -n "${{ steps.agentic_execution.outputs.execution_file }}" ] && [ -f "${{ steps.agentic_execution.outputs.execution_file }}" ]; then
            cp ${{ steps.agentic_execution.outputs.execution_file }} /tmp/tech-debt-collector.log
          else
            echo "No execution file output found from Agentic Action" >> /tmp/tech-debt-collector.log
          fi
          
          # Ensure log file exists
          touch /tmp/tech-debt-collector.log
      - name: Check if workflow-complete.txt exists, if so upload it
        id: check_file
        run: |
          if [ -f workflow-complete.txt ]; then
            echo "File exists"
            echo "upload=true" >> $GITHUB_OUTPUT
          else
            echo "File does not exist"
            echo "upload=false" >> $GITHUB_OUTPUT
          fi
      - name: Upload workflow-complete.txt
        if: steps.check_file.outputs.upload == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: workflow-complete
          path: workflow-complete.txt
      - name: Upload agentic engine logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tech-debt-collector.log
          path: /tmp/tech-debt-collector.log
          if-no-files-found: warn
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn

